Compiling Program: A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Order.src
Memory Available: 2147483646
1>Use OrderPrecompile.pkg
Using pre-compiled package ORDERPRECOMPILE.PKG
Including file: OrderPrecompile.pkd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\OrderPrecompile.pkd)
75734>
75734>Use DfAllent.pkg
75734>Use cCJStandardCommandBarSystem.pkg
75734>Use cToolTipController.pkg
75734>Use cCJCommandBarSystem.pkg
75734>
75734>Object oHtmlHelp is a cHtmlHelp
75736>End_Object
75737>
75737>Object oApplication is a cApplication
75739>    Set psCompany to "Data Access Worldwide"
75740>    Set psProduct to "DataFlex Examples"
75741>    Set psVersion to "18.2"
75742>    Set psProgram to "Order"
75743>    Set psHelpFile to "Examples.chm"
75744>    Set peHelpType to htHtmlHelp
75745>End_Object
75746>
75746>Object oToolTipController is a cToolTipController
75748>    Move Self to ghoToolTipController
75749>End_Object
75750>
75750>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oEditContextMenu.pkg)
75750>>>Use cCJStandardMenuItemClasses.pkg
75750>>>
75750>>>Object oEditContextMenu is a cCJContextMenu
75752>>>    
75752>>>    Move Self to Default_Form_Floating_Menu_ID
75753>>>    
75753>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75755>>>    End_Object
75756>>>    
75756>>>    Object oCutMenuItem is a cCJCutMenuItem
75758>>>        Set pbControlBeginGroup to True
75759>>>    End_Object
75760>>>    
75760>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75762>>>    End_Object
75763>>>
75763>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75765>>>    End_Object
75766>>>
75766>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75768>>>    End_Object
75769>>>
75769>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75771>>>        Set pbControlBeginGroup to True
75772>>>    End_Object
75773>>>
75773>>>End_Object
75774>>>
75774>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\oDEOEditContextMenu17.pkg)
75774>>>Use Windows.pkg
75774>>>Use cCJStandardMenuItemClasses.pkg
75774>>>Use cCJDeoMenuItemClasses.pkg
75774>>>
75774>>>
75774>>>Object oDEOEditContextMenu17 is a cCJContextMenu
75776>>>    
75776>>>    Move Self to Default_dbFloating_Menu_ID
75777>>>    
75777>>>    Object oUndoMenuItem is a cCJUndoMenuItem
75779>>>    End_Object
75780>>>    
75780>>>    Object oCutMenuItem is a cCJCutMenuItem
75782>>>        Set pbControlBeginGroup to True
75783>>>    End_Object
75784>>>    
75784>>>    Object oCopyMenuItem is a cCJCopyMenuItem
75786>>>    End_Object
75787>>>
75787>>>    Object oPasteMenuItem is a cCJPasteMenuItem
75789>>>    End_Object
75790>>>
75790>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
75792>>>    End_Object
75793>>>
75793>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
75795>>>        Set pbControlBeginGroup to True
75796>>>    End_Object
75797>>>
75797>>>    Object oPromptMenuItem is a cCJPromptMenuItem
75799>>>        Set pbControlBeginGroup to True
75800>>>    End_Object
75801>>>
75801>>>    Object oFindNextMenu is a cCJFindNextMenuItem
75803>>>        Set pbControlBeginGroup to True
75804>>>    End_Object
75805>>>
75805>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75807>>>    End_Object
75808>>>
75808>>>    Object oClearMenuItem is a cCJClearMenuItem
75810>>>        Set pbControlBeginGroup to True
75811>>>    End_Object
75812>>>
75812>>>    Object oClearAllMenu is a cCJClearAllMenuItem
75814>>>    End_Object
75815>>>
75815>>>    Object oSaveMenu is a cCJSaveMenuItem
75817>>>    End_Object
75818>>>    
75818>>>    Object oDeleteMenu is a cCJDeleteMenuItem
75820>>>    End_Object
75821>>>
75821>>>    Object oRememberitem is a cCJRememberFieldMenuItem
75823>>>        Set pbControlBeginGroup to True
75824>>>    End_Object
75825>>>
75825>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
75827>>>    End_Object
75828>>>
75828>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
75830>>>    End_Object
75831>>>
75831>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
75833>>>    End_Object
75834>>>
75834>>>End_Object
75835>
75835>Object oMain is a Panel
75837>    Set Label to "Order Entry Sample Application"
75838>    Set Location to 4 3
75839>    Set Size to 300 450
75840>
75840>    Object oCommandBarSystem is a cCJCommandBarSystem
75842>    
75842>        Set pbTimerUpdate to True
75843>    
75843>        Procedure OnCreateCommandBars
75846>            Handle hoOptions
75846>            Get OptionsObject to hoOptions
75847>            Forward Send OnCreateCommandBars
75849>        End_Procedure
75850>    
75850>        Object oMenuBar is a cCJMenuBar
75852>            
75852>            Object oFileMenu is a cCJMenuItem
75854>                
75854>                Set peControlType to xtpControlPopup          
75855>                Set psCaption   to "&File"
75856>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
75857>                Set psCategory to "Menus"
75858>    
75858>                Object oClearMenuItem is a cCJClearMenuItem
75860>                    Set pbAddToDesignerMenu to True
75861>                End_Object
75862>    
75862>                Object oClearAllMenu is a cCJClearAllMenuItem
75864>                    Set pbAddToDesignerMenu to True
75865>                End_Object
75866>    
75866>                Object oPromptMenuItem is a cCJPromptMenuItem
75868>                    Set pbAddToDesignerMenu to True
75869>                    Set pbControlBeginGroup to True
75870>                End_Object
75871>    
75871>                Object oFindMenuItem is a cCJFindMenuItem
75873>                    Set pbAddToDesignerMenu to True
75874>                    Set pbControlBeginGroup to True
75875>                End_Object
75876>    
75876>                Object oFindNextMenu is a cCJFindNextMenuItem
75878>                    Set pbAddToDesignerMenu to True
75879>                End_Object
75880>    
75880>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
75882>                    Set pbAddToDesignerMenu to True
75883>                End_Object
75884>    
75884>                Object oFindFirstMenu is a cCJFindFirstMenuItem
75886>                    Set pbAddToDesignerMenu to True
75887>                End_Object
75888>    
75888>                Object oFindLastMenu is a cCJFindLastMenuItem
75890>                    Set pbAddToDesignerMenu to True
75891>                End_Object
75892>    
75892>                Object oSaveMenuItem is a cCJSaveMenuItem
75894>                    Set pbAddToDesignerMenu to True
75895>                    Set pbControlBeginGroup to True
75896>                End_Object
75897>    
75897>                Object oDeleteMenuItem is a cCJDeleteMenuItem
75899>                    Set pbAddToDesignerMenu to True
75900>                End_Object
75901>    
75901>                Object oExitMenu is a cCJExitMenuItem
75903>                    Set pbControlBeginGroup to True
75904>                End_Object
75905>    
75905>            End_Object
75906>            
75906>            Object oViewMenu is a cCJMenuItem
75908>                
75908>                Set peControlType to xtpControlPopup
75909>                Set psCaption to "&View"
75910>                Set psToolTip to "View"
75911>                Set psDescription to "Available Views"
75912>    
75912>                Object oCustomerEntryViewMenuItem is a cCJMenuItem
75914>                    Set psCaption to "Customer Entry View"
75915>                    Set psShortcut to "Ctrl+1"
75916>                    Set psDescription to "Add, edit and delete Customer data."
75917>                    Set psToolTip to "Customer Entry View"
75918>                
75918>                    Procedure OnExecute Variant vCommandBarControl
75921>                        Handle hoClient
75921>                        Get Client_Id to hoClient
75922>                        Send Activate_oCustomerView of hoClient
75923>                    End_Procedure
75924>                End_Object
75925>    
75925>                Object oInventoryItemViewMenuItem is a cCJMenuItem
75927>                    Set psCaption to "Inventory Item View"
75928>                    Set psShortcut to "Ctrl+2"
75929>                    Set psDescription to "Add, edit and delete Inventory data."
75930>                    Set psToolTip to "Inventory Item View"
75931>                
75931>                    Procedure OnExecute Variant vCommandBarControl
75934>                        Handle hoClient
75934>                        Get Client_Id to hoClient
75935>                        Send Activate_oInventoryView of hoClient
75936>                    End_Procedure
75937>                End_Object
75938>    
75938>                Object oOrderEntryMenuItem is a cCJMenuItem
75940>                    Set psCaption to "Order Entry"
75941>                    Set psShortcut to "Ctrl+3"
75942>                    Set psDescription to "Add, edit and delete Order data."
75943>                    Set psToolTip to "Order Entry"
75944>                
75944>                    Procedure OnExecute Variant vCommandBarControl
75947>                        Handle hoClient
75947>                        Get Client_Id to hoClient
75948>                        Send Activate_oOrderEntryView of hoClient
75949>                    End_Procedure
75950>                End_Object
75951>    
75951>                Object oSalesPersonEntryViewMenuItem is a cCJMenuItem
75953>                    Set psCaption to "Sales Person Entry View"
75954>                    Set psShortcut to "Ctrl+4"
75955>                    Set psDescription to "Add, edit and delete Sales Person data."
75956>                    Set psToolTip to "Sales Person Entry View"
75957>                
75957>                    Procedure OnExecute Variant vCommandBarControl
75960>                        Handle hoClient
75960>                        Get Client_Id to hoClient
75961>                        Send Activate_oSalesPersonView of hoClient
75962>                    End_Procedure
75963>                End_Object
75964>    
75964>                Object oVendorEntryViewMenuItem is a cCJMenuItem
75966>                    Set psCaption to "Vendor Entry View"
75967>                    Set psShortcut to "Ctrl+5"
75968>                    Set psDescription to "Add, edit and delete Vendor data."
75969>                    Set psToolTip to "Vendor Entry View"
75970>                
75970>                    Procedure OnExecute Variant vCommandBarControl
75973>                        Handle hoClient
75973>                        Get Client_Id to hoClient
75974>                        Send Activate_oVendorView of hoClient
75975>                    End_Procedure
75976>                End_Object
75977>    
75977>            End_Object
75978>            
75978>            Object oReportMenu is a cCJMenuItem
75980>                
75980>                Set peControlType to xtpControlPopup          
75981>                Set psCaption to "&Report"
75982>                Set psToolTip to "Report"
75983>                Set psDescription to "Available Reports"
75984>    
75984>                Object oBasicReportsMenuItem is a cCJMenuItem
75986>                    Set psCaption to "Basic Reports"
75987>                    Set peControlType to xtpControlPopup
75988>                    Set psToolTip to "Basic Reports"
75989>                    Set psDescription to "Reports based on the Basic Report class."
75990>    
75990>                    Object oCustomerListMenuItem is a cCJMenuItem
75992>                        Set psCaption to "Customer List"
75993>                        Set psToolTip to "Customer List (Basic)"
75994>                    
75994>                        Procedure OnExecute Variant vCommandBarControl
75997>                            Handle hoClient
75997>                            Get Client_Id to hoClient
75998>                            Send Activate_oCustomerListBR of hoClient
75999>                        End_Procedure
76000>                    End_Object
76001>                End_Object
76002>    
76002>                Object oWinPrintReportsMenuItem is a cCJMenuItem
76004>                    Set psCaption to "WinPrint Reports"
76005>                    Set peControlType to xtpControlPopup
76006>                    Set psToolTip to "WinPrint Reports"
76007>                    Set psDescription to "Reports based on the WinPrint class."
76008>    
76008>                    Object oCustomerListMenuItem2 is a cCJMenuItem
76010>                        Set psCaption to "Customer List"
76011>                        Set psShortcut to "Ctrl+6"
76012>                        Set psToolTip to "Customer List (WinPrint)"
76013>                        Set psDescription to "Print Customer data."
76014>                    
76014>                        Procedure OnExecute Variant vCommandBarControl
76017>                            Handle hoClient
76017>                            Get Client_Id to hoClient
76018>                            Send Activate_oCustomerListWP of hoClient
76019>                        End_Procedure
76020>                    End_Object
76021>    
76021>                    Object oItemsperOrderMenuItem is a cCJMenuItem
76023>                        Set psCaption to "Items per Order"
76024>                        Set psShortcut to "Ctrl+7"
76025>                        Set psToolTip to "Items per Order (WinPrint)"
76026>                        Set psDescription to "Print line items for all Orders."
76027>                    
76027>                        Procedure OnExecute Variant vCommandBarControl
76030>                            Handle hoClient
76030>                            Get Client_Id to hoClient
76031>                            Send Activate_oItemsPerOrderWP of hoClient
76032>                        End_Procedure
76033>                    End_Object
76034>    
76034>                    Object oOrdersbyCustomerMenuItem1 is a cCJMenuItem
76036>                        Set psCaption to "Orders by Customer"
76037>                        Set psShortcut to "Ctrl+8"
76038>                        Set psToolTip to "Orders by Customer (WinPrint)"
76039>                        Set psDescription to "Print Order data sorted by Customer."
76040>                    
76040>                        Procedure OnExecute Variant vCommandBarControl
76043>                            Handle hoClient
76043>                            Get Client_Id to hoClient
76044>                            Send Activate_oOrdersByCustomerWP of hoClient
76045>                        End_Procedure
76046>                    End_Object
76047>    
76047>                    Object oOrdersbyOrderNumberMenuItem is a cCJMenuItem
76049>                        Set psCaption to "Orders by Order Number"
76050>                        Set psShortcut to "Ctrl+9"
76051>                        Set psToolTip to "Orders by Order Number (WinPrint)"
76052>                        Set psDescription to "Print Order data."
76053>                    
76053>                        Procedure OnExecute Variant vCommandBarControl
76056>                            Handle hoClient
76056>                            Get Client_Id to hoClient
76057>                            Send Activate_oOrdersWP of hoClient
76058>                        End_Procedure
76059>                    End_Object
76060>                End_Object
76061>    
76061>            End_Object
76062>                        
76062>            Object oNavigateMenu is a cCJMenuItem
76064>                Set peControlType to xtpControlPopup      
76065>                Set psCaption to "&Navigate"    
76066>                Set psTooltip to "Navigate"    
76067>                Set psDescription to "Move to different areas of the application"
76068>                
76068>                Object oNextAreaMenu is a cCJNextAreaMenu
76070>                End_Object
76071>                
76071>                Object oPriorAreaMenu is a cCJPriorAreaMenu
76073>                End_Object
76074>                
76074>                Object oNextViewMenu is a cCJNextViewMenu
76076>                End_Object
76077>                
76077>                Object oPriorViewMenu is a cCJPriorViewMenu
76079>                End_Object
76080>                
76080>                Object oPromptMenu is a cCJPromptMenuItem
76082>                    Set pbControlBeginGroup to True
76083>                End_Object
76084>    
76084>                Object oZoomMenu is a cCJZoomMenuItem
76086>                End_Object
76087>    
76087>            End_Object
76088>    
76088>            Object oWindowMenu is a cCJMDIWindowsMenuItem
76090>                Set peControlType to xtpControlPopup      
76091>                Set psCaption to "&Window"
76092>                Set psToolTip to "Window"
76093>                Set psDescription to "Display Current Views and set other display options."    
76094>                
76094>                // These are the static windows items. More will be created in onInitPopup 
76094>                Object oDisplayOptionsMenu is a cCJMenuItem
76096>                    Set peControlType to xtpControlPopup          
76097>                    Set psCaption to "&Display Options"
76098>                    Set psToolTip to "Display Options"
76099>                    Set psDescription to "Set display options"
76100>    
76100>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
76102>                    End_Object
76103>    
76103>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
76105>                    End_Object
76106>    
76106>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
76108>                        Set pbControlBeginGroup to True
76109>                    End_Object
76110>                    
76110>                End_Object
76111>        
76111>                Object oCascadeMenu is a cCJCascadeMenuItem
76113>                    Set pbControlBeginGroup to True
76114>                End_Object
76115>    
76115>                Object oHorizTile is a cCJTileHorizontally
76117>                End_Object
76118>    
76118>                Object oVertTile is a cCJTileVertically
76120>                End_Object
76121>    
76121>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
76123>                    Set pbControlBeginGroup to True
76124>                End_Object
76125>    
76125>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
76127>                End_Object
76128>    
76128>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
76130>                    Set pbControlBeginGroup to True
76131>                End_Object
76132>    
76132>            End_Object
76133>
76133>            Object oDemoMenuItem is a cCJMenuItem
76135>                Set psCaption to "&Demo"
76136>                Set psTooltip to "&Demo"
76137>                Set peControlType to xtpControlPopup
76138>                
76138>                Object oParentComboDemoMenuItem is a cCJMenuItem
76140>                    Set psCaption to "Parent Combo Demo"
76141>                    Set psTooltip to "Parent Combo Demo"
76142>                
76142>                    Procedure OnExecute Variant vCommandBarControl
76145>                        Handle hoClient
76145>                        Get Client_Id to hoClient
76146>                        Send Activate_oDemoParentCombos of hoClient
76147>                    End_Procedure
76148>                End_Object
76149>
76149>                Object oSuggestionFormMenuItem is a cCJMenuItem
76151>                    Set psCaption to "Suggestion Form"
76152>                    Set psTooltip to "Suggestion Form"
76153>                
76153>                    Procedure OnExecute Variant vCommandBarControl
76156>                        Handle hoClient
76156>                        Get Client_Id to hoClient
76157>                        Send Activate_oDemoSuggestionForm of hoClient
76158>                    End_Procedure
76159>                End_Object
76160>
76160>                Object oButtonSamplesMenuItem is a cCJMenuItem
76162>                    Set psCaption to "Button Samples"
76163>                    Set psTooltip to "Button Samples"
76164>                
76164>                    Procedure OnExecute Variant vCommandBarControl
76167>                        Handle hoClient
76167>                        Get Client_Id to hoClient
76168>                        Send Activate_oButtonTest of hoClient
76169>                    End_Procedure
76170>                End_Object
76171>
76171>                Object oCalendarControlSampleMenuItem is a cCJMenuItem
76173>                          Set psCaption to "Calendar Control Sample"
76174>                          Set psTooltip to "Calendar Control Sample"
76175>                
76175>                          Procedure OnExecute Variant vCommandBarControl
76178>                                    Handle hoClient
76178>                                    Get Client_Id to hoClient
76179>                                    Send Activate_oDemoCalendarControl of hoClient
76180>                          End_Procedure
76181>                End_Object
76182>            End_Object
76183>            
76183>            Object oHelpMenu is a cCJMenuItem
76185>                Set peControlType to xtpControlPopup    
76186>                Set psCaption to "&Help"
76187>                Set psDescription to "Access Information for learning and using this DataFlex application."
76188>                Set psToolTip to "Help"
76189>                
76189>                Object oHelpMenuItem is a cCJHelpMenuItem 
76191>                End_Object
76192>    
76192>                Object oAboutMenuItem is a cCJAboutMenuItem
76194>                End_Object
76195>           
76195>            End_Object
76196>    
76196>        End_Object
76197>    
76197>        Object oFindToolBar is a cCJToolbar
76199>            Set psTitle to "Finding Toolbar"
76200>    
76200>            Object oFindFirstTool is a cCJFindFirstMenuItem
76202>            End_Object
76203>    
76203>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
76205>            End_Object
76206>    
76206>            Object oFindMenuTool is a cCJFindMenuItem
76208>            End_Object
76209>    
76209>            Object oFindNextTool is a cCJFindNextMenuItem
76211>            End_Object
76212>    
76212>            Object oFindLastTool is a cCJFindLastMenuItem
76214>            End_Object
76215>    
76215>            Object oPromptToolItem is a cCJPromptMenuItem
76217>                Set pbControlBeginGroup to True
76218>            End_Object
76219>    
76219>        End_Object
76220>            
76220>        Object oFileToolBar is a cCJToolbar
76222>            Set psTitle to "Data Entry Toolbar"
76223>    
76223>            Object oClearToolItem is a cCJClearMenuItem
76225>                Set peControlStyle to xtpButtonIconAndCaption
76226>            End_Object
76227>            
76227>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
76229>                Set peControlStyle to xtpButtonIconAndCaption
76230>            End_Object
76231>                
76231>            Object oSaveToolItem is a cCJSaveMenuItem
76233>                Set peControlStyle to xtpButtonIconAndCaption
76234>                Set pbControlBeginGroup to True
76235>            End_Object
76236>    
76236>            Object oDeleteToolItem is a cCJDeleteMenuItem
76238>                Set peControlStyle to xtpButtonIconAndCaption
76239>            End_Object
76240>    
76240>        End_Object
76241>    
76241>        Object oEditToolBar is a cCJToolbar
76243>            Set psTitle to "Edit Toolbar"
76244>            
76244>            Object oCutToolbarItem is a cCJCutMenuItem
76246>            End_Object
76247>    
76247>            Object oCopyToolbarItem is a cCJCopyMenuItem
76249>            End_Object
76250>    
76250>            Object oPasteToolbarItem is a cCJPasteMenuItem
76252>            End_Object
76253>    
76253>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
76255>                Set pbControlBeginGroup to True
76256>            End_Object
76257>    
76257>        End_Object
76258>                
76258>        Object oRememberToolbar is a cCJToolbar
76260>            Set psTitle to "Remember Toolbar"
76261>
76261>            Object oRememberItems is a cCJMenuItem
76263>
76263>                Set peControlType to xtpControlPopup
76264>                Set peControlStyle to xtpButtonCaption
76265>                Set psCaption to C_$Remember
76266>                
76266>                Object oMenuItem is a cCJRememberFieldMenuItem
76268>                    Set peControlStyle to xtpButtonIconAndCaption
76269>                End_Object
76270>                
76270>                Object oMenuItem is a cCJRememberLastFieldMenuItem
76272>                    Set peControlStyle to xtpButtonIconAndCaption
76273>                End_Object
76274>                
76274>                Object oMenuItem is a cCJUnRememberFieldMenuItem
76276>                    Set peControlStyle to xtpButtonIconAndCaption
76277>                End_Object
76278>                
76278>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
76280>                    Set peControlStyle to xtpButtonIconAndCaption
76281>                End_Object
76282>
76282>            End_Object
76283>
76283>        End_Object
76284>
76284>
76284>        Object oStatusBar is a cCJStatusBar
76286>            
76286>            Object oStatusPane1 is a cCJStatusBarPane
76288>                Set piID to sbpIDIdlePane
76289>                Set pbStyleStretch to True
76290>            End_Object
76291>    
76291>            Object oStatusPane2 is a cCJStatusBarPane
76293>                Set phoViewPane to Self
76294>                Set pbStyleStretch to True
76295>            End_Object
76296>    
76296>        End_Object
76297>    
76297>    End_Object
76298>
76298>    Object oClientArea is a ClientArea
76300>        Use Customer.vw
Including file: Customer.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Customer.vw)
76300>>>Use dfClient.pkg
76300>>>Use DataDict.pkg
76300>>>Use dfEntry.pkg
76300>>>Use dfTabDlg.pkg
76300>>>Use dfCEntry.pkg
76300>>>Use cDbTextEdit.Pkg
76300>>>Use Customer.DD
Including file: Customer.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Customer.dd)
76300>>>>>Use Windows.pkg           // Basic Definitions
76300>>>>>Use DataDict.pkg          // DataDictionary Class Definition
76300>>>>>Use DDvalTbl.pkg          // Validation Table Class Definitions
76300>>>>>
76300>>>>>Open Customer
Including file: Customer.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Customer.fd)
76302>>>>>Open OrderHea
Including file: OrderHea.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\OrderHea.fd)
76304>>>>>Open Ordsys
Including file: OrdSys.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\OrdSys.fd)
76306>>>>>
76306>>>>>
76306>>>>>Register_Object Customer_State_VT
76306>>>>>Register_Object Customer_sl
76306>>>>>
76306>>>>>Object Customer_State_VT  is a CodeValidationTable
76308>>>>>    Set Type_Value        To "STATES"
76309>>>>>    Set Table_Title       To "States"
76310>>>>>End_Object   // Customer_State_VT
76311>>>>>
76311>>>>>Register_Function ValidateEmail Integer iColumn String sValue Returns Boolean
76311>>>>>
76311>>>>>Class Customer_DataDictionary Is A DataDictionary
76312>>>>>
76312>>>>>    Procedure Construct_Object
76314>>>>>        Forward Send Construct_Object
76316>>>>>
76316>>>>>        Set Main_File To Customer.File_Number
76317>>>>>        Set Cascade_Delete_State To False
76318>>>>>
76318>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76319>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76320>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76321>>>>>
76321>>>>>        Set Add_Client_File to OrderHea.File_Number
76322>>>>>
76322>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76323>>>>>
76323>>>>>        Set Field_Auto_Increment Field Customer.Customer_Number to File_Field Ordsys.Cust_Number
76324>>>>>        Set Field_Label_Long Field Customer.Customer_Number To "Customer Number"
76325>>>>>        Set Field_Label_Short Field Customer.Customer_Number To "Number"
76326>>>>>        Set Field_Option Field Customer.Customer_Number DD_AUTOFIND to True
76327>>>>>        Set Field_Option Field Customer.Customer_Number DD_NOPUT to True
76328>>>>>        Set Field_Prompt_Object Field Customer.Customer_Number to Customer_sl
76329>>>>>        Set Key_Field_State Field Customer.Customer_Number To True
76330>>>>>        Set Status_Help Field Customer.Customer_Number To "Customer Id Number (system assigned)."
76331>>>>>
76331>>>>>        Set Field_Label_Long Field Customer.Name To "Customer Name"
76332>>>>>        Set Field_Label_Short Field Customer.Name To "Customer Name"
76333>>>>>        Set Field_Option Field Customer.Name DD_REQUIRED to True
76334>>>>>        Set Field_Prompt_Object Field Customer.Name to Customer_sl
76335>>>>>        Set Status_Help Field Customer.Name To "Customer/Company Name."
76336>>>>>
76336>>>>>        Set Field_Label_Long Field Customer.Address To "Street Address"
76337>>>>>        Set Field_Label_Short Field Customer.Address To "Address"
76338>>>>>        Set Status_Help Field Customer.Address To "Street Address."
76339>>>>>
76339>>>>>        Set Status_Help Field Customer.City To "City Name."
76340>>>>>
76340>>>>>        Set Field_Class_Name Field Customer.State To "dbComboForm"
76341>>>>>        Set Field_Label_Long Field Customer.State To "State"
76342>>>>>        Set Field_Label_Short Field Customer.State To "St."
76343>>>>>        Set Field_Option Field Customer.State DD_CAPSLOCK to True
76344>>>>>        Set Field_Value_Table Field Customer.State to Customer_State_VT
76345>>>>>        Set Status_Help Field Customer.State To "Two letter state ID."
76346>>>>>
76346>>>>>        Set Field_Label_Long Field Customer.Zip To "Zip/Postal Code"
76347>>>>>        Set Field_Label_Short Field Customer.Zip To "Zip"
76348>>>>>        Set Field_Mask Field Customer.Zip To "#####-####"
76349>>>>>        Set Field_Mask_Type Field Customer.Zip To MASK_WINDOW
76350>>>>>        Set Status_Help Field Customer.Zip To "Zip or Postal Code."
76351>>>>>
76351>>>>>        Set Field_Label_Long Field Customer.Phone_Number To "Phone Number"
76352>>>>>        Set Field_Label_Short Field Customer.Phone_Number To "Phone"
76353>>>>>        Set Status_Help Field Customer.Phone_Number To "Phone Number."
76354>>>>>
76354>>>>>        Set Field_Label_Long Field Customer.Fax_Number To "Fax Number"
76355>>>>>        Set Field_Label_Short Field Customer.Fax_Number To "Fax"
76356>>>>>        Set Status_Help Field Customer.Fax_Number To "Fax Phone Number."
76357>>>>>
76357>>>>>        Set Field_Label_Long Field Customer.Email_Address To "E-Mail Address"
76358>>>>>        Set Field_Label_Short Field Customer.Email_Address To "E-Mail"
76359>>>>>        Set Status_Help Field Customer.Email_Address To "E-mail Address (internet)."
76360>>>>>        Set Field_Validate_msg Field Customer.EMail_Address to (RefFunc(ValidateEmail))
76361>>>>>        Set Field_Option Field Customer.EMail_Address DD_REQUIRED to True
76362>>>>>
76362>>>>>        Set Field_Class_Name Field Customer.Credit_Limit To "dbSpinForm"
76363>>>>>        Set Field_Mask_Type Field Customer.Credit_Limit To MASK_CURRENCY_WINDOW
76364>>>>>
76364>>>>>        Set Field_Label_Long Field Customer.Purchases To "Total Purchases"
76365>>>>>        Set Field_Label_Short Field Customer.Purchases To "Purchases"
76366>>>>>        Set Field_Mask_Type Field Customer.Purchases To MASK_CURRENCY_WINDOW
76367>>>>>        Set Field_Option Field Customer.Purchases DD_DISPLAYONLY to True
76368>>>>>
76368>>>>>        Set Field_Label_Long Field Customer.Balance To "Balance Due"
76369>>>>>        Set Field_Label_Short Field Customer.Balance To "Balance"
76370>>>>>        Set Field_Mask_Type Field Customer.Balance To MASK_CURRENCY_WINDOW
76371>>>>>        Set Field_Option Field Customer.Balance DD_DISPLAYONLY to True
76372>>>>>
76372>>>>>        Set Status_Help Field Customer.Comments To "Additional Comments and Notes."
76373>>>>>
76373>>>>>        Set Field_Checkbox_Values Field Customer.Status To "Y" "N"
76374>>>>>        Set Field_Label_Long Field Customer.Status To "Active Status"
76375>>>>>        Set Field_Label_Short Field Customer.Status To "Status"
76376>>>>>        Set Status_Help Field Customer.Status To "Active Inactive Status of customer"
76377>>>>>
76377>>>>>    End_Procedure  //  Construct_Object
76378>>>>>
76378>>>>>    Procedure Field_defaults
76380>>>>>        Forward Send Field_Defaults
76382>>>>>        Set Field_Changed_Value   Field Customer.State To "FL"
76383>>>>>        Set Field_Changed_Value   Field Customer.Credit_Limit To 1000
76384>>>>>        Set Field_Changed_Value   Field Customer.Status To "Y"
76385>>>>>    End_Procedure
76386>>>>>
76386>>>>>    //
76386>>>>>    //  Validates if the field contains a valid email address (it allows empty values to).
76386>>>>>    //
76386>>>>>    Function ValidateEmail Integer iColumn String sValue Returns Boolean
76388>>>>>        Integer iAt iDot
76388>>>>>        Boolean bResult
76388>>>>>        
76388>>>>>        If (Trim(sValue) <> "") Begin
76390>>>>>            Move (Pos("@", sValue)) to iAt
76391>>>>>            Move (RightPos(".", sValue)) to iDot
76392>>>>>            
76392>>>>>            If (not(iAt > 1 and iDot > 0 and iDot > iAt + 1 and iDot < Length(sValue))) Begin
76394>>>>>                Send Data_set_error iColumn DFERR_OPERATOR "Please enter a valid email address"
76395>>>>>                Move True to bResult
76396>>>>>            End
76396>>>>>>
76396>>>>>        End
76396>>>>>>
76396>>>>>        
76396>>>>>        Function_Return bResult
76397>>>>>    End_Function
76398>>>>>
76398>>>>>End_Class    //  Customer_DataDictionary
76399>>>>>
76399>>>>>
76399>>>>>Use Customer.sl      // Customer_sl
Including file: Customer.sl    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Customer.sl)
76399>>>>>>>Use DFClient.pkg
76399>>>>>>>Use DFSelLst.pkg
76399>>>>>>>Use Windows.pkg
76399>>>>>>>Use cDbCJGridPromptList.pkg
76399>>>>>>>
76399>>>>>>>Use Customer.DD
76399>>>>>>>
76399>>>>>>>CD_Popup_Object Customer_sl is a dbModalPanel
76417>>>>>>>>
76417>>>>>>>
76417>>>>>>>    Set Border_Style to Border_Thick
76418>>>>>>>    Set Minimize_Icon to False
76419>>>>>>>    Set Label to "Customer List"
76420>>>>>>>    Set Size to 134 238
76421>>>>>>>    Set Location to 4 5
76422>>>>>>>    Set piMinSize to 134 238
76423>>>>>>>
76423>>>>>>>    Object Customer_DD is a Customer_DataDictionary
76425>>>>>>>    End_Object    // Customer_DD
76426>>>>>>>
76426>>>>>>>    Set Main_DD to Customer_DD
76427>>>>>>>    Set Server to Customer_DD
76428>>>>>>>
76428>>>>>>>    Object oSelList is a cDbCJGridPromptList
76430>>>>>>>        Set Size to 100 224
76431>>>>>>>        Set Location to 9 8
76432>>>>>>>        Set peAnchors to anAll
76433>>>>>>>        Set pbAllowColumnRemove to False
76434>>>>>>>
76434>>>>>>>        Object oNumber is a cDbCJGridColumn
76436>>>>>>>            Entry_Item Customer.Customer_Number
76437>>>>>>>            Set piWidth to 93
76438>>>>>>>            Set psCaption to "Number"
76439>>>>>>>        End_Object
76440>>>>>>>
76440>>>>>>>        Object oCustomerName is a cDbCJGridColumn
76442>>>>>>>            Entry_Item Customer.Name
76443>>>>>>>            Set piWidth to 243
76444>>>>>>>            Set psCaption to "Customer Name"
76445>>>>>>>        End_Object
76446>>>>>>>    End_Object  // oSelList
76447>>>>>>>
76447>>>>>>>    Object oOK_bn is a Button
76449>>>>>>>        Set Label to "&Ok"
76450>>>>>>>        Set Location to 116 77
76451>>>>>>>        Set peAnchors to anBottomRight
76452>>>>>>>
76452>>>>>>>        Procedure OnClick
76455>>>>>>>            Send OK of oSelList
76456>>>>>>>        End_Procedure
76457>>>>>>>
76457>>>>>>>    End_Object    // oOK_bn
76458>>>>>>>
76458>>>>>>>    Object oCancel_bn is a Button
76460>>>>>>>        Set Label to "&Cancel"
76461>>>>>>>        Set Location to 116 130
76462>>>>>>>        Set peAnchors to anBottomRight
76463>>>>>>>
76463>>>>>>>        Procedure OnClick
76466>>>>>>>            Send Cancel of oSelList
76467>>>>>>>        End_Procedure
76468>>>>>>>
76468>>>>>>>    End_Object    // oCancel_bn
76469>>>>>>>
76469>>>>>>>    Object oSearch_bn is a Button
76471>>>>>>>        Set Label to "&Search..."
76472>>>>>>>        Set Location to 116 183
76473>>>>>>>        Set peAnchors to anBottomRight
76474>>>>>>>
76474>>>>>>>        Procedure OnClick
76477>>>>>>>            Send Search of oSelList
76478>>>>>>>        End_Procedure
76479>>>>>>>
76479>>>>>>>    End_Object    // oSearch_bn
76480>>>>>>>
76480>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76481>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76482>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76483>>>>>>>
76483>>>>>>>CD_End_Object    // Customer_sl
76485>>>>>>>>
76485>>>>>
76485>>>>>
76485>>>
76485>>>DEFERRED_VIEW Activate_oCustomerView FOR ;;Object oCustomerView is a dbView
76510>>>    Set Border_Style to Border_Thick
76511>>>    Set Label to "Customer Entry View"
76512>>>    Set Location to 7 23
76513>>>    Set Size to 146 277
76514>>>    Set piMaxSize to 300 350
76515>>>    Set piMinSize to 146 277
76516>>>
76516>>>    Object Customer_DD is a Customer_DataDictionary
76518>>>    End_Object    // Customer_DD
76519>>>
76519>>>    Set Main_DD to Customer_DD
76520>>>    Set Server to Customer_DD
76521>>>
76521>>>    Object oCustomer_Number is a dbForm
76523>>>        Entry_Item Customer.Customer_Number
76524>>>        Set Label to "Customer Number:"
76525>>>        Set Size to 13 42
76526>>>        Set Location to 5 72
76527>>>        Set peAnchors to anTopLeft
76528>>>        Set Label_Col_Offset to 2
76529>>>        Set Label_Justification_Mode to jMode_Right
76530>>>    End_Object    // oCustomer_Number
76531>>>
76531>>>    Object oCustomer_Name is a dbForm
76533>>>        Entry_Item Customer.Name
76534>>>        Set Label to "Name:"
76535>>>        Set Size to 13 186
76536>>>        Set Location to 20 72
76537>>>        Set peAnchors to anTopLeftRight
76538>>>        Set Label_Col_Offset to 2
76539>>>        Set Label_Justification_Mode to jMode_Right
76540>>>    End_Object    // oCustomer_Name
76541>>>
76541>>>    Object oCustTD is a dbTabDialog
76543>>>        Set Size to 105 265
76544>>>        Set Location to 36 7
76545>>>        Set Rotate_Mode to RM_Rotate
76546>>>        Set peAnchors to anAll
76547>>>        Object oAddress_TP is a dbTabPage
76549>>>            Set Label to "Address"
76550>>>            Set Tab_ToolTip_Value to "Customer contact information"
76551>>>            Object oCustomer_Address is a dbForm
76553>>>                Entry_Item Customer.Address
76554>>>                Set Label to "Street Address:"
76555>>>                Set Size to 13 180
76556>>>                Set Location to 8 62
76557>>>                Set peAnchors to anTopLeftRight
76558>>>                Set Label_Col_Offset to 2
76559>>>                Set Label_Justification_Mode to jMode_Right
76560>>>            End_Object    // oCustomer_Address
76561>>>
76561>>>            Object oCustomer_City is a dbForm
76563>>>                Entry_Item Customer.City
76564>>>                Set Label to "City/State/Zip:"
76565>>>                Set Size to 13 84
76566>>>                Set Location to 24 62
76567>>>                Set peAnchors to anTopLeftRight
76568>>>                Set Label_Col_Offset to 2
76569>>>                Set Label_Justification_Mode to jMode_Right
76570>>>            End_Object    // oCustomer_City
76571>>>
76571>>>            Object oCustomer_State is a dbComboForm
76573>>>                Entry_Item Customer.State
76574>>>                Set Size to 13 32
76575>>>                Set Location to 24 152
76576>>>                Set peAnchors to anTopRight
76577>>>                Set Form_Border to 0
76578>>>                Set Code_Display_Mode to cb_code_display_code
76579>>>            End_Object    // oCustomer_State
76580>>>
76580>>>            Object oCustomer_Zip is a dbForm
76582>>>                Entry_Item Customer.Zip
76583>>>                Set Size to 13 51
76584>>>                Set Location to 24 191
76585>>>                Set peAnchors to anTopRight
76586>>>            End_Object    // oCustomer_Zip
76587>>>
76587>>>            Object oCustomer_Phone_number is a dbForm
76589>>>                Entry_Item Customer.Phone_Number
76590>>>                Set Label to "Phone Number:"
76591>>>                Set Size to 13 120
76592>>>                Set Location to 39 62
76593>>>                Set peAnchors to anTopLeft
76594>>>                Set Label_Col_Offset to 2
76595>>>                Set Label_Justification_Mode to jMode_Right
76596>>>            End_Object    // oCustomer_Phone_number
76597>>>
76597>>>            Object oCustomer_Fax_number is a dbForm
76599>>>                Entry_Item Customer.Fax_Number
76600>>>                Set Label to "Fax Number:"
76601>>>                Set Size to 13 120
76602>>>                Set Location to 54 62
76603>>>                Set peAnchors to anTopLeft
76604>>>                Set Label_Col_Offset to 2
76605>>>                Set Label_Justification_Mode to jMode_Right
76606>>>            End_Object    // oCustomer_Fax_number
76607>>>
76607>>>            Object oCustomer_Email_address is a dbForm
76609>>>                Entry_Item Customer.EMail_Address
76610>>>                Set Label to "E-Mail Address:"
76611>>>                Set Size to 13 180
76612>>>                Set Location to 69 62
76613>>>                Set peAnchors to anTopLeftRight
76614>>>                Set Label_Col_Offset to 2
76615>>>                Set Label_Justification_Mode to jMode_Right
76616>>>            End_Object    // oCustomer_Email_address
76617>>>
76617>>>        End_Object    // oAddress_TP
76618>>>
76618>>>        Object oBalances_TP is a dbTabPage
76620>>>            Set Label to "Balances"
76621>>>            Set Tab_ToolTip_Value to "Current account balances"
76622>>>            Object oCustomer_Credit_Limit is a dbForm
76624>>>                Entry_Item Customer.Credit_limit
76625>>>                Set Label to "Credit Limit:"
76626>>>                Set Size to 13 48
76627>>>                Set Location to 9 72
76628>>>                Set Label_Col_Offset to 2
76629>>>                Set Label_Justification_Mode to jMode_Right
76630>>>            End_Object    // oCustomer_Credit_Limit
76631>>>
76631>>>            Object oCustomer_Purchases is a dbForm
76633>>>                Entry_Item Customer.Purchases
76634>>>                Set Label to "Total Purchases:"
76635>>>                Set Size to 13 48
76636>>>                Set Location to 24 72
76637>>>                Set Label_Col_Offset to 2
76638>>>                Set Label_Justification_Mode to jMode_Right
76639>>>            End_Object    // oCustomer_Purchases
76640>>>
76640>>>            Object oCustomer_Balance is a dbForm
76642>>>                Entry_Item Customer.Balance
76643>>>                Set Label to "Balance Due:"
76644>>>                Set Size to 13 48
76645>>>                Set Location to 39 72
76646>>>                Set Label_Col_Offset to 2
76647>>>                Set Label_Justification_Mode to jMode_Right
76648>>>            End_Object    // oCustomer_Balance
76649>>>
76649>>>        End_Object    // oBalances_TP
76650>>>
76650>>>        Object oComments_TP is a dbTabPage
76652>>>            Set Label to "Comments"
76653>>>            Set Tab_ToolTip_Value to "Notes about this customer"
76654>>>            Object oCustomer_Comments is a cDbTextEdit
76656>>>                Entry_Item Customer.Comments
76657>>>                Set Size to 71 242
76658>>>                Set Location to 9 9
76659>>>                Set peAnchors to anAll
76660>>>            End_Object    // oCustomer_Comments
76661>>>
76661>>>        End_Object    // oComments_TP
76662>>>
76662>>>    End_Object    // oCustTD
76663>>>
76663>>>CD_End_Object    // oCustomerView
76665>>>>
76665>        Use Invt.vw
Including file: Invt.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Invt.vw)
76665>>>Use dfClient.pkg
76665>>>Use DataDict.pkg
76665>>>Use dfEntry.pkg
76665>>>Use Vendor.DD
Including file: Vendor.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Vendor.dd)
76665>>>>>Use  Windows.pkg           // Basic Definitions
76665>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76665>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76665>>>>>
76665>>>>>Open Vendor
Including file: Vendor.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Vendor.fd)
76667>>>>>Open Invt
Including file: Invt.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Invt.fd)
76669>>>>>Open OrdSys
76671>>>>>
76671>>>>>
76671>>>>>Register_Object Vendor_State_VT
76671>>>>>
76671>>>>>Object Vendor_State_VT  is a CodeValidationTable
76673>>>>>    Set Type_Value        To "STATES"
76674>>>>>End_Object   // Vendor_State_VT
76675>>>>>Register_Object Vendor_sl
76675>>>>>
76675>>>>>Class Vendor_DataDictionary Is A DataDictionary
76676>>>>>
76676>>>>>    Procedure Construct_Object
76678>>>>>        Forward Send Construct_Object
76680>>>>>
76680>>>>>        Set Main_File To Vendor.File_Number
76681>>>>>        Set Cascade_Delete_State To False
76682>>>>>
76682>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76683>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76684>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76685>>>>>
76685>>>>>        Set Add_Client_File to Invt.File_Number
76686>>>>>
76686>>>>>        Set Add_System_File to Ordsys.File_Number DD_LOCK_ON_NEW_SAVE
76687>>>>>
76687>>>>>        Set Field_Auto_Increment Field Vendor.Id to File_Field Ordsys.Vendor_Number
76688>>>>>
76688>>>>>
76688>>>>>        Set Field_Label_Long Field Vendor.ID To "Vendor ID"
76689>>>>>        Set Field_Label_Short Field Vendor.ID To "Vndr ID"
76690>>>>>        Set Field_Option Field Vendor.ID DD_AUTOFIND to True
76691>>>>>        Set Field_Option Field Vendor.ID DD_NOPUT to True
76692>>>>>        Set Field_Prompt_Object Field Vendor.ID to Vendor_sl
76693>>>>>        Set Key_Field_State Field Vendor.ID To True
76694>>>>>        Set Status_Help Field Vendor.ID To "Vendor Id Number (system assigned)."
76695>>>>>
76695>>>>>        Set Field_Label_Long Field Vendor.Name To "Vendor Name"
76696>>>>>        Set Field_Label_Short Field Vendor.Name To "Name"
76697>>>>>        Set Field_Option Field Vendor.Name DD_REQUIRED to True
76698>>>>>        Set Field_Prompt_Object Field Vendor.Name to Vendor_sl
76699>>>>>        Set Status_Help Field Vendor.Name To "Vendor Name."
76700>>>>>
76700>>>>>        Set Field_Label_Long Field Vendor.Address To "Street Address"
76701>>>>>        Set Field_Label_Short Field Vendor.Address To "Address"
76702>>>>>        Set Status_Help Field Vendor.Address To "Street Address."
76703>>>>>
76703>>>>>        Set Status_Help Field Vendor.City To "City Name."
76704>>>>>
76704>>>>>        Set Field_Class_Name Field Vendor.State To "dbComboForm"
76705>>>>>        Set Field_Label_Long Field Vendor.State To "State"
76706>>>>>        Set Field_Label_Short Field Vendor.State To "St."
76707>>>>>        Set Field_Option Field Vendor.State DD_CAPSLOCK to True
76708>>>>>        Set Field_Value_Table Field Vendor.State to Vendor_State_VT
76709>>>>>        Set Status_Help Field Vendor.State To "Two letter state ID."
76710>>>>>
76710>>>>>        Set Field_Label_Long Field Vendor.Zip To "Zip/Postal Code"
76711>>>>>        Set Field_Label_Short Field Vendor.Zip To "Zip"
76712>>>>>        Set Field_Mask Field Vendor.Zip To "#####-####"
76713>>>>>        Set Field_Mask_Type Field Vendor.Zip To MASK_WINDOW
76714>>>>>        Set Status_Help Field Vendor.Zip To "Zip or Postal Code."
76715>>>>>
76715>>>>>        Set Field_Label_Long Field Vendor.Phone_Number To "Phone Number"
76716>>>>>        Set Field_Label_Short Field Vendor.Phone_Number To "Phone"
76717>>>>>        Set Status_Help Field Vendor.Phone_Number To "Phone Number."
76718>>>>>
76718>>>>>        Set Field_Label_Long Field Vendor.Fax_Number To "Fax Number"
76719>>>>>        Set Field_Label_Short Field Vendor.Fax_Number To "Fax"
76720>>>>>        Set Status_Help Field Vendor.Fax_Number To "Fax Phone Number."
76721>>>>>
76721>>>>>
76721>>>>>    End_Procedure  //  Construct_Object
76722>>>>>
76722>>>>>
76722>>>>>
76722>>>>>    Procedure Field_Defaults
76724>>>>>        Forward Send Field_Defaults
76726>>>>>    End_Procedure    // Field_Defaults
76727>>>>>    
76727>>>>>End_Class    //  Vendor_DataDictionary
76728>>>>>
76728>>>>>Use Vendor.sl        // Vendor_sl
Including file: Vendor.sl    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Vendor.sl)
76728>>>>>>>Use DFClient.pkg
76728>>>>>>>Use DFSelLst.pkg
76728>>>>>>>Use Windows.pkg
76728>>>>>>>Use cDbCJGridPromptList.pkg
76728>>>>>>>
76728>>>>>>>Use Vendor.DD
76728>>>>>>>
76728>>>>>>>CD_Popup_Object Vendor_sl is a dbModalPanel
76746>>>>>>>>
76746>>>>>>>    Set Label to "Vendor List"
76747>>>>>>>    Set Size to 132 238
76748>>>>>>>    Set Location to 4 5
76749>>>>>>>    Set piMinSize to 132 238
76750>>>>>>>
76750>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76752>>>>>>>    End_Object    // Vendor_DD
76753>>>>>>>
76753>>>>>>>    Set Main_DD to Vendor_DD
76754>>>>>>>    Set Server to Vendor_DD
76755>>>>>>>
76755>>>>>>>    Object oSelList is a cDbCJGridPromptList
76757>>>>>>>        Set Size to 95 229
76758>>>>>>>        Set Location to 12 4
76759>>>>>>>        Set pbAllowColumnRemove to False
76760>>>>>>>        Set peAnchors to anAll
76761>>>>>>>
76761>>>>>>>        Object oVendor_ID is a cDbCJGridColumn
76763>>>>>>>            Entry_Item Vendor.ID
76764>>>>>>>            Set piWidth to 63
76765>>>>>>>            Set psCaption to "ID"
76766>>>>>>>        End_Object
76767>>>>>>>
76767>>>>>>>        Object oVendor_Name is a cDbCJGridColumn
76769>>>>>>>            Entry_Item Vendor.Name
76770>>>>>>>            Set piWidth to 280
76771>>>>>>>            Set psCaption to "Vendor Name"
76772>>>>>>>        End_Object
76773>>>>>>>    End_Object
76774>>>>>>>
76774>>>>>>>    Object oOK_bn is a Button
76776>>>>>>>        Set Label to "&Ok"
76777>>>>>>>        Set Location to 114 77
76778>>>>>>>        Set peAnchors to anBottomRight
76779>>>>>>>
76779>>>>>>>        Procedure OnClick
76782>>>>>>>            Send OK of oSelList
76783>>>>>>>        End_Procedure
76784>>>>>>>
76784>>>>>>>    End_Object    // oOK_bn
76785>>>>>>>
76785>>>>>>>    Object oCancel_bn is a Button
76787>>>>>>>        Set Label to "&Cancel"
76788>>>>>>>        Set Location to 114 130
76789>>>>>>>        Set peAnchors to anBottomRight
76790>>>>>>>
76790>>>>>>>        Procedure OnClick
76793>>>>>>>            Send Cancel of oSelList
76794>>>>>>>        End_Procedure
76795>>>>>>>
76795>>>>>>>    End_Object    // oCancel_bn
76796>>>>>>>
76796>>>>>>>    Object oSearch_bn is a Button
76798>>>>>>>        Set Label to "&Search..."
76799>>>>>>>        Set Location to 114 183
76800>>>>>>>        Set peAnchors to anBottomRight
76801>>>>>>>
76801>>>>>>>        Procedure OnClick
76804>>>>>>>            Send Search of oSelList
76805>>>>>>>        End_Procedure
76806>>>>>>>
76806>>>>>>>    End_Object    // oSearch_bn
76807>>>>>>>
76807>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76808>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76809>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76810>>>>>>>
76810>>>>>>>CD_End_Object    // Vendor_sl
76812>>>>>>>>
76812>>>>>
76812>>>>>
76812>>>Use Invt.DD
Including file: Invt.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\Invt.dd)
76812>>>>>Use  Windows.pkg           // Basic Definitions
76812>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
76812>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
76812>>>>>
76812>>>>>Open Invt
76814>>>>>Open OrderDtl
Including file: OrderDtl.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\OrderDtl.fd)
76816>>>>>Open Vendor
76818>>>>>
76818>>>>>Register_Object Invt_sl
76818>>>>>
76818>>>>>Class Invt_DataDictionary Is A DataDictionary
76819>>>>>
76819>>>>>    Procedure Construct_Object
76821>>>>>        Forward Send Construct_Object
76823>>>>>
76823>>>>>        Set Main_File To Invt.File_Number
76824>>>>>        Set Cascade_Delete_State To False
76825>>>>>
76825>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
76826>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
76827>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
76828>>>>>
76828>>>>>        Set Add_Client_File to OrderDtl.File_Number
76829>>>>>
76829>>>>>        Set Add_Server_File to Vendor.File_Number
76830>>>>>
76830>>>>>
76830>>>>>        Set Field_Label_Long Field Invt.Item_ID To "Invt. Item ID"
76831>>>>>        Set Field_Label_Short Field Invt.Item_ID To "Item ID"
76832>>>>>        Set Field_Option Field Invt.Item_ID DD_AUTOFIND to True
76833>>>>>        Set Field_Option Field Invt.Item_ID DD_REQUIRED to True
76834>>>>>        Set Field_Option Field Invt.Item_ID DD_CAPSLOCK to True
76835>>>>>        Set Field_Prompt_Object Field Invt.Item_ID to Invt_sl
76836>>>>>        Set Key_Field_State Field Invt.Item_ID To True
76837>>>>>        Set Status_Help Field Invt.Item_ID To "Inventory Item Id - user defined identification"
76838>>>>>
76838>>>>>        Set Field_Label_Long Field Invt.Description To "Invt. Description"
76839>>>>>        Set Field_Label_Short Field Invt.Description To "Description"
76840>>>>>        Set Field_Option Field Invt.Description DD_REQUIRED to True
76841>>>>>        Set Status_Help Field Invt.Description To "Inventory Part Description"
76842>>>>>
76842>>>>>        Set Field_Option Field Invt.Vendor_ID DD_CAPSLOCK to True
76843>>>>>        Set Status_Help Field Invt.Vendor_ID To "Vendor Number"
76844>>>>>
76844>>>>>        Set Field_Option Field Invt.Vendor_Part_ID DD_REQUIRED to True
76845>>>>>        Set Status_Help Field Invt.Vendor_Part_ID To "Vendor ID name for this item"
76846>>>>>
76846>>>>>        Set Field_Mask_Type Field Invt.Unit_Price To MASK_CURRENCY_WINDOW
76847>>>>>        Set Field_Value_Range Field Invt.Unit_Price To 0 999999.99
76848>>>>>        Set Status_Help Field Invt.Unit_Price To "Retail unit price"
76849>>>>>
76849>>>>>        Set Field_Value_Range Field Invt.On_Hand To -999999 999999
76850>>>>>        Set Status_Help Field Invt.On_Hand To "Units currently available"
76851>>>>>
76851>>>>>    End_Procedure  //  Construct_Object
76852>>>>>  
76852>>>>>    Function Validate_Save Returns Integer
76854>>>>>        Integer iRetVal
76854>>>>>    
76854>>>>>        Forward Get Validate_Save to iRetVal
76856>>>>>        
76856>>>>>        If iRetVal Function_Return iRetVal
76859>>>>>    
76859>>>>>        If Invt.On_Hand Lt 0 Begin
76861>>>>>           Send UserError "Insufficient Inventory Stock" ""
76862>>>>>           Function_Return 1
76863>>>>>        End   
76863>>>>>>
76863>>>>>    End_Function  // Validate_Save
76864>>>>>
76864>>>>>
76864>>>>>    Procedure Field_Defaults
76866>>>>>        Forward Send Field_Defaults
76868>>>>>    End_Procedure    // Field_Defaults
76869>>>>>    
76869>>>>>End_Class    //  Invt_DataDictionary
76870>>>>>
76870>>>>>Use Invt.sl          // Invt_sl
Including file: Invt.sl    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Invt.sl)
76870>>>>>>>Use DFClient.pkg
76870>>>>>>>Use DFSelLst.pkg
76870>>>>>>>Use Windows.pkg
76870>>>>>>>
76870>>>>>>>Use Vendor.DD
76870>>>>>>>Use Invt.DD
76870>>>>>>>
76870>>>>>>>CD_Popup_Object Invt_sl is a dbModalPanel
76888>>>>>>>>
76888>>>>>>>
76888>>>>>>>    Set Minimize_Icon to False
76889>>>>>>>    Set Label to "Inventory List"
76890>>>>>>>    Set Size to 133 284
76891>>>>>>>    Set Location to 4 4
76892>>>>>>>    Set piMinSize to 133 284
76893>>>>>>>
76893>>>>>>>    Object Vendor_DD is a Vendor_DataDictionary
76895>>>>>>>    End_Object    // Vendor_DD
76896>>>>>>>
76896>>>>>>>    Object Invt_DD is a Invt_DataDictionary
76898>>>>>>>        Set DDO_Server to Vendor_DD
76899>>>>>>>    End_Object    // Invt_DD
76900>>>>>>>
76900>>>>>>>    Set Main_DD to Invt_DD
76901>>>>>>>    Set Server to Invt_DD
76902>>>>>>>
76902>>>>>>>    Object oSelList is a cDbCJGridPromptList
76904>>>>>>>        Set Size to 105 273
76905>>>>>>>        Set Location to 6 6
76906>>>>>>>        Set peAnchors to anAll
76907>>>>>>>        Set pbAllowColumnRemove to False
76908>>>>>>>
76908>>>>>>>        Object oItemID is a cDbCJGridColumn
76910>>>>>>>            Entry_Item Invt.Item_iD
76911>>>>>>>            Set psCaption to "Item ID"
76912>>>>>>>            Set piWidth to 74
76913>>>>>>>        End_Object
76914>>>>>>>        
76914>>>>>>>        Object oDescription is a cDbCJGridColumn
76916>>>>>>>            Entry_Item Invt.Description
76917>>>>>>>            Set psCaption to "Description"
76918>>>>>>>            Set piWidth to 205
76919>>>>>>>        End_Object
76920>>>>>>>        
76920>>>>>>>        Object oUnitPrice is a cDbCJGridColumn
76922>>>>>>>            Entry_Item Invt.Unit_Price
76923>>>>>>>            Set psCaption to "Unit Price"
76924>>>>>>>            Set piWidth to 69
76925>>>>>>>        End_Object
76926>>>>>>>        
76926>>>>>>>        Object oOnHand is a cDbCJGridColumn
76928>>>>>>>            Entry_Item Invt.On_Hand
76929>>>>>>>            Set psCaption to "On Hand"
76930>>>>>>>            Set piWidth to 61
76931>>>>>>>        End_Object
76932>>>>>>>
76932>>>>>>>    End_Object    // oSelList
76933>>>>>>>
76933>>>>>>>    Object oOK_bn is a Button
76935>>>>>>>        Set Label to "&Ok"
76936>>>>>>>        Set Location to 115 123
76937>>>>>>>        Set peAnchors to anBottomRight
76938>>>>>>>
76938>>>>>>>        Procedure OnClick
76941>>>>>>>            Send OK of oSelList
76942>>>>>>>        End_Procedure
76943>>>>>>>
76943>>>>>>>    End_Object    // oOK_bn
76944>>>>>>>
76944>>>>>>>    Object oCancel_bn is a Button
76946>>>>>>>        Set Label to "&Cancel"
76947>>>>>>>        Set Location to 115 176
76948>>>>>>>        Set peAnchors to anBottomRight
76949>>>>>>>
76949>>>>>>>        Procedure OnClick
76952>>>>>>>            Send Cancel of oSelList
76953>>>>>>>        End_Procedure
76954>>>>>>>
76954>>>>>>>    End_Object    // oCancel_bn
76955>>>>>>>
76955>>>>>>>    Object oSearch_bn is a Button
76957>>>>>>>        Set Label to "&Search..."
76958>>>>>>>        Set Location to 115 229
76959>>>>>>>        Set peAnchors to anBottomRight
76960>>>>>>>
76960>>>>>>>        Procedure OnClick
76963>>>>>>>            Send Search of oSelList
76964>>>>>>>        End_Procedure
76965>>>>>>>
76965>>>>>>>    End_Object    // oSearch_bn
76966>>>>>>>
76966>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
76967>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
76968>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
76969>>>>>>>
76969>>>>>>>CD_End_Object    // Invt_sl
76971>>>>>>>>
76971>>>>>
76971>>>>>
76971>>>
76971>>>DEFERRED_VIEW Activate_oInventoryView FOR ;;Object oInventoryView is a dbView
76996>>>    Set Border_Style to Border_Thick
76997>>>    Set Label to "Inventory Item View"
76998>>>    Set Location to 5 8
76999>>>    Set Size to 151 305
77000>>>    Set piMaxSize to 115 350
77001>>>    Set piMinSize to 151 270
77002>>>
77002>>>    Object Vendor_DD is a Vendor_DataDictionary
77004>>>    End_Object    // Vendor_DD
77005>>>
77005>>>    Object Invt_DD is a Invt_DataDictionary
77007>>>        Set DDO_Server to Vendor_DD
77008>>>    End_Object    // Invt_DD
77009>>>
77009>>>    Set Main_DD to Invt_DD
77010>>>    Set Server to Invt_DD
77011>>>
77011>>>    Object oDbCont is a dbContainer3d
77013>>>        Set Size to 140 295
77014>>>        Set Location to 5 4
77015>>>        Set peAnchors to anAll
77016>>>        Object oInvt_Item_ID is a dbForm
77018>>>            Entry_Item Invt.Item_ID
77019>>>            Set Label to "Invt. Item ID:"
77020>>>            Set Size to 13 60
77021>>>            Set Location to 10 70
77022>>>            Set peAnchors to anTopLeft
77023>>>            Set Label_Col_Offset to 2
77024>>>            Set Label_Justification_Mode to jMode_Right
77025>>>        End_Object    // oInvt_Item_Id
77026>>>
77026>>>        Object oInvt_Description is a dbForm
77028>>>            Entry_Item Invt.Description
77029>>>            Set Label to "Invt. Description:"
77030>>>            Set Size to 13 210
77031>>>            Set Location to 25 70
77032>>>            Set peAnchors to anTopLeftRight
77033>>>            Set Label_Col_Offset to 2
77034>>>            Set Label_Justification_Mode to jMode_Right
77035>>>        End_Object    // oInvt_Description
77036>>>
77036>>>        Object oVendorGroup is a dbGroup
77038>>>            Set Size to 58 271
77039>>>            Set Location to 41 9
77040>>>            Set peAnchors to anAll
77041>>>            Set Label to "Vendor"
77042>>>            Object oInvt_Vendor_ID is a dbForm
77044>>>                Entry_Item Vendor.ID
77045>>>                Set Label to "Vendor ID:"
77046>>>                Set Size to 13 42
77047>>>                Set Location to 9 61
77048>>>                Set peAnchors to anTopLeft
77049>>>                Set Label_Col_Offset to 2
77050>>>                Set Label_Justification_Mode to jMode_Right
77051>>>            End_Object    // oInvt_Vendor_Id
77052>>>
77052>>>            Object oVendor_Name is a dbForm
77054>>>                Entry_Item Vendor.Name
77055>>>                Set Label to "Vendor Name:"
77056>>>                Set Size to 13 180
77057>>>                Set Location to 24 61
77058>>>                Set peAnchors to anTopLeftRight
77059>>>                Set Label_Col_Offset to 2
77060>>>                Set Label_Justification_Mode to jMode_Right
77061>>>            End_Object    // oVendor_Name
77062>>>
77062>>>            Object oInvt_Vendor_Part_ID is a dbForm
77064>>>                Entry_Item Invt.Vendor_Part_ID
77065>>>                Set Label to "Vendor Part ID:"
77066>>>                Set Size to 13 90
77067>>>                Set Location to 39 61
77068>>>                Set peAnchors to anTopLeft
77069>>>                Set Label_Col_Offset to 2
77070>>>                Set Label_Justification_Mode to jMode_Right
77071>>>            End_Object    // oInvt_Vendor_Part_ID
77072>>>
77072>>>        End_Object    // oVendorGroup
77073>>>
77073>>>        Object oUnitGroup is a dbGroup
77075>>>            Set Size to 28 271
77076>>>            Set Location to 101 9
77077>>>            Set peAnchors to anAll
77078>>>            Object oInvt_Unit_Price is a dbForm
77080>>>                Entry_Item Invt.Unit_Price
77081>>>                Set Label to "Unit Price:"
77082>>>                Set Size to 13 48
77083>>>                Set Location to 10 61
77084>>>                Set peAnchors to anTopLeft
77085>>>                Set Label_Col_Offset to 2
77086>>>                Set Label_Justification_Mode to jMode_Right
77087>>>            End_Object    // oInvt_Unit_Price
77088>>>
77088>>>            Object oInvt_On_Hand is a dbForm
77090>>>                Entry_Item Invt.On_Hand
77091>>>                Set Label to "On Hand:"
77092>>>                Set Size to 13 36
77093>>>                Set Location to 10 205
77094>>>                Set peAnchors to anTopRight
77095>>>                Set Label_Col_Offset to 2
77096>>>                Set Label_Justification_Mode to jMode_Right
77097>>>            End_Object    // oInvt_On_Hand
77098>>>
77098>>>        End_Object    // oUnitGroup
77099>>>
77099>>>    End_Object    // oDbCont
77100>>>
77100>>>CD_End_Object    // oInventoryView
77102>>>>
77102>        Use Order.vw
Including file: Order.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Order.vw)
77102>>>Use dfClient.pkg
77102>>>Use DataDict.pkg
77102>>>Use dfEntry.pkg
77102>>>Use dfSpnEnt.pkg
77102>>>Use dfCEntry.pkg
77102>>>Use dfTable.pkg
77102>>>Use Windows.pkg
77102>>>Use Vendor.DD
77102>>>Use Invt.DD
77102>>>Use Customer.DD
77102>>>Use SalesP.DD
Including file: SalesP.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\SalesP.dd)
77102>>>>>Use  Windows.pkg           // Basic Definitions
77102>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77102>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77102>>>>>
77102>>>>>Open Salesp
Including file: SalesP.fd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\SalesP.fd)
77104>>>>>Open Orderhea
77106>>>>>
77106>>>>>Register_Object SalesP_sl
77106>>>>>
77106>>>>>Class SalesP_DataDictionary Is A DataDictionary
77107>>>>>
77107>>>>>    Procedure Construct_Object
77109>>>>>        Forward Send Construct_Object
77111>>>>>
77111>>>>>        Set Main_File To Salesp.File_Number
77112>>>>>        Set Cascade_Delete_State To FALSE
77113>>>>>
77113>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
77114>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77115>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77116>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77117>>>>>
77117>>>>>        Set Add_Client_File to Orderhea.File_Number
77118>>>>>
77118>>>>>
77118>>>>>        Set Field_Label_Long Field Salesp.Id To "Sales Person ID"
77119>>>>>        Set Field_Label_Short Field Salesp.Id To "ID"
77120>>>>>        Set Field_Option Field Salesp.Id DD_AUTOFIND to True
77121>>>>>        Set Field_Option Field Salesp.Id DD_REQUIRED to True
77122>>>>>        Set Field_Option Field Salesp.Id DD_CAPSLOCK to True
77123>>>>>        Set Field_Prompt_Object Field Salesp.Id to SalesP_sl
77124>>>>>        Set Key_Field_State Field Salesp.Id To TRUE
77125>>>>>        Set Status_Help Field Salesp.Id To "Sales person ID code - Upper case alpha"
77126>>>>>
77126>>>>>        Set Field_Label_Long Field Salesp.Name To "Sales Person Name"
77127>>>>>        Set Field_Label_Short Field Salesp.Name To "Sales Person Name"
77128>>>>>        Set Field_Prompt_Object Field Salesp.Name to SalesP_sl
77129>>>>>        Set Status_Help Field Salesp.Name To "Sales person name - first and last"
77130>>>>>
77130>>>>>    End_Procedure  //  Construct_Object
77131>>>>>
77131>>>>>
77131>>>>>    Procedure Field_Defaults
77133>>>>>        Forward Send Field_Defaults
77135>>>>>    End_Procedure    // Field_Defaults
77136>>>>>    
77136>>>>>End_Class    //  Salesp_DataDictionary
77137>>>>>
77137>>>>>Use SalesP.sl        // SalesP_sl
Including file: Salesp.sl    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Salesp.sl)
77137>>>>>>>Use DFClient.pkg
77137>>>>>>>Use DFSelLst.pkg
77137>>>>>>>Use Windows.pkg
77137>>>>>>>Use cDbCJGridPromptList.pkg
77137>>>>>>>
77137>>>>>>>Use SalesP.DD
77137>>>>>>>
77137>>>>>>>CD_Popup_Object SalesP_sl is a dbModalPanel
77155>>>>>>>>
77155>>>>>>>
77155>>>>>>>    Set Minimize_Icon to False
77156>>>>>>>    Set Label to "Sales Person List"
77157>>>>>>>    Set Size to 99 260
77158>>>>>>>    Set Location to 4 5
77159>>>>>>>    Set piMinSize to 99 180
77160>>>>>>>
77160>>>>>>>    Object SalesP_DD is a SalesP_DataDictionary
77162>>>>>>>    End_Object    // Salesp_DD
77163>>>>>>>
77163>>>>>>>    Set Main_DD to SalesP_DD
77164>>>>>>>    Set Server to SalesP_DD
77165>>>>>>>
77165>>>>>>>    Object oSelList is a cDbCJGridPromptList
77167>>>>>>>        Set Size to 70 249
77168>>>>>>>        Set Location to 6 5
77169>>>>>>>        Set pbAllowColumnRemove to False
77170>>>>>>>        Set peAnchors to anAll
77171>>>>>>>
77171>>>>>>>        Object oSalesP_ID is a cDbCJGridColumn
77173>>>>>>>            Entry_Item SalesP.ID
77174>>>>>>>            Set piWidth to 60
77175>>>>>>>            Set psCaption to "ID"
77176>>>>>>>        End_Object
77177>>>>>>>
77177>>>>>>>        Object oSalesP_Name is a cDbCJGridColumn
77179>>>>>>>            Entry_Item SalesP.Name
77180>>>>>>>            Set piWidth to 313
77181>>>>>>>            Set psCaption to "Sales Person Name"
77182>>>>>>>        End_Object
77183>>>>>>>    End_Object
77184>>>>>>>
77184>>>>>>>    Object oOK_bn is a Button
77186>>>>>>>        Set Label to "&Ok"
77187>>>>>>>        Set Location to 81 99
77188>>>>>>>        Set peAnchors to anBottomRight
77189>>>>>>>        Set Default_State to True
77190>>>>>>>
77190>>>>>>>        Procedure OnClick
77193>>>>>>>            Send OK of oSelList
77194>>>>>>>        End_Procedure
77195>>>>>>>
77195>>>>>>>    End_Object    // oOK_bn
77196>>>>>>>
77196>>>>>>>    Object oCancel_bn is a Button
77198>>>>>>>        Set Label to "&Cancel"
77199>>>>>>>        Set Location to 81 152
77200>>>>>>>        Set peAnchors to anBottomRight
77201>>>>>>>
77201>>>>>>>        Procedure OnClick
77204>>>>>>>            Send Cancel of oSelList
77205>>>>>>>        End_Procedure
77206>>>>>>>
77206>>>>>>>    End_Object    // oCancel_bn
77207>>>>>>>
77207>>>>>>>    Object oSearch_bn is a Button
77209>>>>>>>        Set Label to "&Search..."
77210>>>>>>>        Set Location to 81 205
77211>>>>>>>        Set peAnchors to anBottomRight
77212>>>>>>>
77212>>>>>>>        Procedure OnClick
77215>>>>>>>            Send Search of oSelList
77216>>>>>>>        End_Procedure
77217>>>>>>>
77217>>>>>>>    End_Object    // oSearch_bn
77218>>>>>>>
77218>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77219>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77220>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77221>>>>>>>
77221>>>>>>>CD_End_Object    // SalesP_sl
77223>>>>>>>>
77223>>>>>
77223>>>>>
77223>>>Use OrderHea.DD
Including file: OrderHea.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\OrderHea.dd)
77223>>>>>Use  Windows.pkg           // Basic Definitions
77223>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77223>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77223>>>>>
77223>>>>>Open OrderHea
77225>>>>>Open OrderDtl
77227>>>>>Open Customer
77229>>>>>Open SalesP
77231>>>>>Open OrdSys
77233>>>>>
77233>>>>>
77233>>>>>Register_Object Terms_table
77233>>>>>Register_Object Ship_Table
77233>>>>>
77233>>>>>Object Terms_table  is a DescriptionValidationTable
77235>>>>>
77235>>>>>    Procedure Fill_List
77238>>>>>        Forward Send Fill_List
77240>>>>>        Send Add_Table_Value  "NONE"  "None established"
77241>>>>>        Send Add_Table_Value  "COD"  "COD"
77242>>>>>        Send Add_Table_Value  "NET30"  "Net 30"
77243>>>>>        Send Add_Table_Value  "NET60"  "Net 60"
77244>>>>>        Send Add_Table_Value  "NET90"  "Net 90"
77245>>>>>        Send Add_Table_Value  "PREPAY"  "Pre-payment required"
77246>>>>>    End_Procedure    // Fill_List
77247>>>>>End_Object   // Terms_table
77248>>>>>
77248>>>>>Object Ship_Table  is a CodeValidationTable
77250>>>>>    Set Type_Value        To "SHIPPING"
77251>>>>>    Set Allow_Blank_State To True
77252>>>>>End_Object   // Ship_Table
77253>>>>>
77253>>>>>Register_Object OrderHea_sl
77253>>>>>
77253>>>>>Class OrderHea_DataDictionary Is A DataDictionary
77254>>>>>
77254>>>>>    Procedure Construct_Object
77256>>>>>        Forward Send Construct_Object
77258>>>>>
77258>>>>>        Set Main_File To OrderHea.File_Number
77259>>>>>
77259>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77260>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77261>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77262>>>>>
77262>>>>>        Set Add_Client_File to OrderDtl.File_Number
77263>>>>>
77263>>>>>        Set Add_Server_File to Customer.File_Number
77264>>>>>        Set Add_Server_File to SalesP.File_Number
77265>>>>>
77265>>>>>        Set ParentNullAllowed SalesP.File_Number to True
77266>>>>>        Set ParentNoSwitchIfCommitted Customer.File_Number to True
77267>>>>>
77267>>>>>        Set Add_System_File to OrdSys.File_Number DD_LOCK_ON_NEW_SAVE_DELETE
77268>>>>>
77268>>>>>        Set Field_Auto_Increment Field OrderHea.Order_Number to File_Field OrdSys.Order_Number
77269>>>>>
77269>>>>>
77269>>>>>        Set Field_Option Field OrderHea.Order_Number DD_AUTOFIND to True
77270>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Number to OrderHea_SL
77271>>>>>        Set Key_Field_State Field OrderHea.Order_Number To True
77272>>>>>        Set Status_Help Field OrderHea.Order_Number To "Order Number - New orders are assigned numbers automatically"
77273>>>>>
77273>>>>>
77273>>>>>        Set Field_Class_Name Field OrderHea.Order_Date To "dbSpinForm"
77274>>>>>        Set Field_Entry_msg Field OrderHea.Order_Date To Entry_Order_Date
77275>>>>>        Set Field_Mask_Type Field OrderHea.Order_Date To MASK_DATE_WINDOW
77276>>>>>        Set Field_Prompt_Object Field OrderHea.Order_Date to OrderHea_SL
77277>>>>>        Set Status_Help Field OrderHea.Order_Date To "Date on which the order was placed"
77278>>>>>        Set Field_Option Field OrderHea.Order_Date DD_COMMIT to True
77279>>>>>
77279>>>>>        Set Field_Class_Name Field OrderHea.Terms To "dbComboForm"
77280>>>>>        Set Field_Value_Table Field OrderHea.Terms to Terms_table
77281>>>>>        Set Status_Help Field OrderHea.Terms To "Payment terms"
77282>>>>>
77282>>>>>        Set Field_Class_Name Field OrderHea.Ship_Via To "dbComboForm"
77283>>>>>        Set Field_Value_Table Field OrderHea.Ship_Via to Ship_Table
77284>>>>>        Set Status_Help Field OrderHea.Ship_Via To "Shipping method"
77285>>>>>
77285>>>>>        Set Status_Help Field OrderHea.Ordered_By To "Order placed by"
77286>>>>>        Set Field_Option Field OrderHea.Ordered_By DD_COMMIT to True
77287>>>>>
77287>>>>>        Set Field_Label_Long Field OrderHea.Salesperson_ID To "Sales Person ID"
77288>>>>>        Set Field_Label_Short Field OrderHea.Salesperson_ID To "Sales ID"
77289>>>>>        Set Status_Help Field OrderHea.Salesperson_ID To "Sales Person who initiated the order"
77290>>>>>
77290>>>>>        Set Field_Mask_Type Field OrderHea.Order_Total To MASK_CURRENCY_WINDOW
77291>>>>>        Set Field_Option Field OrderHea.Order_Total DD_DISPLAYONLY to True
77292>>>>>
77292>>>>>
77292>>>>>    End_Procedure  // Construct_Object
77293>>>>>
77293>>>>>    Procedure Field_Defaults
77295>>>>>        Forward Send Field_Defaults
77297>>>>>    End_Procedure
77298>>>>>
77298>>>>>    // Add a default date if the field is blank
77298>>>>>    Procedure Entry_Order_Date Integer iField Date dDate
77300>>>>>         Integer iChanged
77300>>>>>         
77300>>>>>         Get Field_Changed_State iField To iChanged
77301>>>>>         If (iChanged=0 And dDate=0) Begin
77303>>>>>            SysDate dDate
77304>>>>>            Set Field_Default_Value iField To dDate
77305>>>>>         End
77305>>>>>>
77305>>>>>    End_Procedure
77306>>>>>
77306>>>>>    Procedure Update
77308>>>>>        Forward Send Update
77310>>>>>        Send Adjust_Balances OrderHea.Order_Total
77311>>>>>    End_Procedure
77312>>>>>
77312>>>>>    Procedure Backout
77314>>>>>        Forward Send Backout
77316>>>>>        Send Adjust_Balances (-OrderHea.Order_Total)
77317>>>>>    End_Procedure
77318>>>>>
77318>>>>>    Procedure Adjust_Balances Number Amt
77320>>>>>        Add Amt To Customer.Purchases
77321>>>>>        Add Amt To Customer.Balance
77322>>>>>    End_Procedure
77323>>>>>
77323>>>>>    Procedure Deleting
77325>>>>>        Forward Send Deleting
77327>>>>>        // see if we can decrement the order number in sys file...can only do
77327>>>>>        // this if this is the newest order.
77327>>>>>        If (OrderHea.Order_Number=OrdSys.Order_Number) Begin // if this is
77329>>>>>           Decrement OrdSys.Order_Number          // the last number,
77330>>>>>           Saverecord OrdSys                      // decrement and save.
77331>>>>>        End
77331>>>>>>
77331>>>>>    End_Procedure
77332>>>>>
77332>>>>>End_Class    //  OrderHea_DataDictionary
77333>>>>>
77333>>>>>Use OrderHea.sl      // OrderHea_sl
Including file: Orderhea.sl    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Orderhea.sl)
77333>>>>>>>Use DFClient.pkg
77333>>>>>>>Use DFSelLst.pkg
77333>>>>>>>Use Windows.pkg
77333>>>>>>>Use cDbCJGridPromptList.pkg
77333>>>>>>>
77333>>>>>>>Use Customer.DD
77333>>>>>>>Use OrderHea.DD
77333>>>>>>>
77333>>>>>>>
77333>>>>>>>CD_Popup_Object OrderHea_sl is a dbModalPanel
77351>>>>>>>>
77351>>>>>>>
77351>>>>>>>    Set Minimize_Icon to False
77352>>>>>>>    Set Label to "Order List"
77353>>>>>>>    Set Size to 134 392
77354>>>>>>>    Set Location to 4 5
77355>>>>>>>    Set piMinSize to 134 392
77356>>>>>>>
77356>>>>>>>    Object Customer_DD is a Customer_DataDictionary
77358>>>>>>>    End_Object    // Customer_DD
77359>>>>>>>
77359>>>>>>>    Object OrderHea_DD is a OrderHea_DataDictionary
77361>>>>>>>        Set DDO_Server to Customer_DD
77362>>>>>>>    End_Object    // OrderHea_DD
77363>>>>>>>
77363>>>>>>>    Set Main_DD to OrderHea_DD
77364>>>>>>>    Set Server to OrderHea_DD
77365>>>>>>>
77365>>>>>>>    Object oSelList is a cDbCJGridPromptList
77367>>>>>>>        Set Size to 100 377
77368>>>>>>>        Set Location to 9 7
77369>>>>>>>        Set pbAllowColumnRemove to False
77370>>>>>>>        Set peAnchors to anAll
77371>>>>>>>
77371>>>>>>>        Object oOrderHea_Order_Number is a cDbCJGridColumn
77373>>>>>>>            Entry_Item OrderHea.Order_Number
77374>>>>>>>            Set piWidth to 87
77375>>>>>>>            Set psCaption to "Order Number"
77376>>>>>>>        End_Object
77377>>>>>>>
77377>>>>>>>        Object oCustomer_Customer_Number is a cDbCJGridColumn
77379>>>>>>>            Entry_Item Customer.Customer_Number
77380>>>>>>>            Set piWidth to 84
77381>>>>>>>            Set psCaption to "Cust. Number"
77382>>>>>>>        End_Object
77383>>>>>>>
77383>>>>>>>        Object oCustomer_Name is a cDbCJGridColumn
77385>>>>>>>            Entry_Item Customer.Name
77386>>>>>>>            Set piWidth to 231
77387>>>>>>>            Set psCaption to "Customer Name"
77388>>>>>>>        End_Object
77389>>>>>>>
77389>>>>>>>        Object oOrderHea_Order_Date is a cDbCJGridColumn
77391>>>>>>>            Entry_Item OrderHea.Order_Date
77392>>>>>>>            Set piWidth to 75
77393>>>>>>>            Set psCaption to "Order Date"
77394>>>>>>>            Set peTextAlignment to xtpAlignmentRight
77395>>>>>>>        End_Object
77396>>>>>>>
77396>>>>>>>        Object oOrderHea_Order_Total is a cDbCJGridColumn
77398>>>>>>>            Entry_Item OrderHea.Order_Total
77399>>>>>>>            Set piWidth to 88
77400>>>>>>>            Set psCaption to "Order Total"
77401>>>>>>>        End_Object
77402>>>>>>>    End_Object
77403>>>>>>>
77403>>>>>>>    Object oOK_bn is a Button
77405>>>>>>>        Set Label to "&Ok"
77406>>>>>>>        Set Location to 116 231
77407>>>>>>>        Set peAnchors to anBottomRight
77408>>>>>>>
77408>>>>>>>        Procedure OnClick
77411>>>>>>>            Send OK of oSelList
77412>>>>>>>        End_Procedure
77413>>>>>>>
77413>>>>>>>    End_Object    // oOK_bn
77414>>>>>>>
77414>>>>>>>    Object oCancel_bn is a Button
77416>>>>>>>        Set Label to "&Cancel"
77417>>>>>>>        Set Location to 116 284
77418>>>>>>>        Set peAnchors to anBottomRight
77419>>>>>>>
77419>>>>>>>        Procedure OnClick
77422>>>>>>>            Send Cancel of oSelList
77423>>>>>>>        End_Procedure
77424>>>>>>>
77424>>>>>>>    End_Object    // oCancel_bn
77425>>>>>>>
77425>>>>>>>    Object oSearch_bn is a Button
77427>>>>>>>        Set Label to "&Search..."
77428>>>>>>>        Set Location to 116 337
77429>>>>>>>        Set peAnchors to anBottomRight
77430>>>>>>>
77430>>>>>>>        Procedure OnClick
77433>>>>>>>            Send Search of oSelList
77434>>>>>>>        End_Procedure
77435>>>>>>>
77435>>>>>>>    End_Object    // oSearch_bn
77436>>>>>>>
77436>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
77437>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
77438>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
77439>>>>>>>
77439>>>>>>>CD_End_Object    // OrderHea_sl
77441>>>>>>>>
77441>>>>>
77441>>>>>
77441>>>Use OrderDtl.DD
Including file: OrderDtl.dd    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\DDSrc\OrderDtl.dd)
77441>>>>>Use  Windows.pkg           // Basic Definitions
77441>>>>>Use  DataDict.pkg          // DataDictionary Class Definition
77441>>>>>Use  DDvalTbl.pkg          // Validation Table Class Definitions
77441>>>>>
77441>>>>>Open OrderDtl
77443>>>>>Open OrderHea
77445>>>>>Open Invt
77447>>>>>
77447>>>>>
77447>>>>>Class OrderDtl_DataDictionary Is A DataDictionary
77448>>>>>
77448>>>>>    Procedure Construct_Object
77450>>>>>        Forward Send Construct_Object
77452>>>>>
77452>>>>>        Set Main_File To OrderDtl.File_Number
77453>>>>>        Set Cascade_Delete_State To False
77454>>>>>
77454>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
77455>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
77456>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
77457>>>>>
77457>>>>>        Set Add_Server_File to OrderHea.File_Number
77458>>>>>        Set Add_Server_File to Invt.File_Number
77459>>>>>
77459>>>>>        Set Field_Auto_Increment Field OrderDtl.Detail_Number to File_Field OrderHea.Last_Detail_Num
77460>>>>>
77460>>>>>
77460>>>>>        Set Field_Option Field OrderDtl.Order_Number DD_NOPUT to True
77461>>>>>
77461>>>>>        Set Field_Option Field OrderDtl.Detail_Number DD_NOPUT to True
77462>>>>>
77462>>>>>
77462>>>>>        Set Field_Exit_msg Field OrderDtl.Qty_Ordered To Adjust_Display_Total
77463>>>>>        Set Field_Label_Long Field OrderDtl.Qty_Ordered To "Quantity Ordered"
77464>>>>>        Set Field_Label_Short Field OrderDtl.Qty_Ordered To "Quantity"
77465>>>>>        Set Field_Mask_Type Field OrderDtl.Qty_Ordered To MASK_NUMERIC_WINDOW
77466>>>>>        Set Status_Help Field OrderDtl.Qty_Ordered To "Number of items ordered"
77467>>>>>
77467>>>>>        Set Field_Entry_msg Field OrderDtl.Price To Entering_Price
77468>>>>>        Set Field_Exit_msg Field OrderDtl.Price To Adjust_Display_Total
77469>>>>>        Set Field_Label_Long Field OrderDtl.Price To "Price per Unit"
77470>>>>>        Set Field_Label_Short Field OrderDtl.Price To "Price"
77471>>>>>        Set Field_Mask_Type Field OrderDtl.Price To MASK_CURRENCY_WINDOW
77472>>>>>        Set Status_Help Field OrderDtl.Price To "Price per Unit"
77473>>>>>
77473>>>>>        Set Field_Label_Long Field OrderDtl.Extended_Price To "Extended Price"
77474>>>>>        Set Field_Label_Short Field OrderDtl.Extended_Price To "Total"
77475>>>>>        Set Field_Mask_Type Field OrderDtl.Extended_Price To MASK_CURRENCY_WINDOW
77476>>>>>        Set Field_Option Field OrderDtl.Extended_Price DD_DISPLAYONLY to True
77477>>>>>        Set Status_Help Field OrderDtl.Extended_Price To "Total extended price"
77478>>>>>
77478>>>>>    End_Procedure  //  Construct_Object
77479>>>>>
77479>>>>>    // Update and Backout need to adjust the Invt.On_Hand quantity,
77479>>>>>    // the dtl line's extended price and the OrderHea total. We will call
77479>>>>>    // the same procedure (Adjust_Balances) to insure that backout and
77479>>>>>    // update are inverses of each other.
77479>>>>>    // Note that Backout does not need to change the extended_price. This
77479>>>>>    // only gets changed as part of update.
77479>>>>>    Procedure Update_Order
77481>>>>>        Forward Send Update
77483>>>>>        Move (OrderDtl.Price * OrderDtl.Qty_Ordered) To OrderDtl.Extended_Price
77484>>>>>        Send Adjust_Balances OrderDtl.Qty_Ordered OrderDtl.Extended_Price
77485>>>>>    End_Procedure //Update_Order
77486>>>>>    
77486>>>>>    Procedure Backout_Order
77488>>>>>        Forward Send Backout
77490>>>>>        Send Adjust_Balances (-OrderDtl.Qty_Ordered) (-OrderDtl.Extended_Price)
77491>>>>>    End_Procedure //Backout_Order
77492>>>>>
77492>>>>>    // Called by Backout and Update passing the quantity
77492>>>>>    // and the extended price. 
77492>>>>>    // Subtract quantity from Invt on-hand and
77492>>>>>    // add extended amnt to order total.
77492>>>>>    Procedure Adjust_Balances Number Qty Number Amt
77494>>>>>        Subtract Qty From Invt.On_Hand
77495>>>>>        Add      Amt To   OrderHea.Order_Total
77496>>>>>    End_Procedure
77497>>>>>
77497>>>>>    // when entering the price field we may wish to update the
77497>>>>>    // current field value with the standard unit price from the
77497>>>>>    // Invt file. Only do this if the current amount is zero and an item was actually picked. If non-
77497>>>>>    // zero or no item picked, we assume the field is being edited (and we make no assumptions). 
77497>>>>>    Procedure Entering_Price Integer Field# Number nAmnt
77499>>>>>        Handle hoInvtDD
77499>>>>>        Boolean bHasRecord
77499>>>>>
77499>>>>>        Get Data_Set Invt.File_Number to hoInvtDD
77500>>>>>
77500>>>>>        If (hoInvtDD) Begin
77502>>>>>            Get HasRecord of hoInvtDD to bHasRecord
77503>>>>>        
77503>>>>>            If (nAmnt=0 and bHasRecord) Begin
77505>>>>>               Get File_Field_Current_Value File_Field Invt.Unit_Price to nAmnt
77506>>>>>               Set Field_Changed_Value Field# to nAmnt
77507>>>>>               Send Adjust_Display_Total
77508>>>>>            End
77508>>>>>>
77508>>>>>        End
77508>>>>>>
77508>>>>>        
77508>>>>>    End_Procedure
77509>>>>>
77509>>>>>    // This updates the extended price field, which will update any 
77509>>>>>    // display balances. This is only done for display purposes. The actual
77509>>>>>    // amount is updated to the field during the save.
77509>>>>>    Procedure Adjust_Display_total Integer iField String sValue
77511>>>>>        Integer iQty
77511>>>>>        Number  nAmnt
77511>>>>>        
77511>>>>>        Get Field_Current_Value Field OrderDtl.Qty_Ordered    To iQty
77512>>>>>        Get Field_Current_Value Field OrderDtl.Price          To nAmnt
77513>>>>>        Set Field_Current_Value Field OrderDtl.Extended_Price To (nAmnt * iQty)
77514>>>>>        // note we set value, but not changed state!
77514>>>>>    End_Procedure
77515>>>>>
77515>>>>>
77515>>>>>    Procedure Field_Defaults
77517>>>>>        Forward Send Field_Defaults
77519>>>>>    End_Procedure    // Field_Defaults
77520>>>>>    
77520>>>>>End_Class    //  OrderDtl_DataDictionary
77521>>>>>
77521>>>Use cDbCJGrid.pkg
77521>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCJGridColumnRowIndicator.pkg)
77521>>>>>Use cCJGridColumn.pkg
77521>>>>>
77521>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
77522>>>>>    
77522>>>>>    Procedure Construct_Object
77524>>>>>        Forward Send Construct_Object
77526>>>>>    
77526>>>>>        Property Integer piImage 0
77527>>>>>        
77527>>>>>        Set psCaption to ""
77528>>>>>        Set piWidth to 20
77529>>>>>        Set pbResizable to False
77530>>>>>        Set pbEditable to False
77531>>>>>        Set pbFocusable to False
77532>>>>>        Set pbAllowDrag to False
77533>>>>>        Set psToolTip to "Row Indicator"
77534>>>>>//        Set Color to (RGB(217,222,243))   //JVH
77534>>>>>    End_Procedure
77535>>>>>    
77535>>>>>    Procedure OnCreateColumn
77537>>>>>        Integer iImage
77537>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
77539>>>>>        Set piImage to iImage
77540>>>>>    End_Procedure
77541>>>>>            
77541>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
77543>>>>>        Integer iImage iFocusedRow
77543>>>>>        Handle hoDataSource
77543>>>>>        
77543>>>>>        Get phoDataSource to hoDataSource
77544>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
77545>>>>>        Move -1 to iImage
77546>>>>>        If (iRow = iFocusedRow) Begin
77548>>>>>            Get piImage to iImage
77549>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
77550>>>>>        End
77550>>>>>>
77550>>>>>    End_Procedure
77551>>>>>
77551>>>>>End_Class
77552>>>
77552>>>Use MonthCalendarPrompt.dg
Including file: MonthCalendarPrompt.dg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\MonthCalendarPrompt.dg)
77552>>>>>// Month Calendar Prompt dialog
77552>>>>>
77552>>>>>
77552>>>>>Use cMonthCalendarPrompt.pkg
Including file: cMonthCalendarPrompt.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendarPrompt.pkg)
77552>>>>>>>Use cMonthCalendar.pkg
Including file: cMonthCalendar.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cMonthCalendar.pkg)
77552>>>>>>>>>Use Windows.pkg
77552>>>>>>>>>Use Commctrl.pkg
77552>>>>>>>>>Use tWinStructs.pkg
77552>>>>>>>>>Use cWinControlEx.pkg
Including file: cWinControlEx.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinControlEx.pkg)
77552>>>>>>>>>>>Use cWinControl.pkg
77552>>>>>>>>>>>// This adds proper navigation and default button support for
77552>>>>>>>>>>>// external classes
77552>>>>>>>>>>>
77552>>>>>>>>>>>Class cWinControlEx is a cWinControl
77553>>>>>>>>>>>    Import_Class_Protocol Standard_Form_Mixin
77554>>>>>>>>>>>    Procedure Construct_Object
77556>>>>>>>>>>>        Forward Send Construct_Object
77558>>>>>>>>>>>        Send define_standard_Form_Mixin
77559>>>>>>>>>>>    End_Procedure
77560>>>>>>>>>>>    
77560>>>>>>>>>>>    Function item_count Integer iItem Returns Integer
77562>>>>>>>>>>>        Function_Return 1
77563>>>>>>>>>>>    End_Function
77564>>>>>>>>>>>    
77564>>>>>>>>>>>    Procedure External_SetFocus
77566>>>>>>>>>>>        Send notify_focus_change 1
77567>>>>>>>>>>>    End_Procedure
77568>>>>>>>>>>>
77568>>>>>>>>>>>    Procedure External_KillFocus
77570>>>>>>>>>>>        Send notify_focus_change 0
77571>>>>>>>>>>>    End_Procedure
77572>>>>>>>>>>>
77572>>>>>>>>>>>    Procedure End_Construct_Object
77574>>>>>>>>>>>        Forward Send End_Construct_Object
77576>>>>>>>>>>>        Set External_Message WM_SETFOCUS  to External_SetFocus
77577>>>>>>>>>>>        Set External_Message WM_KILLFOCUS to External_KillFocus
77578>>>>>>>>>>>    End_Procedure
77579>>>>>>>>>>>        
77579>>>>>>>>>>>End_Class
77580>>>>>>>>>>>
77580>>>>>>>>>
77580>>>>>>>>>Class cMonthCalendar is a cWinControlEx
77581>>>>>>>>>    Procedure Construct_Object
77583>>>>>>>>>        Integer iResult
77583>>>>>>>>>        tWinInitCommonControlsEX InitCC
77583>>>>>>>>>        tWinInitCommonControlsEX InitCC
77583>>>>>>>>>
77583>>>>>>>>>        Forward Send Construct_Object
77585>>>>>>>>>
77585>>>>>>>>>        Move (SizeOfType (tWinInitCommonControlsEX)) to InitCC.dwSize
77586>>>>>>>>>        Move ICC_DATE_CLASSES to InitCC.dwICC
77587>>>>>>>>>        Move (InitCommonControlsEx(AddressOf(InitCC))) to iResult
77588>>>>>>>>>        
77588>>>>>>>>>        Set External_Class_Name 'cMonthCalendar' to 'SysMonthCal32'
77589>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnLButtonDblClick
77590>>>>>>>>>        
77590>>>>>>>>>        Set Border_Style to Border_Normal
77591>>>>>>>>>        
77591>>>>>>>>>        Property Boolean pbNoToday False
77592>>>>>>>>>        Property Boolean pbNoTodayCircle False
77593>>>>>>>>>        Property Boolean pbMultiSelect False
77594>>>>>>>>>        Property Boolean pbWeekNumbers False
77595>>>>>>>>>        Property Integer piMaxSelectedCount 90
77596>>>>>>>>>        
77596>>>>>>>>>        // this is minimum Dialog units required for a single picker rectangle
77596>>>>>>>>>        Property Integer piMinWidth 0
77597>>>>>>>>>        Property Integer piMinHeight 0
77598>>>>>>>>>
77598>>>>>>>>>        // stores initial date before control is activated
77598>>>>>>>>>        Property Date pdPrivateDate 
77599>>>>>>>>>        // if multi-select, this is the end range
77599>>>>>>>>>        Property Date pdPrivateDate2 
77600>>>>>>>>>        
77600>>>>>>>>>    End_Procedure
77601>>>>>>>>>    
77601>>>>>>>>>    // returns control's value when single select
77601>>>>>>>>>    Function SelectedDate Returns Date
77603>>>>>>>>>        tWinSystemTime CurrentSystemTime
77603>>>>>>>>>        tWinSystemTime CurrentSystemTime
77603>>>>>>>>>        Integer iRetval
77603>>>>>>>>>        DateTime dtSel
77603>>>>>>>>>        Handle hWnd
77603>>>>>>>>>        Get Window_Handle to hWnd
77604>>>>>>>>>        If (hWnd) Begin
77606>>>>>>>>>            Move (Windows_Message (MCM_GETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval
77607>>>>>>>>>            Move (DateSetDay(dtSel,CurrentSystemTime.wDay)) to dtSel
77608>>>>>>>>>            Move (DateSetMonth(dtSel,CurrentSystemTime.wMonth)) to dtSel
77609>>>>>>>>>            Move (DateSetYear(dtSel,CurrentSystemTime.wYear)) to dtSel
77610>>>>>>>>>        End
77610>>>>>>>>>>
77610>>>>>>>>>        Else Begin
77611>>>>>>>>>            Get pdPrivateDate to dtSel
77612>>>>>>>>>        End
77612>>>>>>>>>>
77612>>>>>>>>>        Function_Return (Date(dtSel))
77613>>>>>>>>>    End_Function
77614>>>>>>>>>
77614>>>>>>>>>    // returns control's values when multi select
77614>>>>>>>>>    Function SelectedDateRange Returns Date[]
77616>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77616>>>>>>>>>        tWinSystemTime[2] CurrentSystemTime
77617>>>>>>>>>        Integer iRetval
77617>>>>>>>>>        DateTime dtSel1 dtsel2
77617>>>>>>>>>        Date[] dtSel
77618>>>>>>>>>        Handle hWnd
77618>>>>>>>>>        Get Window_Handle to hWnd
77619>>>>>>>>>        If (hWnd) Begin
77621>>>>>>>>>            Move (Windows_Message (MCM_GETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval
77622>>>>>>>>>            
77622>>>>>>>>>            Move (DateSetDay(dtSel1,CurrentSystemTime[0].wDay)) to dtSel1
77623>>>>>>>>>            Move (DateSetMonth(dtSel1,CurrentSystemTime[0].wMonth)) to dtSel1
77624>>>>>>>>>            Move (DateSetYear(dtSel1,CurrentSystemTime[0].wYear)) to dtSel1
77625>>>>>>>>>            
77625>>>>>>>>>            Move (DateSetDay(dtSel2,CurrentSystemTime[1].wDay)) to dtSel2
77626>>>>>>>>>            Move (DateSetMonth(dtSel2,CurrentSystemTime[1].wMonth)) to dtSel2
77627>>>>>>>>>            Move (DateSetYear(dtSel2,CurrentSystemTime[1].wYear)) to dtSel2
77628>>>>>>>>>            
77628>>>>>>>>>            Move dtSel1 to dtSel[0]
77629>>>>>>>>>            Move dtsel2 to dtSel[1]
77630>>>>>>>>>        End
77630>>>>>>>>>>
77630>>>>>>>>>        Else Begin
77631>>>>>>>>>            Get pdPrivateDate to dtSel[0]
77632>>>>>>>>>            Get pdPrivateDate2 to dtSel[1]
77633>>>>>>>>>        End
77633>>>>>>>>>>
77633>>>>>>>>>        Function_Return dtSel
77634>>>>>>>>>    End_Function
77635>>>>>>>>>
77635>>>>>>>>>    // Set control's value when single select
77635>>>>>>>>>    Procedure SetSelectedDate Date dDate
77637>>>>>>>>>        tWinSystemTime CurrentSystemTime
77637>>>>>>>>>        tWinSystemTime CurrentSystemTime
77637>>>>>>>>>        Integer iRetval
77637>>>>>>>>>        Handle hWnd
77637>>>>>>>>>        
77637>>>>>>>>>        Get Window_Handle to hWnd
77638>>>>>>>>>        Set pdPrivateDate to dDate
77639>>>>>>>>>        If (hWnd) Begin
77641>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime.wDay
77642>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime.wMonth
77643>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime.wYear
77644>>>>>>>>>    
77644>>>>>>>>>           Move (Windows_Message (MCM_SETCURSEL, 0, AddressOf (CurrentSystemTime))) to iRetval        
77645>>>>>>>>>        End
77645>>>>>>>>>>
77645>>>>>>>>>    End_Procedure
77646>>>>>>>>>
77646>>>>>>>>>    // Set control's values when multi select
77646>>>>>>>>>    Procedure SetSelectedDateRange Date dDate Date dDate2
77648>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77648>>>>>>>>>        tWinSystemTime[] CurrentSystemTime
77649>>>>>>>>>        Integer iRetval
77649>>>>>>>>>        Handle hWnd
77649>>>>>>>>>
77649>>>>>>>>>        Get Window_Handle to hWnd
77650>>>>>>>>>        Set pdPrivateDate to dDate
77651>>>>>>>>>        Set pdPrivateDate2 to dDate2
77652>>>>>>>>>        If (hWnd) Begin
77654>>>>>>>>>            Move (DateGetDay(dDate)) to CurrentSystemTime[0].wDay
77655>>>>>>>>>            Move (DateGetMonth(dDate)) to CurrentSystemTime[0].wMonth
77656>>>>>>>>>            Move (DateGetYear(dDate)) to CurrentSystemTime[0].wYear
77657>>>>>>>>>
77657>>>>>>>>>            Move (DateGetDay(dDate2)) to CurrentSystemTime[1].wDay
77658>>>>>>>>>            Move (DateGetMonth(dDate2)) to CurrentSystemTime[1].wMonth
77659>>>>>>>>>            Move (DateGetYear(dDate2)) to CurrentSystemTime[1].wYear
77660>>>>>>>>>    
77660>>>>>>>>>            Move (Windows_Message (MCM_SETSELRANGE, 0, AddressOf (CurrentSystemTime))) to iRetval        
77661>>>>>>>>>        End
77661>>>>>>>>>>
77661>>>>>>>>>    End_Procedure
77662>>>>>>>>>    
77662>>>>>>>>>    // augment to set dates from control, so they can be accessed after the control is closed
77662>>>>>>>>>    Procedure Remove_Object
77664>>>>>>>>>        Date[] SelDate 
77665>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77667>>>>>>>>>            Get SelectedDateRange to SelDate
77668>>>>>>>>>            Set pdPrivateDate2 to SelDate[1]
77669>>>>>>>>>        End
77669>>>>>>>>>>
77669>>>>>>>>>        Else Begin
77670>>>>>>>>>            Get SelectedDate to SelDate[0]
77671>>>>>>>>>        End
77671>>>>>>>>>>
77671>>>>>>>>>        Set pdPrivateDate to SelDate[0]
77672>>>>>>>>>        Forward Send Remove_Object
77674>>>>>>>>>    End_Procedure
77675>>>>>>>>>
77675>>>>>>>>>    Procedure Page Integer iState
77677>>>>>>>>>        Integer iRetval iSize iHeight iWidth
77677>>>>>>>>>        tWinRect WindowRect
77677>>>>>>>>>        tWinRect WindowRect
77677>>>>>>>>>        Date dDate dDate2
77677>>>>>>>>>        Handle hWnd
77677>>>>>>>>>        Integer  iMaxSelectedCount
77677>>>>>>>>>        Boolean bNoToday bWeekNumbers bMultiSelect bNoTodayCircle
77677>>>>>>>>>        
77677>>>>>>>>>        If (iState<>1) Begin
77679>>>>>>>>>            Forward Send Page iState
77681>>>>>>>>>            Procedure_Return
77682>>>>>>>>>        End
77682>>>>>>>>>>
77682>>>>>>>>>        
77682>>>>>>>>>        Set Icon to 'ActionCalendar.ico'
77683>>>>>>>>>
77683>>>>>>>>>        Get pbNoToday to bNoToday
77684>>>>>>>>>        Get pbNoTodayCircle to bNoTodayCircle
77685>>>>>>>>>        Get pbMultiSelect to bMultiSelect
77686>>>>>>>>>        Get pbWeekNumbers to bWeekNumbers
77687>>>>>>>>>        Get piMaxSelectedCount to iMaxSelectedCount
77688>>>>>>>>>
77688>>>>>>>>>        Set Window_Style MCS_MULTISELECT to bMultiSelect
77689>>>>>>>>>        Set Window_Style MCS_NOTODAY to bNoToday
77690>>>>>>>>>        Set Window_Style MCS_NOTODAYCIRCLE to bNoTodayCircle
77691>>>>>>>>>        Set Window_Style MCS_WEEKNUMBERS to bWeekNumbers
77692>>>>>>>>>        Forward Send Page iState
77694>>>>>>>>>
77694>>>>>>>>>        Get Window_Handle to hWnd
77695>>>>>>>>>        // support double click
77695>>>>>>>>>        Move (SetClassLong(hWnd,GCL_STYLE,CS_DBLCLKS ior CS_GLOBALCLASS)) to iRetval
77696>>>>>>>>>        // set range when multi select
77696>>>>>>>>>        Move (Windows_Message(MCM_SETMAXSELCOUNT,iMaxSelectedCount,0)) to iRetval
77697>>>>>>>>>        
77697>>>>>>>>>        // store minimum size for calendar control and set the size to this by default
77697>>>>>>>>>        Move (Windows_Message (MCM_GETMINREQRECT, 0, AddressOf(WindowRect))) to iRetval
77698>>>>>>>>>        Get GuiToDialog WindowRect.bottom WindowRect.right to iSize
77699>>>>>>>>>        Move (Hi(iSize)) to iHeight
77700>>>>>>>>>        Move (Low(iSize)) to iWidth
77701>>>>>>>>>        Set piMinWidth to iWidth
77702>>>>>>>>>        Set piMinHeight to iHeight
77703>>>>>>>>>        Set Size to iHeight iWidth
77704>>>>>>>>>        
77704>>>>>>>>>        // now that we are activated set starting date or date range
77704>>>>>>>>>        Get pdPrivateDate to dDate
77705>>>>>>>>>        If (pbMultiSelect(Self)) Begin
77707>>>>>>>>>            Get pdPrivateDate2 to dDate2
77708>>>>>>>>>            Send SetSelectedDateRange dDate dDate2
77709>>>>>>>>>        End
77709>>>>>>>>>>
77709>>>>>>>>>        Else Begin
77710>>>>>>>>>            Send SetSelectedDate dDate
77711>>>>>>>>>        End
77711>>>>>>>>>>
77711>>>>>>>>>    End_Procedure
77712>>>>>>>>>
77712>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
77714>>>>>>>>>        Integer iRetval
77714>>>>>>>>>        DateTime dtSel dtSel2
77714>>>>>>>>>        tWintagNMSelChange CalenderInfo
77714>>>>>>>>>        tWintagNMSelChange CalenderInfo
77714>>>>>>>>>        Boolean bMulti
77714>>>>>>>>>        
77714>>>>>>>>>        Move (MemCopy (AddressOf (CalenderInfo), lParam, SizeOfType (tWintagNMSelChange))) to iRetval
77715>>>>>>>>>        If (CalenderInfo.nmHdr.code = MCN_SELCHANGE) Begin
77717>>>>>>>>>            Get pbMultiSelect to bMulti
77718>>>>>>>>>            Move (DateSetDay(dtSel,CalenderInfo.stSelStart.wDay)) to dtSel
77719>>>>>>>>>            Move (DateSetMonth(dtSel,CalenderInfo.stSelStart.wMonth)) to dtSel
77720>>>>>>>>>            Move (DateSetYear(dtSel,CalenderInfo.stSelStart.wYear)) to dtSel
77721>>>>>>>>>            If bMulti Begin
77723>>>>>>>>>                Move (DateSetDay(dtSel,CalenderInfo.stSelEnd.wDay)) to dtSel2
77724>>>>>>>>>                Move (DateSetMonth(dtSel,CalenderInfo.stSelEnd.wMonth)) to dtSel2
77725>>>>>>>>>                Move (DateSetYear(dtSel,CalenderInfo.stSelEnd.wYear)) to dtSel2
77726>>>>>>>>>            End
77726>>>>>>>>>>
77726>>>>>>>>>            Send OnChange (Date(dtSel)) (Date(dtSel2))
77727>>>>>>>>>        End
77727>>>>>>>>>>
77727>>>>>>>>>    End_Procedure
77728>>>>>>>>>
77728>>>>>>>>>    // sent whenever there is a selection change within the calendar
77728>>>>>>>>>    Procedure OnChangeDate Date dDate Date dDate2
77730>>>>>>>>>    End_Procedure
77731>>>>>>>>>
77731>>>>>>>>>    // sent when a click occurs in the calendar 
77731>>>>>>>>>    Procedure OnClick
77733>>>>>>>>>    End_Procedure
77734>>>>>>>>>    
77734>>>>>>>>>    // sent when a double click occurs in the calendar 
77734>>>>>>>>>    Procedure OnDoubleClick
77736>>>>>>>>>    End_Procedure
77737>>>>>>>>>    
77737>>>>>>>>>    // sends OnClick if the double click is on a calendar day
77737>>>>>>>>>    Procedure OnLButtonDblClick Integer wParam Integer lParam
77739>>>>>>>>>        Boolean bDayHit
77739>>>>>>>>>        Get MonthDayHit to bDayHit
77740>>>>>>>>>        If bDayHit Begin
77742>>>>>>>>>            Send OnDoubleClick
77743>>>>>>>>>        End
77743>>>>>>>>>>
77743>>>>>>>>>    End_Procedure
77744>>>>>>>>>
77744>>>>>>>>>    // sends OnClick if the click is on a calendar day
77744>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
77746>>>>>>>>>        Boolean bDayHit
77746>>>>>>>>>        Get MonthDayHit to bDayHit
77747>>>>>>>>>        If bDayHit Begin
77749>>>>>>>>>            Send OnClick
77750>>>>>>>>>        End
77750>>>>>>>>>>
77750>>>>>>>>>    End_Procedure
77751>>>>>>>>>    
77751>>>>>>>>>    // returns true if the month calander is up and the mouse is over a day
77751>>>>>>>>>    Function MonthDayHit Returns Boolean
77753>>>>>>>>>        Integer iRet
77753>>>>>>>>>        Get Windows_Message MCM_GETCURRENTVIEW 0 0 to iRet
77754>>>>>>>>>        If (iRet=MCMV_MONTH) Begin
77756>>>>>>>>>            Get HitTest to iRet
77757>>>>>>>>>            Function_Return (iRet=MCHT_CALENDARDATE)
77758>>>>>>>>>        End
77758>>>>>>>>>>
77758>>>>>>>>>        Function_Return False
77759>>>>>>>>>    End_Function
77760>>>>>>>>>    
77760>>>>>>>>>    // return what was hit in the control
77760>>>>>>>>>    Function HitTest Returns Integer
77762>>>>>>>>>        tWinMCHitTestInfo HitInfo
77762>>>>>>>>>        tWinMCHitTestInfo HitInfo
77762>>>>>>>>>        Handle hWnd iRet
77762>>>>>>>>>        Integer iVoid
77762>>>>>>>>>        Pointer lpPt
77762>>>>>>>>>        tWinPoint Pt
77762>>>>>>>>>        tWinPoint Pt
77762>>>>>>>>>        Get Window_Handle to hWnd
77763>>>>>>>>>        Move (AddressOf(Pt)) to lpPt
77764>>>>>>>>>        Move (GetCursorPos(lpPt)) to iVoid
77765>>>>>>>>>        Move (ScreenToClient(hWnd, lpPt)) to iVoid
77766>>>>>>>>>        Move Pt to HitInfo.Pt
77767>>>>>>>>>        Move (SizeOfType(tWinMCHitTestInfo)) to HitInfo.cbSize
77768>>>>>>>>>        Get WindowsMessage MCM_HITTEST 0 (AddressOf(HitInfo)) to iRet
77769>>>>>>>>>        Function_Return HitInfo.uHit
77770>>>>>>>>>    End_Function
77771>>>>>>>>>    
77771>>>>>>>>>End_Class
77772>>>>>>>
77772>>>>>>>// peMouseSelectOk choices
77772>>>>>>>Enum_List
77772>>>>>>>    Define msoClick
77772>>>>>>>    Define msoDblClick
77772>>>>>>>    Define msoNone
77772>>>>>>>End_Enum_List
77772>>>>>>>
77772>>>>>>>// It is expected that this class will only be used inside of ModalPanel and
77772>>>>>>>// will be used as a prompt object component in a framework style application.
77772>>>>>>>// If you wish to Use a month calendar in some other non prompt situation, 
77772>>>>>>>// use cMonthCalendar
77772>>>>>>>
77772>>>>>>>Class cMonthCalendarPrompt is a cMonthCalendar
77773>>>>>>>
77773>>>>>>>    Procedure Construct_Object
77775>>>>>>>
77775>>>>>>>        Forward Send Construct_Object
77777>>>>>>>
77777>>>>>>>        Property Integer peUpdateMode umPromptValue
77778>>>>>>>
77778>>>>>>>        Property Integer peMouseSelectOk msoClick
77779>>>>>>>        
77779>>>>>>>        Property Date pdSeedValue
77780>>>>>>>
77780>>>>>>>        // if multi-select, this is the end range
77780>>>>>>>        Property Date pdSeedValue2
77781>>>>>>>
77781>>>>>>>        Property Handle phmPromptUpdateCallback 0
77782>>>>>>>
77782>>>>>>>        Property Integer phoInvokingObject
77783>>>>>>>        
77783>>>>>>>        Property Integer peStoredUpdateMode
77784>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
77785>>>>>>>        Property Boolean pbStoredWeekNumbers
77786>>>>>>>        Property Boolean pbStoredNoToday
77787>>>>>>>        Property Boolean pbStoredNoTodayCircle
77788>>>>>>>        Property Boolean pbStoredMultiSelect
77789>>>>>>>        Property Integer piStoredMaxSelectedCount
77790>>>>>>>        Property Integer peStoredpeMouseSelectOk
77791>>>>>>>
77791>>>>>>>        // internally set by list
77791>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
77791>>>>>>>        Property Boolean pbCanceled
77792>>>>>>>
77792>>>>>>>    End_Procedure
77793>>>>>>>        
77793>>>>>>>    Procedure OnStoreDefaults
77795>>>>>>>        Integer iVal
77795>>>>>>>        Boolean bVal
77795>>>>>>>
77795>>>>>>>        Get peUpdateMode to iVal
77796>>>>>>>        Set peStoredUpdateMode to iVal
77797>>>>>>>        
77797>>>>>>>        Get phmPromptUpdateCallback to iVal       
77798>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
77799>>>>>>>
77799>>>>>>>        Get pbMultiSelect to bVal       
77800>>>>>>>        Set pbStoredMultiSelect to bVal       
77801>>>>>>>
77801>>>>>>>        Get pbNoToday to bVal       
77802>>>>>>>        Set pbStoredNoToday to bVal       
77803>>>>>>>
77803>>>>>>>        Get pbNoTodayCircle to bVal       
77804>>>>>>>        Set pbStoredNoTodayCircle to bVal       
77805>>>>>>>
77805>>>>>>>        Get pbWeekNumbers to bVal       
77806>>>>>>>        Set pbStoredWeekNumbers to bVal       
77807>>>>>>>
77807>>>>>>>        Get piMaxSelectedCount to iVal       
77808>>>>>>>        Set piStoredMaxSelectedCount to iVal  
77809>>>>>>>        
77809>>>>>>>        Get peMouseSelectOk to iVal       
77810>>>>>>>        Set peStoredpeMouseSelectOk to iVal       
77811>>>>>>>        
77811>>>>>>>    End_Procedure
77812>>>>>>>
77812>>>>>>>    Procedure OnRestoreDefaults
77814>>>>>>>        Integer iVal
77814>>>>>>>        Boolean bVal
77814>>>>>>>
77814>>>>>>>        Get peStoredUpdateMode to iVal
77815>>>>>>>        Set peUpdateMode to iVal
77816>>>>>>>        
77816>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
77817>>>>>>>        Set phmPromptUpdateCallback to iVal       
77818>>>>>>>
77818>>>>>>>        Get pbStoredMultiSelect to bVal       
77819>>>>>>>        Set pbMultiSelect to bVal       
77820>>>>>>>
77820>>>>>>>        Get pbStoredNoToday to bVal       
77821>>>>>>>        Set pbNoToday to bVal       
77822>>>>>>>
77822>>>>>>>        Get pbStoredNoTodayCircle to bVal       
77823>>>>>>>        Set pbNoTodayCircle to bVal       
77824>>>>>>>
77824>>>>>>>        Get pbStoredWeekNumbers to bVal       
77825>>>>>>>        Set pbWeekNumbers to bVal       
77826>>>>>>>
77826>>>>>>>        Get piStoredMaxSelectedCount to iVal       
77827>>>>>>>        Set piMaxSelectedCount to iVal       
77828>>>>>>>
77828>>>>>>>        Get peStoredpeMouseSelectOk to iVal       
77829>>>>>>>        Set peMouseSelectOk to iVal       
77830>>>>>>>
77830>>>>>>>    End_Procedure
77831>>>>>>>
77831>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
77833>>>>>>>        Integer eMode
77833>>>>>>>        Set pbCanceled to True // assume cancel unless changed
77834>>>>>>>        Get peUpdateMode to eMode
77835>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
77837>>>>>>>            Send OnStoreDefaults
77838>>>>>>>        End
77838>>>>>>>>
77838>>>>>>>        Send InitializePrompt
77839>>>>>>>        Forward Send Add_Focus hoParent
77841>>>>>>>    End_Procedure
77842>>>>>>>        
77842>>>>>>>    // augment to send OnRestoreDefaults.
77842>>>>>>>    Procedure Release_Focus
77844>>>>>>>        Integer eUpdateMode
77844>>>>>>>        Get peUpdateMode to eUpdateMode
77845>>>>>>>        Forward Send Release_Focus
77847>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77849>>>>>>>            Send OnRestoreDefaults
77850>>>>>>>        End
77850>>>>>>>>
77850>>>>>>>    End_Procedure
77851>>>>>>>
77851>>>>>>>    // This is only called in a successful close
77851>>>>>>>    Procedure ClosePrompt
77853>>>>>>>        Handle hoInvokingObject
77853>>>>>>>        Handle hmCallBack
77853>>>>>>>        Integer eUpdateMode
77853>>>>>>>        Date[] dDates
77854>>>>>>>        
77854>>>>>>>        Set pbCanceled to False
77855>>>>>>>        
77855>>>>>>>        Get peUpdateMode to eUpdateMode
77856>>>>>>>        // if non-invoking there is by definition, no move value out
77856>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77858>>>>>>>            
77858>>>>>>>            If (eUpdateMode=umPromptValue) Begin
77860>>>>>>>                Send OnMoveValueOutByValue
77861>>>>>>>            End
77861>>>>>>>>
77861>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
77864>>>>>>>                Send OnMoveValueOutByCustom
77865>>>>>>>            End
77865>>>>>>>>
77865>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
77866>>>>>>>            If hmCallBack Begin
77868>>>>>>>                Get phoInvokingObject to hoInvokingObject
77869>>>>>>>                If (pbMultiSelect(Self)) Begin
77871>>>>>>>                    Get SelectedDateRange to dDates
77872>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0] dDates[1]
77873>>>>>>>                    
77873>>>>>>>                End
77873>>>>>>>>
77873>>>>>>>                Else Begin
77874>>>>>>>                    Get SelectedDate to dDates[0]
77875>>>>>>>                    Send hmCallBack of hoInvokingObject Self dDates[0]
77876>>>>>>>                End
77876>>>>>>>>
77876>>>>>>>            End
77876>>>>>>>>
77876>>>>>>>        End
77876>>>>>>>>
77876>>>>>>>
77876>>>>>>>        Send Close_Panel
77877>>>>>>>    End_Procedure
77878>>>>>>>
77878>>>>>>>    Procedure OnMoveValueOutByValue
77880>>>>>>>        Handle hoInvokingObject
77880>>>>>>>        Date dSelDate
77880>>>>>>>        Boolean bMulti
77880>>>>>>>        // we can only do an automatic move value out with
77880>>>>>>>        // single select. If multi-select you will probably want to
77880>>>>>>>        // use a callback method (hmCallBack) to update the values. 
77880>>>>>>>        Get pbMultiSelect to bMulti
77881>>>>>>>        If (not(bMulti)) Begin
77883>>>>>>>            Get SelectedDate to dSelDate
77884>>>>>>>            Get phoInvokingObject to hoInvokingObject
77885>>>>>>>            Set Value of hoInvokingObject to dSelDate
77886>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
77887>>>>>>>        End
77887>>>>>>>>
77887>>>>>>>    End_Procedure
77888>>>>>>>
77888>>>>>>>    Procedure OnMoveValueOutByCustom
77890>>>>>>>    End_Procedure
77891>>>>>>>        
77891>>>>>>>    // called before the list is activated. 
77891>>>>>>>    Procedure InitializePrompt
77893>>>>>>>        Handle hoInvokingObject
77893>>>>>>>        Integer eUpdateMode
77893>>>>>>>        Boolean bMulti 
77893>>>>>>>        Date dValue
77893>>>>>>>
77893>>>>>>>        Get peUpdateMode to eUpdateMode
77894>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
77896>>>>>>>
77896>>>>>>>            Get Focus of Desktop to hoInvokingObject
77897>>>>>>>            If (hoInvokingObject<=Desktop) Begin
77899>>>>>>>                Error DFERR_PROGRAM "Calendar Prompt has no invoking object"
77900>>>>>>>>
77900>>>>>>>                Procedure_Return
77901>>>>>>>            End
77901>>>>>>>>
77901>>>>>>>
77901>>>>>>>            Set phoInvokingObject to hoInvokingObject
77902>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
77903>>>>>>>            Get peUpdateMode to eUpdateMode
77904>>>>>>>        End
77904>>>>>>>>
77904>>>>>>>
77904>>>>>>>        Get pdSeedValue to dValue
77905>>>>>>>        Get pbMultiSelect to bMulti
77906>>>>>>>        If (not(bMulti) and eUpdateMode=umPromptValue and dValue=0) Begin
77908>>>>>>>            Get Value of hoInvokingObject to dValue
77909>>>>>>>            Set pdSeedValue to dValue
77910>>>>>>>        End
77910>>>>>>>>
77910>>>>>>>        Send OnSeedData
77911>>>>>>>        Set pdSeedValue to 0
77912>>>>>>>        Set pdSeedValue2 to 0
77913>>>>>>>    End_Procedure
77914>>>>>>>    
77914>>>>>>>    Procedure OnSeedData 
77916>>>>>>>        Boolean bMulti
77916>>>>>>>        Date dValue dValue2
77916>>>>>>>        Integer iMax iRange
77916>>>>>>>        DateTime dt1 dt2
77916>>>>>>>        Get pbMultiSelect to bMulti
77917>>>>>>>        Get pdSeedValue to dValue
77918>>>>>>>        If (not(bMulti)) Begin
77920>>>>>>>            // if no date, use current date
77920>>>>>>>            If (dValue=0) Begin
77922>>>>>>>                Move (CurrentDateTime()) to dValue
77923>>>>>>>            End
77923>>>>>>>>
77923>>>>>>>            Send SetSelectedDate dValue    
77924>>>>>>>        End
77924>>>>>>>>
77924>>>>>>>        Else Begin
77925>>>>>>>            Get pdSeedValue2 to dValue2 
77926>>>>>>>            // if no dates, use current date
77926>>>>>>>            If (dValue=0 and dValue2=0) Begin
77928>>>>>>>                Move (CurrentDateTime()) to dValue
77929>>>>>>>            End
77929>>>>>>>>
77929>>>>>>>            // if only one date, make that the range
77929>>>>>>>            If (dValue=0) Begin
77931>>>>>>>                Move dValue2 to dValue
77932>>>>>>>            End
77932>>>>>>>>
77932>>>>>>>            Else If (dValue2=0) Begin
77935>>>>>>>                Move dValue to dValue2
77936>>>>>>>            End
77936>>>>>>>>
77936>>>>>>>            
77936>>>>>>>            // test for valid range
77936>>>>>>>            Get piMaxSelectedCount to iMax
77937>>>>>>>            Move dValue to dt1
77938>>>>>>>            Move dValue2 to dt2
77939>>>>>>>            Move (SpanTotalDays(dt1 - dt2)) to iRange
77940>>>>>>>            If (iRange>iMax) Begin
77942>>>>>>>                Error DFERR_OPERATOR (SFormat(C_$DateRangeExceeded,iMax))
77943>>>>>>>>
77943>>>>>>>                Move dValue to dValue2
77944>>>>>>>            End
77944>>>>>>>>
77944>>>>>>>            
77944>>>>>>>            Send SetSelectedDateRange dValue dValue2
77945>>>>>>>        End
77945>>>>>>>>
77945>>>>>>>    End_Procedure
77946>>>>>>>
77946>>>>>>>    Procedure OnDoubleClick
77948>>>>>>>        Integer eSelectOn
77948>>>>>>>        Get peMouseSelectOk to eSelectOn
77949>>>>>>>        If (eSelectOn=msoDblClick) Begin
77951>>>>>>>            Send Ok
77952>>>>>>>        End
77952>>>>>>>>
77952>>>>>>>    End_Procedure
77953>>>>>>>    
77953>>>>>>>    Procedure OnClick
77955>>>>>>>        Integer eSelectOn
77955>>>>>>>        Get peMouseSelectOk to eSelectOn
77956>>>>>>>        If (eSelectOn=msoClick) Begin
77958>>>>>>>            Send Ok
77959>>>>>>>        End
77959>>>>>>>>
77959>>>>>>>    End_Procedure
77960>>>>>>>
77960>>>>>>>    Procedure Ok Returns Integer
77962>>>>>>>        Send ClosePrompt
77963>>>>>>>    End_Procedure
77964>>>>>>>
77964>>>>>>>    Procedure Cancel Returns Integer
77966>>>>>>>        Send Close_Panel
77967>>>>>>>    End_Procedure
77968>>>>>>>        
77968>>>>>>>End_Class
77969>>>>>>>
77969>>>>>>>
77969>>>>>Use Dfclient.pkg
77969>>>>>
77969>>>>>Cd_Popup_Object oMonthCalendarPrompt is a ModalPanel
77987>>>>>>
77987>>>>>    Set Location to 10 10
77988>>>>>    Set Size to 145 145
77989>>>>>    // resizable
77989>>>>>    Set Border_Style to Border_Thick
77990>>>>>
77990>>>>>    Set Label to C_$DateSelector
77991>>>>>
77991>>>>>    Set piMinSize to 0 0 // set this dynamically // 145 145
77992>>>>>    Set piMaxSize to 310 460
77993>>>>>
77993>>>>>    // tells us if this been activated and sized yet
77993>>>>>    Property Boolean pbSizeInited False
77995>>>>>        
77995>>>>>    Object oCalendar is a cMonthCalendarPrompt
77997>>>>>        Set Size to 120 135 // not real size, will be assigned
77998>>>>>        Set Location to 5 5
77999>>>>>        Set Border_Style to Border_None
78000>>>>>    End_Object
78001>>>>>
78001>>>>>    Object oOKButton is a Button
78003>>>>>        Set Label to C_$OK
78004>>>>>        Set Default_State to True
78005>>>>>        Set Location to 129 34
78006>>>>>        Set peAnchors to anBottomRight
78007>>>>>        
78007>>>>>        Procedure OnClick
78010>>>>>            Send Ok of oCalendar
78011>>>>>        End_Procedure
78012>>>>>    End_Object
78013>>>>>
78013>>>>>    Object oCancelButton is a Button
78015>>>>>        Set Label to C_$Cancel
78016>>>>>        Set Location to 129 89
78017>>>>>        Set peAnchors to anBottomRight
78018>>>>>        
78018>>>>>        Procedure OnClick
78021>>>>>            Send Cancel of oCalendar
78022>>>>>        End_Procedure
78023>>>>>    End_Object
78024>>>>>
78024>>>>>    Procedure OnResize 
78027>>>>>        Integer iSize iHeight iWidth iMinSize
78027>>>>>        Boolean bInited
78027>>>>>
78027>>>>>        Get piMinHeight of oCalendar to iHeight
78028>>>>>        // when 0, the control has not yet been created. Nothing to do.
78028>>>>>        If (iHeight=0) Begin
78030>>>>>            Procedure_Return
78031>>>>>        End
78031>>>>>>
78031>>>>>
78031>>>>>        Get pbSizeInited to bInited
78032>>>>>        
78032>>>>>        Get piMinWidth of oCalendar to iWidth
78033>>>>>        Get piMinSize to iMinSize
78034>>>>>        // Minumum size of panel - add 1 to each to each for wiggle room
78034>>>>>        Move (iHeight+25+1) to iHeight
78035>>>>>        Move (iWidth+10+1) to iWidth
78036>>>>>         
78036>>>>>        Set piMinSize to iHeight iWidth
78037>>>>>
78037>>>>>        If (not(bInited))  Begin
78039>>>>>            Set Size to iHeight iWidth
78040>>>>>            Set pbSizeInited to True
78041>>>>>        End
78041>>>>>>
78041>>>>>        Else Begin
78042>>>>>            Send Adjust_Logicals
78043>>>>>            Get Size to iSize
78044>>>>>            If (Hi(iSize)<iHeight or Low(iSize)<iWidth) Begin
78046>>>>>                Set Size to (iHeight max Hi(iSize)) (iWidth max Low(iSize))
78047>>>>>                Get Size to iSize
78048>>>>>            End
78048>>>>>>
78048>>>>>            Set Size of oCalendar to (Hi(iSize) - 25) (Low(iSize) - 10)
78049>>>>>        End
78049>>>>>>
78049>>>>>        
78049>>>>>    End_Procedure
78050>>>>>    
78050>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
78053>>>>>        Forward Send Add_Focus hoParent
78055>>>>>        Send OnResize
78056>>>>>    End_Procedure
78057>>>>>
78057>>>>>    On_Key kCancel Send KeyAction to oCancelButton
78058>>>>>
78058>>>>>Cd_End_Object
78060>>>>>>
78060>>>
78060>>>Activate_View Activate_oOrderEntryView for oOrderEntryView
78070>>>>
78070>>>Object oOrderEntryView is a dbView
78072>>>    Set Border_Style to Border_Thick
78073>>>    Set Maximize_Icon to True
78074>>>    Set Label to "Order Entry"
78075>>>    Set Location to 2 3
78076>>>    Set Size to 174 383
78077>>>    Set piMinSize to 174 383
78078>>>    Set pbAutoActivate to True
78079>>>    
78079>>>
78079>>>    Object Vendor_DD is a Vendor_DataDictionary
78081>>>    End_Object    // Vendor_DD
78082>>>
78082>>>    Object Invt_DD is a Invt_DataDictionary
78084>>>        Set DDO_Server to Vendor_DD
78085>>>    End_Object    // Invt_DD
78086>>>
78086>>>    Object Customer_DD is a Customer_DataDictionary
78088>>>    End_Object    // Customer_DD
78089>>>
78089>>>    Object SalesP_DD is a Salesp_DataDictionary
78091>>>    End_Object    // SalesP_DD
78092>>>
78092>>>    Object OrderHea_DD is a OrderHea_DataDictionary
78094>>>        Set DDO_Server to Customer_DD
78095>>>        Set DDO_Server to SalesP_DD
78096>>>        
78096>>>        // this lets you save a new OrderHea from within OrderDtl.
78096>>>        Set Allow_Foreign_New_Save_State to True
78097>>>        
78097>>>    End_Object    // OrderHea_DD
78098>>>    
78098>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
78100>>>        Set DDO_Server to OrderHea_DD
78101>>>        Set DDO_Server to Invt_DD
78102>>>        Set Constrain_File to OrderHea.File_Number
78103>>>        
78103>>>        Procedure Update
78106>>>                Forward Send Update_Order
78108>>>        End_Procedure // Update
78109>>>        
78109>>>        Procedure Backout
78112>>>                Forward Send Backout_Order
78114>>>        End_Procedure //Backout
78115>>>        
78115>>>        //Function Validate_Delete Returns Integer
78115>>>        //    Integer iRetVal
78115>>>        //    Forward Get Validate_Delete_Order to iRetVal
78115>>>        //    Function_Return iRetVal
78115>>>        //End_Function //Validate_Delete
78115>>>        
78115>>>    End_Object    // OrderDtl_DD
78116>>>
78116>>>    Set Main_DD to OrderHea_DD
78117>>>    Set Server to OrderHea_DD
78118>>>    
78118>>>    Object oDbContainer3d1 is a dbContainer3d
78120>>>        Set Size to 85 377
78121>>>        Set Location to 2 3
78122>>>        Set peAnchors to anTopLeftRight
78123>>>        
78123>>>        
78123>>>        Object oOrderHea_Order_Number is a dbForm
78125>>>            Entry_Item OrderHea.Order_Number
78126>>>            Set Label to "Order Number:"
78127>>>            Set Size to 13 42
78128>>>            Set Location to 4 63
78129>>>            Set peAnchors to anTopLeft
78130>>>            Set Label_Col_Offset to 2
78131>>>            Set Label_Justification_Mode to jMode_Right
78132>>>            
78132>>>        End_Object    // oOrderHea_Order_Number
78133>>>
78133>>>        Object oOrderHea_Customer_Number is a dbForm
78135>>>            Entry_Item Customer.Customer_Number
78136>>>            Set Label to "Customer Number:"
78137>>>            Set Size to 13 42
78138>>>            Set Location to 4 201
78139>>>            Set peAnchors to anTopRight
78140>>>            Set Label_Col_Offset to 2
78141>>>            Set Label_Justification_Mode to jMode_Right
78142>>>        End_Object    // oOrderHea_Customer_Number
78143>>>
78143>>>        Object oOrderHea_Order_Date is a dbForm
78145>>>            Entry_Item OrderHea.Order_Date
78146>>>            Set Label to "Order Date:"
78147>>>            Set Size to 13 67
78148>>>            Set Location to 4 299
78149>>>            Set peAnchors to anTopRight
78150>>>            Set Label_Col_Offset to 2
78151>>>            Set Label_Justification_Mode to jMode_Right
78152>>>            
78152>>>            Set Prompt_Object to oMonthCalendarPrompt
78153>>>            Set Prompt_Button_Mode to PB_PromptOn
78154>>>        End_Object    // oOrderHea_Order_Date
78155>>>
78155>>>        Object oCustomer_Name is a dbForm
78157>>>            Entry_Item Customer.Name
78158>>>            Set Label to "Customer Name:"
78159>>>            Set Size to 13 180
78160>>>            Set Location to 18 63
78161>>>            Set peAnchors to anTopLeftRight
78162>>>            Set Label_Col_Offset to 2
78163>>>            Set Label_Justification_Mode to jMode_Right
78164>>>        End_Object    // oCustomer_Name
78165>>>
78165>>>        Object oCustomer_Address is a dbForm
78167>>>            Entry_Item Customer.Address
78168>>>            Set Label to "Street Address:"
78169>>>            Set Size to 13 180
78170>>>            Set Location to 34 63
78171>>>            Set peAnchors to anTopLeftRight
78172>>>            Set Label_Col_Offset to 2
78173>>>            Set Label_Justification_Mode to jMode_Right
78174>>>        End_Object    // oCustomer_Address
78175>>>
78175>>>        Object oCustomer_City is a dbForm
78177>>>            Entry_Item Customer.City
78178>>>            Set Label to "City/State/Zip:"
78179>>>            Set Size to 13 84
78180>>>            Set Location to 49 63
78181>>>            Set peAnchors to anTopLeftRight
78182>>>            Set Label_Col_Offset to 2
78183>>>            Set Label_Justification_Mode to jMode_Right
78184>>>        End_Object    // oCustomer_City
78185>>>
78185>>>        Object oCustomer_State is a dbForm
78187>>>            Entry_Item Customer.State
78188>>>            Set Size to 13 20
78189>>>            Set Location to 49 155
78190>>>            Set peAnchors to anTopRight
78191>>>        End_Object    // oCustomer_State
78192>>>
78192>>>        Object oCustomer_Zip is a dbForm
78194>>>            Entry_Item Customer.Zip
78195>>>            Set Size to 13 60
78196>>>            Set Location to 49 183
78197>>>            Set peAnchors to anTopRight
78198>>>        End_Object    // oCustomer_Zip
78199>>>
78199>>>        Object oOrderHea_Ordered_By is a dbForm
78201>>>            Entry_Item OrderHea.Ordered_By
78202>>>            Set Label to "Ordered By:"
78203>>>            Set Size to 13 67
78204>>>            Set Location to 34 299
78205>>>            Set peAnchors to anTopRight
78206>>>            Set Label_Col_Offset to 2
78207>>>            Set Label_Justification_Mode to jMode_Right
78208>>>        End_Object    // oOrderHea_Ordered_By
78209>>>
78209>>>        Object oOrderHea_Salesperson_ID is a dbForm
78211>>>            Entry_Item Salesp.Id
78212>>>            Set Label to "Salesperson ID:"
78213>>>            Set Size to 13 40
78214>>>            Set Location to 49 299
78215>>>            Set peAnchors to anTopRight
78216>>>            Set Label_Col_Offset to 2
78217>>>            Set Label_Justification_Mode to jMode_Right
78218>>>        End_Object    // oOrderHea_Salesperson_ID
78219>>>
78219>>>        Object oOrderHea_Terms is a dbComboForm
78221>>>            Entry_Item OrderHea.Terms
78222>>>            Set Label to "Terms:"
78223>>>            Set Size to 13 85
78224>>>            Set Location to 64 63
78225>>>            Set peAnchors to anTopLeft
78226>>>            Set Form_Border to 0
78227>>>            Set Label_Col_Offset to 2
78228>>>            Set Label_Justification_Mode to jMode_Right
78229>>>
78229>>>        End_Object    // oOrderHea_Terms
78230>>>
78230>>>        Object oOrderHea_Ship_Via is a dbComboForm
78232>>>            Entry_Item OrderHea.Ship_Via
78233>>>            Set Label to "Ship Via:"
78234>>>            Set Size to 13 103
78235>>>            Set Location to 64 183
78236>>>            Set peAnchors to anTopRight
78237>>>            Set Form_Border to 0
78238>>>            Set Label_Col_Offset to 2
78239>>>            Set Label_Justification_Mode to jMode_Right
78240>>>
78240>>>        End_Object    // oOrderHea_Ship_Via
78241>>>
78241>>>    End_Object    // oDbContainer3d1
78242>>>
78242>>>    Object oOrderDtl_Grid is a cDbCJGrid
78244>>>        Set Server to OrderDtl_DD
78245>>>        Set Ordering to 1
78246>>>        Set Size to 63 377
78247>>>        Set Location to 90 3
78248>>>        Set peAnchors to anAll
78249>>>        Set pbAllowInsertRow to False
78250>>>        Set pbRestoreLayout to False
78251>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
78252>>>        Set piLayoutBuild to 6
78253>>>        Set pbHeaderPrompts to True
78254>>>
78254>>>        On_Key Key_F11 Send Request_InsertRow
78255>>>
78255>>>        Object oMark is a cCJGridColumnRowIndicator
78257>>>        End_Object
78258>>>        
78258>>>        Object oInvt_Item_ID is a cDbCJGridColumn
78260>>>            Entry_Item Invt.Item_ID
78261>>>            Set piWidth to 91
78262>>>            Set psCaption to "Item ID"
78263>>>            Set psImage to "ActionPrompt.ico"
78264>>>        End_Object
78265>>>
78265>>>        Object oInvt_Description is a cDbCJGridColumn
78267>>>            Entry_Item Invt.Description
78268>>>            Set piWidth to 213
78269>>>            Set psCaption to "Description"
78270>>>        End_Object
78271>>>
78271>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
78273>>>            Entry_Item Invt.Unit_Price
78274>>>            Set piWidth to 53
78275>>>            Set psCaption to "Unit Price"
78276>>>        End_Object
78277>>>
78277>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
78279>>>            Entry_Item OrderDtl.Qty_Ordered
78280>>>            Set piWidth to 50
78281>>>            Set psCaption to "Quantity"
78282>>>        End_Object
78283>>>
78283>>>        Object oOrderDtl_Price is a cDbCJGridColumn
78285>>>            Entry_Item OrderDtl.Price
78286>>>            Set piWidth to 62
78287>>>            Set psCaption to "Price"
78288>>>        End_Object
78289>>>
78289>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
78291>>>            Entry_Item OrderDtl.Extended_Price
78292>>>            Set piWidth to 81
78293>>>            Set psCaption to "Total"
78294>>>        End_Object
78295>>>        
78295>>>    End_Object    // oOrderDtl_Grid
78296>>>
78296>>>    Object oOrderHea_Order_Total is a dbForm
78298>>>        Entry_Item OrderHea.Order_Total
78299>>>        Set Label to "Order Total:"
78300>>>        Set Size to 13 60
78301>>>        Set Location to 156 307
78302>>>        Set peAnchors to anBottomRight
78303>>>        Set Label_Col_Offset to 3
78304>>>        Set Label_Justification_Mode to jMode_Right
78305>>>    End_Object    // oOrderHea_Order_Total
78306>>>
78306>>>    Object oPrintBtn is a Button
78308>>>        Set Label to "Print Order"
78309>>>        Set Location to 156 3
78310>>>        Set peAnchors to anBottomLeft
78311>>>        Set psToolTip to "Print preview of current order"
78312>>>
78312>>>        Procedure OnClick
78315>>>            Delegate Send PrintCurrentOrder // defined in view object
78317>>>        End_Procedure  // OnClick
78318>>>        
78318>>>    End_Object    // oPrintBtn
78319>>>
78319>>>
78319>>>    // Change:   Create custom confirmation messages for save and delete
78319>>>    //           We must create the new functions and assign verify messages
78319>>>    //           to them.
78319>>>    Function Confirm_Delete_Order Returns Integer
78322>>>        Integer iRetVal
78322>>>        Get Confirm "Delete Entire Order?" to iRetVal
78323>>>        Function_Return iRetVal
78324>>>    End_Function
78325>>>    
78325>>>    // Only confirm on the saving of new records
78325>>>    Function Confirm_Save_Order Returns Integer
78328>>>        Integer iNoSave iSrvr
78328>>>        Boolean bOld
78328>>>        Get Server to iSrvr
78329>>>        Get HasRecord of iSrvr to bOld
78330>>>        If not bOld Begin
78332>>>            Get Confirm "Save this NEW order header?" to iNoSave
78333>>>        End
78333>>>>
78333>>>        Function_Return iNoSave
78334>>>    End_Function
78335>>>    
78335>>>    // Define alternate confirmation Messages
78335>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
78336>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
78337>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
78338>>>    
78338>>>    
78338>>>    // print the current order. This message will be sent
78338>>>    // by the print button
78338>>>    Procedure PrintCurrentOrder
78341>>>        Integer hDD iNum
78341>>>        Get Server to hDD // this will be the OrderHea DD
78342>>>        If (HasRecord(hDD)) Begin // only do this if record exists
78344>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
78345>>>//            Send PrintOrder of oOrder_Report iNum
78345>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
78346>>>        End
78346>>>>
78346>>>    End_Procedure
78347>>>    
78347>>>    // refresh is sent to containers. We will use that to control the print button and only
78347>>>    // enable it when an order exists
78347>>>    Procedure Refresh Integer eMode
78350>>>        Boolean bRec
78350>>>        Handle hoServer
78350>>>        Get Server to hoServer
78351>>>        Get HasRecord of hoServer to bRec
78352>>>        Set Enabled_State of oPrintBtn to bRec
78353>>>    End_Procedure
78354>>>
78354>>>End_Object
78355>        Use SalesP.vw
Including file: Salesp.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Salesp.vw)
78355>>>Use dfClient.pkg
78355>>>Use DataDict.pkg
78355>>>Use dfEntry.pkg
78355>>>Use SalesP.DD
78355>>>
78355>>>DEFERRED_VIEW Activate_oSalesPersonView FOR ;;Object oSalesPersonView is a dbView
78380>>>    Set Border_Style to Border_None
78381>>>    Set Label to "Sales Person Entry View"
78382>>>    Set Location to 6 6
78383>>>    Set Size to 51 245
78384>>>
78384>>>    Object SalesP_DD is a Salesp_DataDictionary
78386>>>    End_Object    // Salesp_DD
78387>>>
78387>>>    Set Main_DD to SalesP_DD
78388>>>    Set Server to SalesP_DD
78389>>>
78389>>>    Object oContainer1 is a dbContainer3d
78391>>>        Set Size to 40 233
78392>>>        Set Location to 5 6
78393>>>        Object oSalesP_ID is a dbForm
78395>>>            Entry_Item SalesP.ID
78396>>>            Set Label to "Sales Person ID:"
78397>>>            Set Size to 13 46
78398>>>            Set Location to 4 70
78399>>>            Set Label_Col_Offset to 2
78400>>>            Set Label_Justification_Mode to jMode_Right
78401>>>        End_Object    // oSalesP_ID
78402>>>
78402>>>        Object oSalesP_Name is a dbForm
78404>>>            Entry_Item SalesP.Name
78405>>>            Set Label to "Sales Person Name:"
78406>>>            Set Size to 13 156
78407>>>            Set Location to 20 70
78408>>>            Set Label_Col_Offset to 2
78409>>>            Set Label_Justification_Mode to jMode_Right
78410>>>        End_Object    // oSalesP_Name
78411>>>
78411>>>    End_Object    // oContainer1
78412>>>
78412>>>CD_End_Object    // oSalesPersonView
78414>>>>
78414>        Use Vendor.vw
Including file: Vendor.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Vendor.vw)
78414>>>Use dfClient.pkg
78414>>>Use DataDict.pkg
78414>>>Use dfEntry.pkg
78414>>>Use dfCEntry.pkg
78414>>>Use Vendor.DD
78414>>>
78414>>>DEFERRED_VIEW Activate_oVendorView FOR ;;Object oVendorView is a dbView
78439>>>    Set Border_Style to Border_Thick
78440>>>    Set Label to "Vendor Entry View"
78441>>>    Set Location to 6 6
78442>>>    Set Size to 137 281
78443>>>    Set piMaxSize to 137 350
78444>>>    Set piMinSize to 137 215
78445>>>
78445>>>    Object Vendor_DD is a Vendor_DataDictionary
78447>>>    End_Object    // Vendor_DD
78448>>>
78448>>>    Set Main_DD to Vendor_DD
78449>>>    Set Server to Vendor_DD
78450>>>
78450>>>    Object oContainer1 is a dbContainer3d
78452>>>        Set Size to 129 273
78453>>>        Set Location to 4 4
78454>>>        Set peAnchors to anAll
78455>>>        Object oVendor_Id is a dbForm
78457>>>            Entry_Item Vendor.ID
78458>>>            Set Label to "Vendor ID:"
78459>>>            Set Size to 13 42
78460>>>            Set Location to 4 67
78461>>>            Set peAnchors to anTopLeft
78462>>>            Set Label_Col_Offset to 2
78463>>>            Set Label_Justification_Mode to jMode_Right
78464>>>        End_Object    // oVendor_ID
78465>>>
78465>>>        Object oVendor_Name is a dbForm
78467>>>            Entry_Item Vendor.Name
78468>>>            Set Label to "Vendor Name:"
78469>>>            Set Size to 13 186
78470>>>            Set Location to 18 67
78471>>>            Set peAnchors to anTopLeftRight
78472>>>            Set Label_Col_Offset to 2
78473>>>            Set Label_Justification_Mode to jMode_Right
78474>>>        End_Object    // oVendor_Name
78475>>>
78475>>>        Object oVendor_Address is a dbForm
78477>>>            Entry_Item Vendor.Address
78478>>>            Set Label to "Street Address:"
78479>>>            Set Size to 13 186
78480>>>            Set Location to 34 67
78481>>>            Set peAnchors to anTopLeftRight
78482>>>            Set Label_Col_Offset to 2
78483>>>            Set Label_Justification_Mode to jMode_Right
78484>>>        End_Object    // oVendor_Address
78485>>>
78485>>>        Object oVendor_City is a dbForm
78487>>>            Entry_Item Vendor.City
78488>>>            Set Label to "City:"
78489>>>            Set Size to 13 90
78490>>>            Set Location to 49 67
78491>>>            Set peAnchors to anTopLeft
78492>>>            Set Label_Col_Offset to 2
78493>>>            Set Label_Justification_Mode to jMode_Right
78494>>>        End_Object    // oVendor_City
78495>>>
78495>>>        Object oVendor_State is a dbComboForm
78497>>>            Entry_Item Vendor.State
78498>>>            Set Label to "State:"
78499>>>            Set Size to 13 32
78500>>>            Set Location to 64 67
78501>>>            Set peAnchors to anTopLeft
78502>>>            Set Form_Border to 0
78503>>>            Set Label_Col_Offset to 2
78504>>>            Set Label_Justification_Mode to jMode_Right
78505>>>            Set Entry_State to False
78506>>>            Set Code_Display_Mode to cb_code_display_code
78507>>>        End_Object    // oVendor_State
78508>>>
78508>>>        Object oVendor_Zip is a dbForm
78510>>>            Entry_Item Vendor.Zip
78511>>>            Set Label to "Zip/Postal Code:"
78512>>>            Set Size to 13 66
78513>>>            Set Location to 79 67
78514>>>            Set peAnchors to anTopLeft
78515>>>            Set Label_Col_Offset to 2
78516>>>            Set Label_Justification_Mode to jMode_Right
78517>>>        End_Object    // oVendor_Zip
78518>>>
78518>>>        Object oVendor_Phone_Number is a dbForm
78520>>>            Entry_Item Vendor.Phone_Number
78521>>>            Set Label to "Phone Number:"
78522>>>            Set Size to 13 126
78523>>>            Set Location to 94 67
78524>>>            Set peAnchors to anTopLeftRight
78525>>>            Set Label_Col_Offset to 2
78526>>>            Set Label_Justification_Mode to jMode_Right
78527>>>        End_Object    // oVendor_Phone_Number
78528>>>
78528>>>        Object oVendor_Fax_Number is a dbForm
78530>>>            Entry_Item Vendor.Fax_Number
78531>>>            Set Label to "Fax Number:"
78532>>>            Set Size to 13 126
78533>>>            Set Location to 108 67
78534>>>            Set peAnchors to anTopLeftRight
78535>>>            Set Label_Col_Offset to 2
78536>>>            Set Label_Justification_Mode to jMode_Right
78537>>>        End_Object    // oVendor_Fax_Number
78538>>>
78538>>>    End_Object    // oContainer1
78539>>>
78539>>>CD_End_Object    // oVendorView
78541>>>>
78541>        
78541>        Use Basic\CustomerListBR.rv
Including file: Basic\CustomerListBR.rv    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Basic\CustomerListBR.rv)
78541>>>Use DFAllRpt.pkg
78541>>>Use Basic\CustBasicRptImages.inc  // contains the images for the report
Including file: Basic\CustBasicRptImages.inc    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\Basic\CustBasicRptImages.inc)
78541>>>>>// CustBasicRptImages.pkg - images for CustomerListBR.rv
78541>>>>>// Since report images, such as the one used here, are not fully supported by
78541>>>>>// the Studio, we have placed the images for this report in a separate package.
78541>>>>>
/CUSTHDR
Image 2, CUSTHDR
                             Customer Listing                      Page:___.
Number  Name
----------------------------------------------------------------------------
/CustBody
Image 3, CUSTBODY
_____.  ______________________________
/Footer
Image 4, FOOTER
Date printed:  __/__/____
/*
78541>>>
78541>>>Open Customer
78543>>>Use dfrptvw.pkg
78543>>>Use dfRadio.pkg
Including file: Dfradio.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfradio.pkg)
78543>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
78543>>>>>
78543>>>Use Windows.pkg
78543>>>
78543>>>DEFERRED_VIEW Activate_oCustomerListBR FOR ;;Object oCustomerListBR is a ReportView
78568>>>
78568>>>    Property Integer piSortIndex Public 1
78570>>>
78570>>>    Set Label to "Customer List"
78571>>>    Set Location to 6 6
78572>>>    Set Size to 80 180
78573>>>
78573>>>    Object oDestination is a RadioGroup
78575>>>        Set Size to 50 80
78576>>>        Set Location to 5 5
78577>>>        Set Label to "Output Device:"
78578>>>        Object oScreen is a Radio
78580>>>            Set Label to "Screen"
78581>>>            Set Size to 10 39
78582>>>            Set Location to 15 10
78583>>>            Set Status_Help to "Preview the report to screen"
78584>>>        End_Object    // oScreen
78585>>>
78585>>>        Object oPrinter is a Radio
78587>>>            Set Label to "Printer"
78588>>>            Set Size to 10 37
78589>>>            Set Location to 30 10
78590>>>            Set Status_Help to "Send the report to the default printer"
78591>>>        End_Object    // oPrinter
78592>>>
78592>>>        // set the Output_Device_Mode each time the radio button changes
78592>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78595>>>            Forward Send Notify_Select_State iNewItem iOldItem
78597>>>        
78597>>>            If (iNewItem=0) Set Output_Device_Mode To PRINT_TO_WINDOW
78600>>>            Else            Set Output_Device_Mode To PRINT_TO_PRINTER
78602>>>        End_Procedure
78603>>>
78603>>>    End_Object    // oDestination
78604>>>
78604>>>    Object oOrderRadio is a RadioGroup
78606>>>        Set Size to 50 80
78607>>>        Set Location to 5 95
78608>>>        Set Label to "Report Order:"
78609>>>        Object oNumber is a Radio
78611>>>            Set Label to "Number"
78612>>>            Set Size to 10 41
78613>>>            Set Location to 15 10
78614>>>            Set Status_Help to "Sort by customer number"
78615>>>        End_Object    // oNumber
78616>>>
78616>>>        Object oName is a Radio
78618>>>            Set Label to "Name"
78619>>>            Set Size to 10 35
78620>>>            Set Location to 30 10
78621>>>            Set Status_Help to "Sort by customer name"
78622>>>        End_Object    // oName
78623>>>
78623>>>        // set the piSortIndex each time the radio button changes
78623>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
78626>>>            Forward Send Notify_Select_State iNewItem iOldItem
78628>>>        
78628>>>            Set piSortIndex  To (iNewItem + 1)
78629>>>        End_Procedure
78630>>>
78630>>>    End_Object    // oOrderRadio
78631>>>
78631>>>    Object oOkButton is a Button
78633>>>        Set Label to "OK"
78634>>>        Set Size to 14 51
78635>>>        Set Location to 62 71
78636>>>        Set Default_State to True
78637>>>
78637>>>        Procedure OnClick
78640>>>            Send StartReport
78641>>>        End_Procedure
78642>>>
78642>>>    End_Object    // oOkButton
78643>>>
78643>>>    Object oCancelButton is a Button
78645>>>        Set Label to "Cancel"
78646>>>        Set Location to 62 125
78647>>>
78647>>>        Procedure OnClick
78650>>>            Send Request_Cancel
78651>>>        End_Procedure
78652>>>
78652>>>    End_Object    // oCancelButton
78653>>>
78653>>>    Procedure StartReport
78656>>>        Integer iOutputDevice
78656>>>        Handle hoThisWorkspace
78656>>>        String sCurDir sDataPath 
78656>>>        String sFileName
78656>>>                    
78656>>>        Get Output_Device_Mode to iOutputDevice
78657>>>
78657>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78659>>>            // save current location
78659>>>            Get_Current_Directory to sCurDir
78660>>>
78660>>>            // get workspace data path (all users must have r/w rights to it) to output the temp file there
78660>>>            Get phoWorkspace of ghoApplication to hoThisWorkspace
78661>>>            Get psDataPath of hoThisWorkspace to sDataPath
78662>>>            Get PathAtIndex of hoThisWorkspace sDataPath 1 to sDataPath
78663>>>            
78663>>>            // set current directory to DataPath
78663>>>            Set_Directory sDataPath
78664>>>        
78664>>>            Make_Temp_File "TXT" sFileName
78665>>>            Move (".\" - sFileName) to sFileName
78666>>>            Set Output_Device_Name to sFileName
78667>>>        End
78667>>>>
78667>>>        Else Begin
78668>>>           Set Output_Device_Name to "WinLST:"
78669>>>        End
78669>>>>
78669>>>    
78669>>>        Send Run_Report
78670>>>    
78670>>>        If (iOutputDevice=PRINT_TO_WINDOW) Begin
78672>>>           Runprogram background "NotePad" sFileName
78673>>>           EraseFile sFileName
78674>>>>
78674>>>        End
78674>>>>
78674>>>        
78674>>>        // restore previous location
78674>>>        Set_Directory sCurDir
78675>>>        
78675>>>    End_Procedure   // StartReport
78676>>>    
78676>>>    Object oCustomer_BasicReport is a BasicReport
78678>>>    
78678>>>        Report_Main_File Customer
78679>>>    
78679>>>        Set Report_Title to "Printing Customer Names"
78680>>>    
78680>>>        Function Starting_Main_Report Returns Integer
78683>>>            Integer iRetVal
78683>>>            Integer iIndex
78683>>>    
78683>>>            Forward Get Starting_Main_Report to iRetVal
78685>>>    
78685>>>            Get piSortIndex To iIndex
78686>>>            Report_Index BY iIndex    // set the sort order
78688>>>            Sysdate Footer.1         // set date for report
78689>>>            
78689>>>            Function_Return iRetVal
78690>>>        End_Function
78691>>>    
78691>>>        Procedure_Section Page_Top as CustHdr
78696>>>            Integer iPage
78696>>>            Get Page_Count To iPage
78697>>>            Print iPage
78698>>>            OutPut_PageCheck
78699>>>        End_Procedure
78700>>>    
78700>>>        Procedure_Section Body as CustBody
78705>>>            Send Update_Status (String(Customer.Customer_Number)- ":" * Customer.Name )
78706>>>            Print Customer.Customer_number
78707>>>            Print Customer.Name
78708>>>            OutPut_PageCheck
78709>>>        End_Procedure
78710>>>    
78710>>>        Procedure_Section Page_Bottom as Footer
78720>>>            OutPut_PageCheck
78721>>>        End_Procedure
78722>>>    
78722>>>    End_Object    // Customer_BasicReport
78723>>>
78723>>>CD_End_Object    // oCustomerListBR
78725>>>>
78725>        Use WinPrint\CustomerListWP.rv
Including file: WinPrint\CustomerListWP.rv    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\WinPrint\CustomerListWP.rv)
78725>>>Use dfrptvw.pkg
78725>>>Use DataDict.pkg
78725>>>Use dfRadio.pkg
78725>>>Use Windows.pkg
78725>>>Use cWinReport2.pkg
Including file: cWinReport2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cWinReport2.pkg)
78725>>>>>// cWinReport2.pkg
78725>>>>>
78725>>>>>// defines support for new Winprint2 cWinReport2 class
78725>>>>>
78725>>>>>
78725>>>>>Use DFRpt.pkg              // BasicReport RO Class for VDF
78725>>>>>Use WinPrint2.pkg          // WinPrint2 engine
Including file: Winprint2.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Winprint2.pkg)
78725>>>>>>>// WinPrint2.pkg
78725>>>>>>>//
78725>>>>>>>Use windows.pkg
78725>>>>>>>Use LanguageText.pkg
78725>>>>>>>Use DLL.pkg
78725>>>>>>>Use WinPrint2_Api.pkg
Including file: WinPrint2_API.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinPrint2_API.pkg)
78725>>>>>>>>>//WinPrint2_API.pkg
78725>>>>>>>>>
78725>>>>>>>>>Use DLL.pkg
78725>>>>>>>>>
78725>>>>>>>>>External_Function WP_IsPrinterValid "IsPrinterValid" WinPrint.dll ;Returns Boolean // True if the the current printer is a valid one. False, otherwise.
78726>>>>>>>>>
78726>>>>>>>>>External_Function WP_ArePrintersInstalled "ArePrintersInstalled" WinPrint.dll ; // determines whether at least one printer is installedReturns Boolean // True, if a printer is installed, False if it is not.
78727>>>>>>>>>
78727>>>>>>>>>External_Function WP_ExecutePrinterSetupDialog "ExecutePrinterSetupDialog" WinPrint.dll ; // displays the "printer setup" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78728>>>>>>>>>
78728>>>>>>>>>External_Function WP_ExecutePrintDialog "ExecutePrintDialog" WinPrint.dll ; // displays the "Print" dialog   Handle hWndParent; // window handle of the parent windowReturns Boolean // True if the OK button pressed; False, otherwise.
78729>>>>>>>>>
78729>>>>>>>>>External_Function WP_GetCurrentDevice "GetCurrentDevice" WinPrint.dll ; // retrieves the name of the current printer device    Address aDevice ; // address of the string (255 chars) that will hold the device name upon returnReturns Boolean // True, if success; False if error occurred
78730>>>>>>>>>
78730>>>>>>>>>External_Function WP_GetPrintDialogFlags "GetPrintDialogFlags" WinPrint.dll ; // retrieves the current print optionsReturns UInteger // array of flags representing print-related options that are currently set
78731>>>>>>>>>
78731>>>>>>>>>External_Function WP_GetUserDefinedPapersize "GetUserDefinedPapersize" WinPrint.dll ;  // gets the size of user-defined paperReturns UInteger // // hi-word=length; lo-word=width
78732>>>>>>>>>
78732>>>>>>>>>External_Function WP_IsPrintDialogFlagSet "IsPrintDialogFlagSet" WinPrint.dll ; // determines whether a specific print-flag is set    UInteger iFlag ; // the printer flagReturns Boolean // True, if the flag is set; False, if it isn't
78733>>>>>>>>>
78733>>>>>>>>>External_Function WP_SelectPrinter "SelectPrinter" WinPrint.dll ; // selects a printer programatically    String sDevice; // the name of the printerReturns Boolean // True, if success; False, if error (such as an invalid printer name)
78734>>>>>>>>>
78734>>>>>>>>>External_Function WP_SetFirstPagePaperSource "SetFirstPagePaperSource"  WinPrint.dll ;        Integer iBin ; // the bim constantReturns Boolean // True if success, false if error
78735>>>>>>>>>
78735>>>>>>>>>External_Function WP_SetNumberOfPrintCopies "SetNumberOfPrintCopies" WinPrint.dll ; // sets the number of copies to print    UInteger iNumCopies; // number of copies to makeReturns Boolean // Always True
78736>>>>>>>>>
78736>>>>>>>>>External_Function WP_SetSpecificPrintDialogFlag "SetSpecificPrintDialogFlag" WinPrint.dll; // Sets/unsets one printer flag    UInteger fFlag; // printer flagReturns Boolean // True, if success; False if error occurred
78737>>>>>>>>>
78737>>>>>>>>>External_Function WP_SetPrintDialogFlags "SetPrintDialogFlags" WinPrint.dll; // Sets/unsets all printer flags in one call    UInteger fFlags; // printer flagsReturns Boolean // True, if success; False if error occurred
78738>>>>>>>>>
78738>>>>>>>>>External_Function WP_SetUserDefinedPapersize "SetUserDefinedPapersize" WinPrint.dll ;  // sets the size of user-defined paper    UInteger iPaperSize ; // hi-word=length; lo-word=widthReturns Boolean; // True, if success; False if error occurred
78739>>>>>>>>>External_Function WP_SetFontStyle "SetFontStyle" WinPrint.dll ; // sets multiple font attributes    Integer iStyles ; // series of flagsReturns Boolean // always True
78740>>>>>>>>>
78740>>>>>>>>>External_Function WP_SetFontBold "SetFontBold" WinPrint.dll ; // toggles the bold attribute of the current font    Boolean bBold ; // True to switch bold attribute on; False to switch it offReturns Boolean // always True
78741>>>>>>>>>
78741>>>>>>>>>External_Function WP_SetFontItalic "SetFontItalic" WinPrint.dll ; // toggles the italic attribute of the current font    Boolean bItalic ; // True to switch italic attribute on; False to switch it offReturns Boolean  // always True
78742>>>>>>>>>
78742>>>>>>>>>External_Function WP_SetFontUnderline "SetFontUnderline" WinPrint.dll ; // toggles the underline attribute of the current font    Boolean bUnderline ; // True to switch underline attribute on; False to switch it offReturns Boolean  // always True
78743>>>>>>>>>
78743>>>>>>>>>External_Function WP_SetFontStrikeout "SetFontStrikeout" WinPrint.dll ; // toggles the strikeout attribute of the current font    Boolean bStrikeout ; // True to switch strikeout attribute on; False to switch it offReturns Boolean  // always True
78744>>>>>>>>>
78744>>>>>>>>>External_Function WP_SetFontColor "SetFontColor" WinPrint.dll ; // sets the color of the current font    Integer iColor ; // color of the fontReturns Boolean  // always True
78745>>>>>>>>>
78745>>>>>>>>>External_Function WP_SetFontHeight "SetFontHeight" WinPrint.dll ; // sets the height of the font    UInteger iHeight ; // height of the font in points (multiplied by 100. Eg 12.5 point should be sent as 1250)Returns Boolean  // always True
78746>>>>>>>>>
78746>>>>>>>>>External_Function WP_SetFontName "SetFontName" WinPrint.dll ; // Sets the name of the font to use    String sFontName ; // name of the font to useReturns Boolean  // always True
78747>>>>>>>>>
78747>>>>>>>>>External_Function WP_DrawBitmap "DrawBitmap" WinPrint.dll ; // Draws a bitmap (BMP, JPG)    String  sBitmap;                 // Name of the bitmap    Integer iLeft;                   // distance from left edge to draw bitmap    Integer iTop;                    // distance from top edge to draw bitmap    Integer iWidth;                  // width of the bitmap    Integer iHeight;                 // height of the bitmap    Boolean bUpdateCurrentPosition;  // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78748>>>>>>>>>
78748>>>>>>>>>External_Function WP_DrawEllipse "DrawEllipse" WinPrint.dll ; // draws an elipse within a bounding rectangle    Integer iLeft;                   // distance from left edge to draw the ellipse    Integer iTop;                    // distance from top edge to draw the ellipse    Integer iWidth;                  // width of the bounding rectangle    Integer iHeight;                 // height of the bounding rectangle    Integer iBorderColor;            // color of the ellipse's edge    Integer iFillColor;              // internal color of the ellipse    Boolean  bFill;                  // should the ellipse be filled? (False=transparent)    UInteger iThickness;             // thickness of the elipse    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the ellipse be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78749>>>>>>>>>
78749>>>>>>>>>External_Function WP_DrawLine "DrawLine" WinPrint.dll ; // draws a line from the current position    Integer iLeft;                   // distance from left edge to draw the line    Integer iTop;                    // distance from top edge to draw the line    Integer iLength;                 // length of the line    Boolean  bHorizontal;            // draw horizontal? (False=vertical)    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if OK; False, if an error occurred.
78750>>>>>>>>>
78750>>>>>>>>>External_Function WP_DrawRectangle "DrawRectangle" WinPrint.dll ; // draws a rectangle    Integer iLeft;                   // distance from left edge to draw the rectangle    Integer iTop;                    // distance from top edge to draw the rectangle    Integer iWidth;                  // width of the rectangle    Integer iHeight;                 // height of the rectangle    Integer iBorderColor;            // color of the rectangle's border    Integer iFillColor;              // internal color of the rectangle    Boolean  bFill;                  // should the rectangle be filled? (False=transparent)    UInteger iThickness;             // thickness of the rectangle's border    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the rectangle be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78751>>>>>>>>>
78751>>>>>>>>>External_Function WP_DrawXYLine "DrawXYLine" WinPrint.dll ; // draws a line between two points    Integer iLeftStart;              // distance from left edge to draw from    Integer iTopStart;               // distance from top edge to draw from    Integer iLeftEnd;                // distance from left edge to draw to    Integer iTopEnd;                 // distance from top edge to draw to    Integer iColor;                  // color of the line    UInteger iThickness;             // thickness of the line    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?    Boolean  bWrap;                  // Should the line be drawn on future soft-page breaks?Returns Boolean // True, if OK; False, if an error occurred.
78752>>>>>>>>>
78752>>>>>>>>>External_Function WP_SetAbsoluteMargins "SetAbsoluteMargins" WinPrint.dll ; // modifies the top/bottom non-printable margin    UInteger iTop;      // the top margin offset    UInteger iBottom;   // the bottom margin offset    Boolean  bAllPages; // should all pages be affected? True=AllPages; False=first page onlyReturns Boolean // always True
78753>>>>>>>>>
78753>>>>>>>>>External_Function WP_SetMargins "SetMargins" WinPrint.dll ; // Sets the user-margins    UInteger iLeft;   // the left margin    UInteger iTop;    // the top margin    UInteger iRight;  // the right margin    UInteger iBottom; // the bottom marginReturns Boolean // always True
78754>>>>>>>>>
78754>>>>>>>>>External_Function WP_CreateDiagram "CreateDiagram" WinPrint.dll ; // Creates a new diagram    UInteger eType;       // type of diagram (Bar, Line, Pie)    UInteger eEffect;     // how it is drawn (2d or 3d, etc)    UInteger iWidth;      // width of the diagram    UInteger iHeight;     // height of the diagram    Boolean  bDrawXyAxis; // draw the xy-axis (for bar charts only)?Returns Handle // unique id for the diagram used in other diagram funtions
78755>>>>>>>>>
78755>>>>>>>>>External_Function WP_AddDiagramEntry "AddDiagramEntry" WinPrint.dll ; // Adds an item into a diagram    Handle   hDiagram;          // diagram handle returned by CreateDiagram()    String   sValueDescription; // description of the item    String   sValue;            // value of the item    Integer iBorderColor;       // color of the item's border    Integer iFillColor;         // color of the item's interior    Boolean  bFilled;           // should the item be drawn filled (with iFillColor), or transparent?    UInteger iNumDecimals;      // Number of decimals in the sValue argument    UInteger eValueOrPercent;   // How the value should be displayed (as value or percentage, etc)    Boolean  bExploded;         // should the value be "pulled out" (pie charts only)Returns Boolean // True, if success; False, if error
78756>>>>>>>>>
78756>>>>>>>>>External_Function WP_DrawDiagram "DrawDiagram" WinPrint.dll ; // draws a diagram    Handle   hDiagram;               // diagram handle returned by CreateDiagram()    UInteger iLeft;                  // x-coordinate to draw the diagram    UInteger iTop;                   // y-coordinate to draw the diagram    Boolean  bUpdateCurrentPosition; // after drawing, should the current position be updated?Returns Boolean // True, if success; False, if error
78757>>>>>>>>>
78757>>>>>>>>>External_Function WP_LockDiagram "LockDiagram" WinPrint.dll ; // Locks a diagram so that no more entries can be added    Handle hDiagram; // diagram handle returned by CreateDiagram()Returns Boolean // True, if success; False, if error
78758>>>>>>>>>
78758>>>>>>>>>External_Function WP_SetDiagramCaption "SetDiagramCaption" WinPrint.dll ; // Sets the caption of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sCaption; // the diagram's captionReturns Boolean // True, if success; False, if error
78759>>>>>>>>>
78759>>>>>>>>>External_Function WP_SetDiagramXText "SetDiagramXText" WinPrint.dll ; // Sets the horizontal label of a diagram    Handle hDiagram; // diagram handle returned by CreateDiagram()    String sText;    // the diagram's horizonal labelReturns Boolean // True, if success; False, if error
78760>>>>>>>>>
78760>>>>>>>>>External_Function WP_SetDiagramYText "SetDiagramYText" WinPrint.dll ; // Sets the vertical label of a diagram    Handle  hDiagram;      // diagram handle returned by CreateDiagram()    String  sText;         // the diagram's vertical label    Boolean bVerticalText; // should the text be drawn vertically (False=horizontally)Returns Boolean // True, if success; False, if error
78761>>>>>>>>>
78761>>>>>>>>>External_Function WP_BeginHeader "BeginHeader" WinPrint.dll ; // creates a new header    UInteger iHeaderType; // the type of header    UInteger iSubHeaderNum; // for subheaders, then number (1-0)Returns Boolean // always True
78762>>>>>>>>>
78762>>>>>>>>>External_Function WP_EndHeader "EndHeader" WinPrint.dll ; // declares the end of the current headerReturns Boolean // always True
78763>>>>>>>>>
78763>>>>>>>>>External_Function WP_SetExtraLineCheck "SetExtraLineCheck" WinPrint.dll ; // forces a soft page break if header plus number of lines don't fit on page    UInteger iNumLines; // number of lines in addition to header required before forcing a soft page-breakReturns Boolean; // always True
78764>>>>>>>>>External_Function WP_SetHeaderFrame "SetHeaderFrame" WinPrint.dll ; // sets the style, color and frame of a header    UInteger eFrame;     // style of frame (margin-to-margin, etc)    Integer iColor;      // color of the frame's edge    UInteger iThickness; // thickness of the frame    Integer iFillCol;    // the internal color of the frame (only used if bBilled=True)    Boolean  bFilled;    // True, if the frame should be filled with the iFillColor (False=Transparent)Returns Boolean // Always True
78765>>>>>>>>>
78765>>>>>>>>>External_Function WP_SetHeaderMargin "SetHeaderMargin" WinPrint.dll ; // Sets a margin of space on the inside and outside of the current header    UInteger eType;      // Specifies which margin areas is being set.    Integer  iSize;      // Size of the margin setting in the current report metricsReturns Boolean  // False if document is not started
78766>>>>>>>>>
78766>>>>>>>>>External_Function WP_SetHeaderPlacement "SetHeaderPlacement" WinPrint.dll ; // placement (left, center or right) of the header    UInteger ePlacement; // placed left, center or rightReturns Boolean //always True
78767>>>>>>>>>
78767>>>>>>>>>External_Function WP_SetHeaderWrap "SetHeaderWrap" WinPrint.dll ; // determines whether the current header is drawn on soft page-breaks    Boolean bWrap; // True, to wrap onto following pages; False, for current page onlyReturns Boolean // always True
78768>>>>>>>>>
78768>>>>>>>>>External_Function WP_WriteHeader "WriteHeader" WinPrint.dll ; // writes a header to the current page    UInteger eHeaderType;   // type of header    UInteger iSubHeaderNum; // for subheaders, the number (1-9)Returns Boolean // True, if success; False, if error
78769>>>>>>>>>
78769>>>>>>>>>External_Function WP_RGBToDFPrintColor "RGBToDFPrintColor" WinPrint.dll ; // converts R, G, and B values into a composite color that WinPrint expects    UInteger iRed;   // red component (1-255)    UInteger iGreen; // green component (1-255)    UInteger iBlue;  // blue component (1-255)Returns Integer // composite color
78770>>>>>>>>>
78770>>>>>>>>>External_Function WP_GetMetrics "GetMetrics" WinPrint.dll ; // gets the current unit of measurementReturns UInteger // unit of measurement (Inch or CM)
78771>>>>>>>>>
78771>>>>>>>>>External_Function WP_SetMetrics "SetMetrics" WinPrint.dll ; // sets the unit of measurement   UInteger eMetrics; // Inch or CMReturns Boolean // always True
78772>>>>>>>>>
78772>>>>>>>>>External_Function WP_ClearDocument "ClearDocument" WinPrint.dll ; // clears the resources of the document from memoryReturns Boolean // always True
78773>>>>>>>>>
78773>>>>>>>>>External_Function WP_NewDocument "NewDocument" WinPrint.dll ; // starts a new document, but preserves the printer settings   Boolean bAutoPreview ; // Should the Previewer be displayed immediatelyReturns Boolean // True, if success; False, if an error occurred
78774>>>>>>>>>
78774>>>>>>>>>External_Function WP_EndDocument "EndDocument" WinPrint.dll ; // Indicates that the document is finishedReturns Boolean // always True
78775>>>>>>>>>
78775>>>>>>>>>External_Function WP_ClearPrinter "ClearPrinter" WinPrint.dll ; // clears all printer and document resourcesReturns Boolean // True, if success; False, if an error occurred
78776>>>>>>>>>
78776>>>>>>>>>External_Function WP_ConfirmLines "ConfirmLines" WinPrint.dll ; // ensures that a specified number of lines will fit on the page; if not, a soft page-break is performed automatically    UInteger iNumLines; // number of lines that must fit on the pageReturns Boolean // True, if success; False, if an error occurred
78777>>>>>>>>>
78777>>>>>>>>>External_Function WP_CreatePage "CreatePage" WinPrint.dll ; // creates a new page of specified columns   UInteger iNumColumns; // number of columns (zero= no columns)Returns UInteger; // page number that was created
78778>>>>>>>>>External_Function WP_PreviewDocument "PreviewDocument" WinPrint.dll ; // previews the current document    Boolean bPrintDialog; // Determines whether the Print Dialog (range, etc) is displayed when the "print" button is clicked in the preview window.    Boolean bPrintSetup;  // Determines whether the Print Setup button is enabled (allows to change orientation, etc)    Boolean bPrint;       // Determines whether the Print button is enabledReturns Handle // non-zero = hViewerProcess; zero= error
78779>>>>>>>>>
78779>>>>>>>>>External_Function WP_ClosePreview "ClosePreview" WinPrint.dll ; // closes the preview windowReturns Boolean // True, if closed; False, if an error occurred (such as it not being already open)
78780>>>>>>>>>
78780>>>>>>>>>External_Function WP_PrintDocument "PrintDocument" WinPrint.dll ; // prints the current document    Handle hWndParent; // window handle of object to use for any modal outputReturns Boolean // True, if success; False, if an error occurred
78781>>>>>>>>>
78781>>>>>>>>>External_Function WP_SetAlign "SetAlign" WinPrint.dll ; // align future text    UInteger eAlign; // left, center or rightReturns Boolean // always True
78782>>>>>>>>>
78782>>>>>>>>>External_Function WP_WriteText "WriteText" WinPrint.dll ; // write text to the current position or column    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iColumnNum;        // number of the column to write to (zero=no column, use current position)    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78783>>>>>>>>>
78783>>>>>>>>>External_Function WP_WriteTextAtPosition "WriteTextAtPosition" WinPrint.dll ; // writes text to a specific position    String sText;               // the text to write    Boolean bNewLineAfterPrint; // should a "CR" be written after the text    UInteger iPosition;         // horizontal position to write the text    Integer iNumDecimals;       // number of decimals in the text (-1 means sText is a string)    UInteger iWidth;            // width of text before truncatingReturns Boolean // True, if success; False, if an error occurred
78784>>>>>>>>>
78784>>>>>>>>>External_Function WP_SetProgressCaption "SetProgressCaption" WinPrint.dll ;    String sProgressCaption ;Returns Boolean
78785>>>>>>>>>
78785>>>>>>>>>External_Function WP_SetReportTitle     "SetReportTitle"     WinPrint.dll ;    String sCaption ;Returns Boolean
78786>>>>>>>>>
78786>>>>>>>>>External_Function WP_ViewerWantsToClose "ViewerWantsToClose" WinPrint.dll ;Returns Integer
78787>>>>>>>>>
78787>>>>>>>>>External_Function WP_DisplayMessageBox  "DisplayMessageBox"  WinPrint.dll ;    String sCaption String sText ;Returns Integer
78788>>>>>>>>>
78788>>>>>>>>>External_Function WP_GetViewerWindow "GetViewerWindow" Winprint.dll ;Returns Handle
78789>>>>>>>>>
78789>>>>>>>>>External_Function WP_GetDocumentStatus "GetDocumentStatus" Winprint.dll ;Returns Integer // returns dsNotStarted, dsStarted, or dsFinished
78790>>>>>>>>>
78790>>>>>>>Use WinPrint_Constants.pkg
78790>>>>>>>Use Rgb.pkg
78790>>>>>>>Use GlobalFunctionsProcedures.pkg
78790>>>>>>>
78790>>>>>>>DEFINE INFINITE for -1
78790>>>>>>>DEFINE WAIT_TIMEOUT for |CI$00000102
78790>>>>>>>
78790>>>>>>>
78790>>>>>>>DEFINE QS_KEY            for |CI$0001
78790>>>>>>>DEFINE QS_MOUSEMOVE      for |CI$0002
78790>>>>>>>DEFINE QS_MOUSEBUTTON    for |CI$0004
78790>>>>>>>DEFINE QS_POSTMESSAGE    for |CI$0008
78790>>>>>>>DEFINE QS_TIMER          for |CI$0010
78790>>>>>>>DEFINE QS_PAINT          for |CI$0020
78790>>>>>>>DEFINE QS_SENDMESSAGE    for |CI$0040
78790>>>>>>>DEFINE QS_HOTKEY         for |CI$0080
78790>>>>>>>DEFINE QS_ALLPOSTMESSAGE for |CI$0100
78790>>>>>>>DEFINE QS_MOUSE          for (QS_MOUSEMOVE ior QS_MOUSEBUTTON)
78790>>>>>>>DEFINE QS_INPUT          for (QS_MOUSE ior QS_KEY)
78790>>>>>>>DEFINE QS_ALLEVENTS      for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY)
78790>>>>>>>DEFINE QS_ALLINPUT       for (QS_INPUT ior QS_POSTMESSAGE ior QS_TIMER ior QS_PAINT ior QS_HOTKEY ior QS_SENDMESSAGE)
78790>>>>>>>
78790>>>>>>>External_Function WaitForSingleObject "WaitForSingleObject" Kernel32.dll Handle hHandle Dword dwMilliseconds Returns DWord
78791>>>>>>>External_Function GetCurrentProcessId "GetCurrentProcessId" Kernel32.dll Returns DWord
78792>>>>>>>External_Function GetCurrentProcess "GetCurrentProcess" Kernel32.dll Returns DWord
78793>>>>>>>
78793>>>>>>>External_Function MsgWaitForMultipleObjects "MsgWaitForMultipleObjects" User32.dll ;    DWORD nCount;             // number of handles in the object handle array    Address pHandles;     // pointer to the object-handle array    Boolean fWaitAll;     // wait for all or wait for one    DWORD dwMilliseconds; // time-out interval in milliseconds    DWORD dwWakeMask;     // type of input events to wait forReturns Dword
78794>>>>>>>
78794>>>>>>>Use GlobalFunctionsProcedures.pkg
78794>>>>>>>
78794>>>>>>>Class cWinPrint2 is a cObject // JJT: Will we need a windows handle for this like old one
78795>>>>>>>    Procedure Construct_Object
78797>>>>>>>        forward send construct_object
78799>>>>>>>
78799>>>>>>>        //*** internal properties
78799>>>>>>>        Property Integer DFCurrent_Color       0
78800>>>>>>>        Property String  DFCurrent_OutPut      "WinPrint"
78801>>>>>>>        Property Integer DFCurrent_Diagram     0
78802>>>>>>>        Property Integer DFCurrent_HeaderType  0
78803>>>>>>>        Property Integer DFCurrent_HeaderNr    0
78804>>>>>>>        Property Number  DFCurrent_FontSize    10
78805>>>>>>>        Property String  DFCurrent_Font        "Arial"
78806>>>>>>>
78806>>>>>>>        //*** Default values for margins 2.53 CM = 1 inch
78806>>>>>>>        Property Number  DFLeft_Margin    2.53
78807>>>>>>>        Property Number  DFTop_Margin     2.53
78808>>>>>>>        Property Number  DFright_Margin   2.53
78809>>>>>>>        Property Number  DFBottom_Margin  2.53
78810>>>>>>>
78810>>>>>>>        // If WP1 this defaults to false. In 2, it is true which means that the print job
78810>>>>>>>        // dialog appears when you hitprint in previewer.
78810>>>>>>>        Property Integer PrintDlgInPreview   1
78811>>>>>>>         // This does nothing in Wp2 (because you can't to this anyway)
78811>>>>>>>        Property Integer EnablePrintSetupFromPreview  True
78812>>>>>>>        Property Integer EnablePrintFromPreview  1
78813>>>>>>>
78813>>>>>>>        // is the GUI Suspended. This is privately maintained and is used
78813>>>>>>>        // to figure out if a preview panel is up or not
78813>>>>>>>        Property Integer pbIsSuspended False
78814>>>>>>>
78814>>>>>>>        Object oDFColorArray is an Array
78816>>>>>>>           //Moved into array
78816>>>>>>>           Set Value  0  To RGB_WHITE
78817>>>>>>>           Set Value  1  To RGB_RED
78818>>>>>>>           Set Value  2  To RGB_BLUE
78819>>>>>>>           Set Value  3  To RGB_GREEN
78820>>>>>>>           Set Value  4  To RGB_YELLOW
78821>>>>>>>           Set Value  5  To RGB_GREY
78822>>>>>>>           Set Value  6  To RGB_CYAN
78823>>>>>>>           Set Value  7  To RGB_MAGENTA
78824>>>>>>>           Set Value  8  To RGB_DRED
78825>>>>>>>           Set Value  9  To RGB_DBLUE
78826>>>>>>>           Set Value  10 To RGB_DGREEN
78827>>>>>>>           Set Value  11 To RGB_DYELLOW
78828>>>>>>>           Set Value  12 To RGB_DGREY
78829>>>>>>>           Set Value  13 To RGB_DCYAN
78830>>>>>>>           Set Value  14 To RGB_DMAGENTA
78831>>>>>>>           Set Value  15 To RGB_BLACK
78832>>>>>>>        End_Object
78833>>>>>>>
78833>>>>>>>        Object oDiagramArray is an Array
78835>>>>>>>        End_Object
78836>>>>>>>
78836>>>>>>>    End_Procedure
78837>>>>>>>
78837>>>>>>>    Function ViewerWantsToClose returns Boolean
78839>>>>>>>        Function_return (WP_ViewerWantsToClose())
78840>>>>>>>    end_Function
78841>>>>>>>
78841>>>>>>>    Function IsViewerActive returns boolean
78843>>>>>>>        Function_Return (WP_GetViewerWindow()<>0)
78844>>>>>>>    end_function
78845>>>>>>>
78845>>>>>>>    Function IsPrinterValid Returns Boolean
78847>>>>>>>        Function_Return (WP_IsPrinterValid()<>0)
78848>>>>>>>    End_Function
78849>>>>>>>
78849>>>>>>>    Function ArePrintersInstalled returns boolean
78851>>>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
78852>>>>>>>    End_Function
78853>>>>>>>
78853>>>>>>>
78853>>>>>>>    // returns docucument state: dsNotStarted, dsStarted, dsFinished
78853>>>>>>>    Function DocumentStatus returns Integer
78855>>>>>>>        Function_Return (WP_GetDocumentStatus())
78856>>>>>>>    end_function
78857>>>>>>>
78857>>>>>>>    // Might still be called from report class. Leave dummy stub
78857>>>>>>>    Procedure DFZeroCounters
78859>>>>>>>    End_Procedure
78860>>>>>>>
78860>>>>>>>    //***
78860>>>>>>>    Function DFNewPage Integer Columns Returns Integer
78862>>>>>>>        Integer iPageNum
78862>>>>>>>        // This returns a page number used in report object....(this may change)
78862>>>>>>>        Move (WP_CreatePage(Columns)) To iPageNum
78863>>>>>>>        If (iPageNum=0) Begin
78865>>>>>>>            Error DFERR_WINPRINT DFPrintError900
78866>>>>>>>>
78866>>>>>>>        End
78866>>>>>>>>
78866>>>>>>>        Function_Return iPageNum
78867>>>>>>>    End_Function
78868>>>>>>>
78868>>>>>>>    //***Return handle to use for winprint dialog. If main_window
78868>>>>>>>    //   exists, use it. Else, get object's handle
78868>>>>>>>    Function Report_Window_Handle returns handle
78870>>>>>>>        Handle hWnd
78870>>>>>>>        Handle hoObj
78870>>>>>>>        Get Focus of desktop to hoObj // start with the focus
78871>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
78872>>>>>>>        function_return hWnd
78873>>>>>>>    End_Function
78874>>>>>>>
78874>>>>>>>
78874>>>>>>>    //***
78874>>>>>>>    Function DFPrintDialog Returns Boolean
78876>>>>>>>        Handle hwnd
78876>>>>>>>        Boolean bOk
78876>>>>>>>
78876>>>>>>>        Get Report_Window_Handle to hWnd
78877>>>>>>>        Move (WP_ExecutePrintDialog(hwnd)) To bOk
78878>>>>>>>
78878>>>>>>>        Function_Return bOk
78879>>>>>>>    End_Function
78880>>>>>>>
78880>>>>>>>
78880>>>>>>>    //*** You can only invoke the print setup if the report is cleared. If you try to to do this in
78880>>>>>>>    //    the wrong state you will get an error.
78880>>>>>>>    Function DFPrintSetupDialog Returns Boolean
78882>>>>>>>        Handle hwnd
78882>>>>>>>        Boolean bOk
78882>>>>>>>        Integer iStatus
78882>>>>>>>        Get ArePrintersInstalled to bOk
78883>>>>>>>        If not bOk Begin
78885>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78886>>>>>>>>
78886>>>>>>>        End
78886>>>>>>>>
78886>>>>>>>        Else Begin
78887>>>>>>>            Get DocumentStatus to iStatus
78888>>>>>>>            
78888>>>>>>>            If (iStatus=dsNotStarted) Begin
78890>>>>>>>                Get Report_Window_Handle to hWnd
78891>>>>>>>                Move (WP_ExecutePrinterSetupDialog(hwnd)) to bOk
78892>>>>>>>                
78892>>>>>>>                // test that the selected printer is valid....
78892>>>>>>>                If bOK Begin
78894>>>>>>>                    Get IsPrinterValid to bOk // if printer not valid, it's not ok
78895>>>>>>>                    If not bOk Begin
78897>>>>>>>                        Error DFERR_WINPRINT DFPrintError936  // could not select a valid printer
78898>>>>>>>>
78898>>>>>>>                    End
78898>>>>>>>>
78898>>>>>>>                End
78898>>>>>>>>
78898>>>>>>>            End
78898>>>>>>>>
78898>>>>>>>            Else Begin
78899>>>>>>>               Error DFERR_WINPRINT DFPrintError966      // cannot change printer when report is active
78900>>>>>>>>
78900>>>>>>>            End
78900>>>>>>>>
78900>>>>>>>        End
78900>>>>>>>>
78900>>>>>>>        Function_Return bOk
78901>>>>>>>    End_Function
78902>>>>>>>
78902>>>>>>>
78902>>>>>>>    //*** Provided for backwards compatibility. DFPrintSetupDialog is more flexible because it returns a
78902>>>>>>>    //    false if cancel was selected.
78902>>>>>>>    Procedure DFPrintSetup
78904>>>>>>>        Boolean bOk
78904>>>>>>>        Get DFPrintSetupDialog to bOk
78905>>>>>>>    End_Procedure
78906>>>>>>>
78906>>>>>>>    //*** This invokes the print job dialog, prints the report, then clears the report document.
78906>>>>>>>    //    This should be called after the report is complete.
78906>>>>>>>    Procedure DFPrint
78908>>>>>>>        Integer bOk
78908>>>>>>>        Get DFPrintDialog To bOk
78909>>>>>>>        If bOk Begin
78911>>>>>>>            Send DFPrintDoc
78912>>>>>>>            Send DFClearDoc
78913>>>>>>>        End
78913>>>>>>>>
78913>>>>>>>    End_Procedure
78914>>>>>>>
78914>>>>>>>    Procedure DFSuspendGui boolean bSuspend
78916>>>>>>>        If (bSuspend<>pbIsSuspended(self)) begin
78918>>>>>>>            Send SuspendGui of Desktop bSuspend
78919>>>>>>>            Set pbIsSuspended to bSuspend
78920>>>>>>>        end
78920>>>>>>>>
78920>>>>>>>    end_procedure
78921>>>>>>>
78921>>>>>>>    // this is protected so that the queue is only pumped if the
78921>>>>>>>    // gui is suspended.
78921>>>>>>>    Procedure PumpMsgQueue
78923>>>>>>>        If (pbIsSuspended(self)) begin
78925>>>>>>>            Send PumpMsgQueue of desktop // permit painting
78926>>>>>>>        end
78926>>>>>>>>
78926>>>>>>>    end_procedure
78927>>>>>>>
78927>>>>>>>
78927>>>>>>>    //*** This does a modeless preview. This is what you'd want during
78927>>>>>>>    //    report generation and it may be what you want for report viewing.
78927>>>>>>>    Procedure DFPreviewNoWait
78929>>>>>>>        Boolean bOk
78929>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78929>>>>>>>        integer iStatus
78929>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78930>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78931>>>>>>>        Get EnablePrintFromPreview to bPrint
78932>>>>>>>        Get DocumentStatus to iStatus
78933>>>>>>>        If (iStatus=dsStarted) begin
78935>>>>>>>            Send DfSuspendGui True
78936>>>>>>>        end
78936>>>>>>>>
78936>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To bOk
78937>>>>>>>        If not bOk Begin
78939>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78940>>>>>>>>
78940>>>>>>>            Send DfSuspendGui False
78941>>>>>>>        End
78941>>>>>>>>
78941>>>>>>>    End_Procedure
78942>>>>>>>
78942>>>>>>>
78942>>>>>>>    //*** This does a modal preview. You might want this for report
78942>>>>>>>    //    viewing as the program knows when the viewer is closed
78942>>>>>>>    // Note that this is a private message and it was never intended that this
78942>>>>>>>    // should be used. We expect winprint reports to use modeless viewers.
78942>>>>>>>    Procedure DFPreviewWait
78944>>>>>>>        Handle hViewerProcess
78944>>>>>>>        Boolean bPrntDlg bPrintSetup bPrint
78944>>>>>>>        Integer iRetVal
78944>>>>>>>        Integer hwMain hMain
78944>>>>>>>
78944>>>>>>>        Get PrintDlgInPreview to bPrntDlg
78945>>>>>>>        Get EnablePrintSetupFromPreview to bPrintSetup
78946>>>>>>>        Get EnablePrintFromPreview to bPrint
78947>>>>>>>
78947>>>>>>>        Send DfSuspendGui True
78948>>>>>>>        Move (WP_PreviewDocument(bPrntDlg,bPrintSetup,bPrint)) To hViewerProcess
78949>>>>>>>
78949>>>>>>>        If (hViewerProcess = 0) Begin
78951>>>>>>>            Error DFERR_WINPRINT DFPrintError901
78952>>>>>>>>
78952>>>>>>>        End
78952>>>>>>>>
78952>>>>>>>        Else Begin
78953>>>>>>>            // We need to wait for either the Viewer to close, or a WM_PAINT message in the thread's queue...
78953>>>>>>>            Repeat
78953>>>>>>>>
78953>>>>>>>               Move (MsgWaitForMultipleObjects(1, AddressOf(hViewerProcess), False, INFINITE, QS_PAINT)) To iRetVal
78954>>>>>>>               Send PumpMsgQueue // permit painting
78955>>>>>>>            Until (iRetVal = 0) // 0 means that the viewer process terminated
78957>>>>>>>        end
78957>>>>>>>>
78957>>>>>>>        Send DfSuspendGui False
78958>>>>>>>
78958>>>>>>>       // Do what we can to force VDF application to the top.
78958>>>>>>>       // As 12.0 dfSuspendGUI actually properly disables the underlying windows. When the viewer
78958>>>>>>>       // is closed it cannot give the focus back to this so it goes elsewhere. This will force it
78958>>>>>>>       // back. 
78958>>>>>>>
78958>>>>>>>       Get main_window of desktop to hMain
78959>>>>>>>       If hMain Begin
78961>>>>>>>          Get window_handle of hMain to hwMain
78962>>>>>>>          If hwMain Begin
78964>>>>>>>              If (GetForegroundWindow()<>hwMain) Begin
78966>>>>>>>                  Move (SetForegroundWindow(hwMain)) to hwMain
78967>>>>>>>              End
78967>>>>>>>>
78967>>>>>>>          End
78967>>>>>>>>
78967>>>>>>>       End
78967>>>>>>>>
78967>>>>>>>
78967>>>>>>>    End_Procedure
78968>>>>>>>
78968>>>>>>>    Procedure DfPreview
78970>>>>>>>        send DfPreviewNoWait
78971>>>>>>>    end_procedure
78972>>>>>>>
78972>>>>>>>
78972>>>>>>>    //***
78972>>>>>>>    Procedure DFPrintDoc
78974>>>>>>>        Handle hwnd
78974>>>>>>>        Boolean bOk
78974>>>>>>>        Get Report_Window_Handle to hWnd
78975>>>>>>>        Move (WP_PrintDocument(hwnd)) To bOk
78976>>>>>>>
78976>>>>>>>        If not bOk Begin
78978>>>>>>>            Error DFERR_WINPRINT DFPrintError902
78979>>>>>>>>
78979>>>>>>>        End
78979>>>>>>>>
78979>>>>>>>    End_Procedure
78980>>>>>>>
78980>>>>>>>
78980>>>>>>>    //***
78980>>>>>>>    Procedure DFClearDoc
78982>>>>>>>        Boolean bOk
78982>>>>>>>        Get ArePrintersInstalled to bOk
78983>>>>>>>        If bOk begin
78985>>>>>>>            Move (WP_ClearDocument()) To bOk
78986>>>>>>>            Send DFSuspendGUI False
78987>>>>>>>            If not bOk Begin
78989>>>>>>>               Error DFERR_WINPRINT DFPrintError903 // error number right?
78990>>>>>>>>
78990>>>>>>>            End
78990>>>>>>>>
78990>>>>>>>        End
78990>>>>>>>>
78990>>>>>>>    End_Procedure
78991>>>>>>>
78991>>>>>>>    Procedure DFNewDoc Boolean bAutoPreview
78993>>>>>>>        Boolean bOk
78993>>>>>>>        // this is the most likely place we will encounter when we start a report. Check for
78993>>>>>>>        // printers and return an explicit error to make it easy to identify the error
78993>>>>>>>        Get ArePrintersInstalled to bOk
78994>>>>>>>        If not bOk begin
78996>>>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
78997>>>>>>>>
78997>>>>>>>        end
78997>>>>>>>>
78997>>>>>>>        else begin
78998>>>>>>>            Send DfClearDoc //JJT - a new doc should always start with a clear
78999>>>>>>>            If bAutoPreview Send DFSuspendGUI True
79002>>>>>>>            Move (WP_NewDocument(bAutoPreview)) To bOk
79003>>>>>>>
79003>>>>>>>            If not bOk Begin
79005>>>>>>>               Error DFERR_WINPRINT DFPrintError902  // could not print document
79006>>>>>>>>
79006>>>>>>>               Send DFSuspendGUI False
79007>>>>>>>            End
79007>>>>>>>>
79007>>>>>>>        end
79007>>>>>>>>
79007>>>>>>>    End_Procedure
79008>>>>>>>
79008>>>>>>>    //***
79008>>>>>>>    Procedure DFSetFont String sFontName
79010>>>>>>>        boolean bOk
79010>>>>>>>        Move (WP_SetFontName(sFontName)) To bOk
79011>>>>>>>
79011>>>>>>>        If not bOK Begin
79013>>>>>>>            Error DFERR_WINPRINT DFPrintError904
79014>>>>>>>>
79014>>>>>>>        End
79014>>>>>>>>
79014>>>>>>>    End_Procedure
79015>>>>>>>
79015>>>>>>>
79015>>>>>>>    //***
79015>>>>>>>    Procedure DFSetFontSize Integer iHeight Integer iWidth
79017>>>>>>>        boolean bOk
79017>>>>>>>        // note that width is ignored in new implementation
79017>>>>>>>        Move (WP_SetFontHeight(iHeight)) To bOk
79018>>>>>>>
79018>>>>>>>        If not bOK Begin
79020>>>>>>>            Error DFERR_WINPRINT  DFPrintError905
79021>>>>>>>>
79021>>>>>>>        End
79021>>>>>>>>
79021>>>>>>>    End_Procedure
79022>>>>>>>
79022>>>>>>>
79022>>>>>>>    //***
79022>>>>>>>    Procedure DFSetFontStyle DWORD dwStyle
79024>>>>>>>        boolean bOk
79024>>>>>>>        Move (WP_SetFontStyle(dwStyle)) To bOk
79025>>>>>>>
79025>>>>>>>        If not bOK Begin
79027>>>>>>>            Error DFERR_WINPRINT DFPrintError906
79028>>>>>>>>
79028>>>>>>>        End
79028>>>>>>>>
79028>>>>>>>    End_Procedure
79029>>>>>>>
79029>>>>>>>
79029>>>>>>>    //***
79029>>>>>>>    Procedure DFSetUnderline boolean bUnderline
79031>>>>>>>        boolean bOk
79031>>>>>>>
79031>>>>>>>        Move (WP_SetFontUnderline(bUnderline)) To bOk
79032>>>>>>>
79032>>>>>>>        If not bOK Begin
79034>>>>>>>            Error DFERR_WINPRINT DFPrintError907
79035>>>>>>>>
79035>>>>>>>        End
79035>>>>>>>>
79035>>>>>>>    End_Procedure
79036>>>>>>>
79036>>>>>>>
79036>>>>>>>    //***
79036>>>>>>>    Procedure DFSetBold Boolean bBold
79038>>>>>>>        Boolean bOk
79038>>>>>>>
79038>>>>>>>        Move (WP_SetFontBold(bBold)) To bOk
79039>>>>>>>
79039>>>>>>>        If not bOK Begin
79041>>>>>>>            Error DFERR_WINPRINT DFPrintError908
79042>>>>>>>>
79042>>>>>>>        End
79042>>>>>>>>
79042>>>>>>>    End_Procedure
79043>>>>>>>
79043>>>>>>>
79043>>>>>>>    //***
79043>>>>>>>    Procedure DFSetItalic Boolean bItalic
79045>>>>>>>        Boolean bOk
79045>>>>>>>
79045>>>>>>>        Move (WP_SetFontItalic(bItalic)) To bOk
79046>>>>>>>
79046>>>>>>>        If not bOK Begin
79048>>>>>>>            Error DFERR_WINPRINT DFPrintError909
79049>>>>>>>>
79049>>>>>>>        End
79049>>>>>>>>
79049>>>>>>>    End_Procedure
79050>>>>>>>
79050>>>>>>>
79050>>>>>>>    //***
79050>>>>>>>    Procedure DFSetStrikeout Boolean bStrikeout
79052>>>>>>>        Boolean bOk
79052>>>>>>>
79052>>>>>>>        Move (WP_SetFontStrikeout(bStrikeout)) To bOk
79053>>>>>>>
79053>>>>>>>        If not bOK Begin
79055>>>>>>>            Error DFERR_WINPRINT DFPrintError910
79056>>>>>>>>
79056>>>>>>>        End
79056>>>>>>>>
79056>>>>>>>    End_Procedure
79057>>>>>>>
79057>>>>>>>
79057>>>>>>>    //***
79057>>>>>>>    Procedure DFSetMargins Number nLeft Number nTop Number nRight Number nBottom
79059>>>>>>>        Boolean bOk
79059>>>>>>>        integer iLeft iRight iTop iBottom
79059>>>>>>>
79059>>>>>>>        Move (nLeft   * 100) to iLeft
79060>>>>>>>        Move (nRight  * 100) to iRight
79061>>>>>>>        Move (nTop    * 100) to iTop
79062>>>>>>>        Move (nBottom * 100) to iBottom
79063>>>>>>>
79063>>>>>>>        Move (WP_SetMargins(iLeft,iTop,iRight,iBottom)) To bOk
79064>>>>>>>
79064>>>>>>>        If bOk Begin
79066>>>>>>>            Set DFLeft_Margin   To nLeft
79067>>>>>>>            Set DFTop_Margin    To nTop
79068>>>>>>>            Set DFRight_Margin  To nRight
79069>>>>>>>            Set DFBottom_Margin To nBottom
79070>>>>>>>        End
79070>>>>>>>>
79070>>>>>>>        Else Begin
79071>>>>>>>            Error DFERR_WINPRINT DFPrintError911
79072>>>>>>>>
79072>>>>>>>        End
79072>>>>>>>>
79072>>>>>>>    End_Procedure
79073>>>>>>>
79073>>>>>>>
79073>>>>>>>    //***
79073>>>>>>>    Procedure DFSetLeftMargin Number nLeft
79075>>>>>>>        number  nTop nRight nBottom
79075>>>>>>>        Get DFTop_Margin    To nTop
79076>>>>>>>        Get DFRight_Margin  To nRight
79077>>>>>>>        Get DFBottom_Margin To nBottom
79078>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79079>>>>>>>    End_Procedure
79080>>>>>>>
79080>>>>>>>
79080>>>>>>>    //***
79080>>>>>>>    Procedure DFSetRightMargin Number nRight
79082>>>>>>>        number  nLeft nTop nBottom
79082>>>>>>>        Get DFLeft_Margin   To nLeft
79083>>>>>>>        Get DFTop_Margin    To nTop
79084>>>>>>>        Get DFBottom_Margin To nBottom
79085>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79086>>>>>>>    End_Procedure
79087>>>>>>>
79087>>>>>>>
79087>>>>>>>    //***
79087>>>>>>>    Procedure DFSetTopMargin Number nTop
79089>>>>>>>        number  nLeft nRight nBottom
79089>>>>>>>        Get DFLeft_Margin   To nLeft
79090>>>>>>>        Get DFRight_Margin  To nRight
79091>>>>>>>        Get DFBottom_Margin To nBottom
79092>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79093>>>>>>>    End_Procedure
79094>>>>>>>
79094>>>>>>>
79094>>>>>>>    //***
79094>>>>>>>    Procedure DFSetBottomMargin Number nBottom
79096>>>>>>>        number  nLeft nTop nRight
79096>>>>>>>        Get DFLeft_Margin   To nLeft
79097>>>>>>>        Get DFTop_Margin    To nTop
79098>>>>>>>        Get DFRight_Margin  To nRight
79099>>>>>>>        Send DFSetMargins nLeft nTop nRight nBottom
79100>>>>>>>    End_Procedure
79101>>>>>>>
79101>>>>>>>
79101>>>>>>>    //***
79101>>>>>>>    Procedure DFWriteText String sText Integer iStyle Integer iColumn Integer iDecimal Boolean bNewLineAfterPrint
79103>>>>>>>        Boolean bOk
79103>>>>>>>
79103>>>>>>>        Send DFSetFontStyle iStyle
79104>>>>>>>        Get ToAnsi sText To sText
79105>>>>>>>        Move (WP_WriteText(sText,bNewLineAfterPrint,iColumn,iDecimal,0)) To bOk
79106>>>>>>>        If not bOk Begin
79108>>>>>>>            Error DFERR_WINPRINT DFPrintError918
79109>>>>>>>>
79109>>>>>>>        End
79109>>>>>>>>
79109>>>>>>>        Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79110>>>>>>>    End_Procedure
79111>>>>>>>
79111>>>>>>>    //***
79111>>>>>>>    Procedure DFWrite String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79113>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79115>>>>>>>            Move (Rtrim(sText)) to sText
79116>>>>>>>        end
79116>>>>>>>>
79116>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal False
79117>>>>>>>    End_Procedure
79118>>>>>>>
79118>>>>>>>    //***
79118>>>>>>>    Procedure DFWriteLn String sText DWORD iStyle Integer iColumn Integer iDecimal Boolean bTrim
79120>>>>>>>        If (Num_Arguments>=5 and bTrim) Begin
79122>>>>>>>            Move (Rtrim(sText)) to sText
79123>>>>>>>        end
79123>>>>>>>>
79123>>>>>>>        Send DFWriteText sText iStyle iColumn iDecimal True
79124>>>>>>>    End_Procedure
79125>>>>>>>
79125>>>>>>>
79125>>>>>>>    //***
79125>>>>>>>    Procedure DFWriteTextAtPosition String sText integer iStyle Number nPosition Integer iDecimal ;                                    Number nMaxLength Boolean bNewLineAfterPrint
79127>>>>>>>        Boolean bOk
79127>>>>>>>        Integer iPosition iMaxLength
79127>>>>>>>        Send DFSetFontStyle iStyle
79128>>>>>>>        Get ToAnsi sText To sText
79129>>>>>>>        Move (nPosition * 100) to iPosition
79130>>>>>>>        Move (nMaxLength * 100) to iMaxLength
79131>>>>>>>        Move (WP_WriteTextAtPosition(sText,bNewLineAfterPrint,iPosition,iDecimal,iMaxLength)) To bOk
79132>>>>>>>        If not bOk Begin
79134>>>>>>>            Error DFERR_WINPRINT DFPrintError922
79135>>>>>>>>
79135>>>>>>>        End
79135>>>>>>>>
79135>>>>>>>         Send PumpMsgQueue // permit painting //JJT!!!!!!!!!!!
79136>>>>>>>    End_Procedure
79137>>>>>>>
79137>>>>>>>    //***
79137>>>>>>>    Procedure DFWritePos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79139>>>>>>>        Number nMax
79139>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79141>>>>>>>            Move (Rtrim(sText)) to sText
79142>>>>>>>        end
79142>>>>>>>>
79142>>>>>>>
79142>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79145>>>>>>>        Else ;            Move nMaxLength to nMax
79147>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax False
79148>>>>>>>    End_Procedure
79149>>>>>>>
79149>>>>>>>    //***
79149>>>>>>>    Procedure DFWriteLnPos String sText integer iStyle Number nPosition Integer iDecimal Number nMaxLength boolean bTrim
79151>>>>>>>        Number nMax
79151>>>>>>>        If (Num_Arguments>=6 and bTrim) Begin
79153>>>>>>>            Move (Rtrim(sText)) to sText
79154>>>>>>>        end
79154>>>>>>>>
79154>>>>>>>
79154>>>>>>>        If (Num_Arguments<5) ;            Move 0 to nMax
79157>>>>>>>        Else ;            Move nMaxLength to nMax
79159>>>>>>>        Send DFWriteTextAtPosition sText iStyle nPosition iDecimal nMax True
79160>>>>>>>    End_Procedure
79161>>>>>>>
79161>>>>>>>    Procedure DFSetMetrics String sMetrics
79163>>>>>>>        integer eMetrics
79163>>>>>>>        // for backwards compatibility support both string names and integer enumerations
79163>>>>>>>        // it is better to use the enumeration value
79163>>>>>>>        If (sMetrics="INCH" or sMetrics="CM") Begin
79165>>>>>>>            Set DFCurrent_Metrics to sMetrics
79166>>>>>>>        end
79166>>>>>>>>
79166>>>>>>>        else Begin
79167>>>>>>>            Move sMetrics to eMetrics
79168>>>>>>>            Move (WP_SetMetrics(eMetrics)) To eMetrics
79169>>>>>>>        End
79169>>>>>>>>
79169>>>>>>>    End_Procedure
79170>>>>>>>
79170>>>>>>>    Function DFGetMetrics Returns Integer
79172>>>>>>>        Integer eMetrics
79172>>>>>>>        Move (WP_GetMetrics()) To eMetrics
79173>>>>>>>        Function_return eMetrics
79174>>>>>>>    End_Function
79175>>>>>>>
79175>>>>>>>
79175>>>>>>>    //**** Properties Maintained for compatibility with old Winprint (obsolete)
79175>>>>>>>    Function DFCurrent_Metrics returns string
79177>>>>>>>        Integer eMetrics
79177>>>>>>>        Get DFGetMetrics to eMetrics
79178>>>>>>>        Function_return (if(eMetrics=WPM_INCH,"INCH","CM"))
79179>>>>>>>    end_function
79180>>>>>>>
79180>>>>>>>    Procedure Set DFCurrent_Metrics string sCMorINCH
79182>>>>>>>        Send DFSetMetrics (if(sCMorINCH="INCH", WPM_INCH, WPM_CM))
79183>>>>>>>    End_Procedure
79184>>>>>>>
79184>>>>>>>
79184>>>>>>>
79184>>>>>>>
79184>>>>>>>
79184>>>>>>>    //***
79184>>>>>>>    Procedure DFBeginHeaderType Integer iHeaderNr Integer eHeaderType
79186>>>>>>>        Boolean bOk
79186>>>>>>>
79186>>>>>>>        If (eHeaderType=DFSubHeader or eHeaderType=DFSubTotal) Begin
79188>>>>>>>            //*** Do nothing for the moment
79188>>>>>>>        End
79188>>>>>>>>
79188>>>>>>>        Else ;            Move 0 to iHeaderNr // If the user made a mistake
79190>>>>>>>
79190>>>>>>>        Set DFCurrent_HeaderType To eHeaderType
79191>>>>>>>        Set DFCurrent_HeaderNr   To iHeaderNr
79192>>>>>>>
79192>>>>>>>        Move (WP_BeginHeader(eHeaderType, iHeaderNr)) To bOk
79193>>>>>>>
79193>>>>>>>        If not bOk Begin
79195>>>>>>>            Error DFERR_WINPRINT DFPrintError925
79196>>>>>>>>
79196>>>>>>>        End
79196>>>>>>>>
79196>>>>>>>    End_Procedure
79197>>>>>>>
79197>>>>>>>
79197>>>>>>>    //***
79197>>>>>>>    Procedure DFEndHeaderType
79199>>>>>>>        Boolean bOk
79199>>>>>>>
79199>>>>>>>        Move (WP_EndHeader()) To bOk
79200>>>>>>>
79200>>>>>>>        if not bOk begin
79202>>>>>>>            Error DFERR_WINPRINT DFPrintError926
79203>>>>>>>>
79203>>>>>>>        End
79203>>>>>>>>
79203>>>>>>>    End_Procedure
79204>>>>>>>
79204>>>>>>>
79204>>>>>>>    //***
79204>>>>>>>    Procedure DFWriteHeaderType Integer iHeaderNr Integer eHeaderType
79206>>>>>>>        Boolean bOk
79206>>>>>>>        Move (WP_WriteHeader(eHeaderType, iHeaderNr)) To bOk
79207>>>>>>>        if not bOk begin
79209>>>>>>>            Error DFERR_WINPRINT DFPrintError927
79210>>>>>>>>
79210>>>>>>>        End
79210>>>>>>>>
79210>>>>>>>    End_Procedure
79211>>>>>>>
79211>>>>>>>
79211>>>>>>>    //***
79211>>>>>>>    Procedure DFHeaderPosition Integer ePlace
79213>>>>>>>        Boolean bOk
79213>>>>>>>
79213>>>>>>>         Move (WP_SetHeaderPlacement(ePlace)) To bOk
79214>>>>>>>
79214>>>>>>>         if not bOk begin
79216>>>>>>>            Error DFERR_WINPRINT DFPrintError929
79217>>>>>>>>
79217>>>>>>>        End
79217>>>>>>>>
79217>>>>>>>    End_Procedure
79218>>>>>>>
79218>>>>>>>
79218>>>>>>>    //***
79218>>>>>>>    Procedure DFHeaderFrameType Integer eFrame integer iColor Number nWeight;                                Integer iFillColor Boolean bFillFrame
79220>>>>>>>        Integer iWeight
79220>>>>>>>        Boolean bOk
79220>>>>>>>
79220>>>>>>>        move (nWeight*100) To iWeight
79221>>>>>>>
79221>>>>>>>        Move (WP_SetHeaderFrame(eFrame,iColor,iWeight,iFillColor,bFillFrame)) To bOk
79222>>>>>>>
79222>>>>>>>         if not bOk begin
79224>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79225>>>>>>>>
79225>>>>>>>        End
79225>>>>>>>>
79225>>>>>>>    End_Procedure
79226>>>>>>>
79226>>>>>>>  Procedure DFHeaderMargin Integer eType Number nSize
79228>>>>>>>        Boolean bOk
79228>>>>>>>        Integer iSize
79228>>>>>>>
79228>>>>>>>        move (nSize * 100) to iSize
79229>>>>>>>
79229>>>>>>>        move (WP_SetHeaderMargin(eType, iSize)) To bOk
79230>>>>>>>
79230>>>>>>>        if not bOk begin
79232>>>>>>>            Error DFERR_WINPRINT DFPrintError930
79233>>>>>>>>
79233>>>>>>>        end
79233>>>>>>>>
79233>>>>>>>    End_Procedure
79234>>>>>>>
79234>>>>>>>
79234>>>>>>>    //***
79234>>>>>>>    Procedure DFHeaderWrap Integer eOnOff
79236>>>>>>>         Boolean bOk
79236>>>>>>>
79236>>>>>>>         Move (WP_SetHeaderWrap(eOnOff)) To bOk
79237>>>>>>>
79237>>>>>>>         if not bOk begin
79239>>>>>>>            Error DFERR_WINPRINT DFPrintError931
79240>>>>>>>>
79240>>>>>>>        End
79240>>>>>>>>
79240>>>>>>>    End_Procedure
79241>>>>>>>
79241>>>>>>>    //***
79241>>>>>>>    Procedure DFWriteBMP String sFileName Number nStartX Number nStartY Number nHeight Number nWidth Boolean bUCp
79243>>>>>>>        Boolean bOk
79243>>>>>>>        Integer iStartX iStartY iHeight iWidth
79243>>>>>>>
79243>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX to iStartX
79246>>>>>>>        else ;            move (nStartX*100) To iStartX
79248>>>>>>>
79248>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY to iStartY
79251>>>>>>>        else ;            move (nStartY*100) To iStartY
79253>>>>>>>
79253>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79256>>>>>>>        else ;            move (nWidth*100) To iWidth
79258>>>>>>>
79258>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79261>>>>>>>        else ;            move (nHeight*100) To iHeight
79263>>>>>>>
79263>>>>>>>        Get_File_Path sFileName To sFileName
79264>>>>>>>        Move (WP_DrawBitmap(sFileName,iStartX,iStartY,iWidth,iHeight,bUCp)) to bOk
79265>>>>>>>
79265>>>>>>>        If not bOk Begin
79267>>>>>>>            Error DFERR_WINPRINT DFPrintError932
79268>>>>>>>>
79268>>>>>>>        End
79268>>>>>>>>
79268>>>>>>>    End_Procedure
79269>>>>>>>
79269>>>>>>>
79269>>>>>>>    //***
79269>>>>>>>    Procedure DFHeaderLineCheck Integer iLines
79271>>>>>>>        Boolean bOk
79271>>>>>>>
79271>>>>>>>         Move (WP_SetExtraLineCheck(iLines)) To bOk
79272>>>>>>>
79272>>>>>>>        If not bOk begin
79274>>>>>>>            Error DFERR_WINPRINT DFPrintError934
79275>>>>>>>>
79275>>>>>>>        End
79275>>>>>>>>
79275>>>>>>>    End_Procedure
79276>>>>>>>
79276>>>>>>>
79276>>>>>>>    //***
79276>>>>>>>    Procedure DFPrintFlags Integer Flags
79278>>>>>>>        Boolean bOk
79278>>>>>>>
79278>>>>>>>         Move (WP_SetPrintDialogFlags(Flags)) To bOk
79279>>>>>>>
79279>>>>>>>        If not bOk begin
79281>>>>>>>            Error DFERR_WINPRINT DFPrintError935
79282>>>>>>>>
79282>>>>>>>        End
79282>>>>>>>>
79282>>>>>>>    End_Procedure
79283>>>>>>>
79283>>>>>>>
79283>>>>>>>    //*** obsolete and maintained for winprint-I backwards compatibility (maybe should be removed)
79283>>>>>>>    //
79283>>>>>>>    Procedure DFSelectPrinter String sDriver String sDevice String sPort Boolean bUpdate
79285>>>>>>>        Send DFSetDevice sDevice
79286>>>>>>>    End_Procedure
79287>>>>>>>
79287>>>>>>>    //*** Preferred usage for WinprintII
79287>>>>>>>    Procedure DFSetDevice String sDevice
79289>>>>>>>        Boolean bOk
79289>>>>>>>
79289>>>>>>>        Move (WP_SelectPrinter(sDevice)) To bOk
79290>>>>>>>
79290>>>>>>>        If not bOk Begin
79292>>>>>>>            Error DFERR_WINPRINT DFPrintError936
79293>>>>>>>>
79293>>>>>>>        End
79293>>>>>>>>
79293>>>>>>>    End_Procedure
79294>>>>>>>
79294>>>>>>>    Procedure DFPrinterBinFirstPage Integer eBin
79296>>>>>>>        Boolean bOk
79296>>>>>>>
79296>>>>>>>         Move (WP_SetFirstPagePaperSource(eBin)) To bOk
79297>>>>>>>
79297>>>>>>>        If not bOk Begin
79299>>>>>>>            Error DFERR_WINPRINT DFPrintError937
79300>>>>>>>>
79300>>>>>>>        End
79300>>>>>>>>
79300>>>>>>>    End_Procedure
79301>>>>>>>
79301>>>>>>>
79301>>>>>>>    //***
79301>>>>>>>    Function DFGetDFColor Integer iRed Integer iGreen Integer iBlue Returns Integer
79303>>>>>>>        Integer iColor
79303>>>>>>>
79303>>>>>>>         Move (WP_RGBToDFPrintColor(iRed,iGreen,iBlue)) To iColor
79304>>>>>>>
79304>>>>>>>        If (iColor=0) Begin
79306>>>>>>>            Error DFERR_WINPRINT DFPrintError938
79307>>>>>>>>
79307>>>>>>>        End
79307>>>>>>>>
79307>>>>>>>        Function_Return iColor
79308>>>>>>>    End_Function
79309>>>>>>>
79309>>>>>>>
79309>>>>>>>    //***
79309>>>>>>>    Procedure DFSetDFColor Dword dwColor
79311>>>>>>>        Integer bOk
79311>>>>>>>
79311>>>>>>>         Move (WP_SetFontColor(dwColor)) To bOk
79312>>>>>>>
79312>>>>>>>        If not bOk Begin
79314>>>>>>>            Error DFERR_WINPRINT DFPrintError939
79315>>>>>>>>
79315>>>>>>>        End
79315>>>>>>>>
79315>>>>>>>    End_Procedure
79316>>>>>>>
79316>>>>>>>
79316>>>>>>>    //***
79316>>>>>>>    Procedure DFSetTopBottom Number nTop Number nBottom Boolean bAllPages
79318>>>>>>>        Boolean bOk
79318>>>>>>>        Integer iTop iBottom
79318>>>>>>>
79318>>>>>>>        move (nTop*100)    To iTop
79319>>>>>>>        move (nBottom*100) To iBottom
79320>>>>>>>
79320>>>>>>>        Move (WP_SetAbsoluteMargins(iTop,iBottom,bAllPages)) To bOk
79321>>>>>>>
79321>>>>>>>        If Not bOk Begin
79323>>>>>>>            Error DFERR_WINPRINT DFPrintError940
79324>>>>>>>>
79324>>>>>>>        End
79324>>>>>>>>
79324>>>>>>>    End_Procedure
79325>>>>>>>
79325>>>>>>>
79325>>>>>>>    //***
79325>>>>>>>    Procedure DFSetJMode Integer eAlign
79327>>>>>>>        Boolean bOk
79327>>>>>>>
79327>>>>>>>        Move (WP_SetAlign(eAlign)) To bOk
79328>>>>>>>
79328>>>>>>>        If Not bOk Begin
79330>>>>>>>            Error DFERR_WINPRINT DFPrintError941
79331>>>>>>>>
79331>>>>>>>        End
79331>>>>>>>>
79331>>>>>>>    End_Procedure
79332>>>>>>>
79332>>>>>>>
79332>>>>>>>    //***
79332>>>>>>>    Procedure DFWriteEllip Number nStartX Number nStartY Number nHeight Number nWidth ;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79334>>>>>>>
79334>>>>>>>        Boolean bOk
79334>>>>>>>        Integer iWeight
79334>>>>>>>        Integer iStartX iStartY iHeight iWidth
79334>>>>>>>
79334>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79337>>>>>>>        else ;            move (nStartX*100) To iStartX
79339>>>>>>>
79339>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79342>>>>>>>        else ;            move (nStartY*100) To iStartY
79344>>>>>>>
79344>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79347>>>>>>>        else ;            move (nWidth*100) To iWidth
79349>>>>>>>
79349>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79352>>>>>>>        else ;            move (nHeight*100) To iHeight
79354>>>>>>>
79354>>>>>>>        move (nWeight*100) To iWeight
79355>>>>>>>
79355>>>>>>>
79355>>>>>>>        Move (WP_DrawEllipse(iStartX,iStartY,iWidth,iHeight,;                        dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79356>>>>>>>
79356>>>>>>>        If Not bOk Begin
79358>>>>>>>            Error DFERR_WINPRINT DFPrintError942
79359>>>>>>>>
79359>>>>>>>        End
79359>>>>>>>>
79359>>>>>>>    End_Procedure
79360>>>>>>>
79360>>>>>>>
79360>>>>>>>
79360>>>>>>>
79360>>>>>>>    //***
79360>>>>>>>    Procedure DFWriteRect Number nStartX Number nStartY Number nHeight Number nWidth;              Dword dwBColor Dword dwFColor Boolean bFill Number nWeight Boolean bWrap Boolean bUCp
79362>>>>>>>
79362>>>>>>>        Boolean bOk
79362>>>>>>>        Integer iWeight
79362>>>>>>>        Integer iStartX iStartY iHeight iWidth
79362>>>>>>>
79362>>>>>>>        If ((nStartX = -998) or (nStartX = -999));            move nStartX To iStartX
79365>>>>>>>        else ;            move (nStartX*100) To iStartX
79367>>>>>>>
79367>>>>>>>        If ((nStartY = -998) or (nStartY = -999));            move nStartY To iStartY
79370>>>>>>>        else ;            move (nStartY*100) To iStartY
79372>>>>>>>
79372>>>>>>>        If ((nWidth = -998) or (nWidth = -999));            move nWidth To iWidth
79375>>>>>>>        else ;            move (nWidth*100) To iWidth
79377>>>>>>>
79377>>>>>>>        If ((nHeight = -998) or (nHeight = -999));            move nHeight To iHeight
79380>>>>>>>        else ;            move (nHeight*100) To iHeight
79382>>>>>>>
79382>>>>>>>        move (nWeight*100) To iWeight
79383>>>>>>>
79383>>>>>>>        Move (WP_DrawRectangle(iStartX,iStartY,iWidth,iHeight,;                            dwBColor,dwFColor,bFill,iWeight,bUCp,bWrap)) To bOk
79384>>>>>>>
79384>>>>>>>        If Not bOk Begin
79386>>>>>>>            Error DFERR_WINPRINT DFPrintError944
79387>>>>>>>>
79387>>>>>>>        End
79387>>>>>>>>
79387>>>>>>>    End_Procedure
79388>>>>>>>
79388>>>>>>>
79388>>>>>>>
79388>>>>>>>
79388>>>>>>>    //***
79388>>>>>>>    Procedure DFLineCheck Integer iLines
79390>>>>>>>        Boolean bOk
79390>>>>>>>
79390>>>>>>>        Move (WP_ConfirmLines(iLines)) To bOk
79391>>>>>>>
79391>>>>>>>        If Not bOk Begin
79393>>>>>>>            Error DFERR_WINPRINT DFPrintError946
79394>>>>>>>>
79394>>>>>>>        End
79394>>>>>>>>
79394>>>>>>>    End_Procedure
79395>>>>>>>
79395>>>>>>>
79395>>>>>>>    //***
79395>>>>>>>    Procedure DFCreateDiagram Integer eType Integer eFx Number nHeight Number nWidth Integer bXyAxis
79397>>>>>>>        Handle hDiagram
79397>>>>>>>        Integer iWidth iHeight
79397>>>>>>>
79397>>>>>>>        move (nHeight*100) To iHeight
79398>>>>>>>        move (nWidth*100)  To iWidth
79399>>>>>>>
79399>>>>>>>        Set DFCurrent_Color To 0
79400>>>>>>>
79400>>>>>>>        Move (WP_CreateDiagram(eType,eFx,iWidth,iHeight,bXyAxis)) To hDiagram
79401>>>>>>>
79401>>>>>>>        If (hDiagram) Begin
79403>>>>>>>            Error DFERR_WINPRINT DFPrintError947
79404>>>>>>>>
79404>>>>>>>        End
79404>>>>>>>>
79404>>>>>>>        Else Begin
79405>>>>>>>            Set DFCurrent_Diagram To hDiagram
79406>>>>>>>        end
79406>>>>>>>>
79406>>>>>>>    End_Procedure
79407>>>>>>>
79407>>>>>>>
79407>>>>>>>    //***
79407>>>>>>>    Procedure DFDiagram_Item handle hDiagram String sLabel Number nValue;                             Dword dwBColor Dword dwFColor Integer eFill;                             Integer iDec Integer eValueOrPercent Integer eExt
79409>>>>>>>
79409>>>>>>>        Boolean bOk
79409>>>>>>>        Integer iCurrColor iValue
79409>>>>>>>
79409>>>>>>>        If (dwFColor = -1) Begin
79411>>>>>>>            Get DFCurrent_Color To iCurrColor
79412>>>>>>>            Increment iCurrColor
79413>>>>>>>            If (iCurrColor>15) Move 1 To iCurrColor
79416>>>>>>>            Set DFCurrent_Color To iCurrColor
79417>>>>>>>            Get DFGetColor iCurrColor To dwFColor
79418>>>>>>>        End
79418>>>>>>>>
79418>>>>>>>
79418>>>>>>>        Move (nValue *100) to iValue
79419>>>>>>>
79419>>>>>>>        Get ToAnsi sLabel To sLabel
79420>>>>>>>
79420>>>>>>>        Move (WP_AddDiagramEntry(hDiagram,sLabel,iValue,dwBColor,dwFColor,eFill,iDec,eValueorPercent,eExt)) To bOk
79421>>>>>>>
79421>>>>>>>        If not bOk Begin
79423>>>>>>>            Error DFERR_WINPRINT DFPrintError948
79424>>>>>>>>
79424>>>>>>>        End
79424>>>>>>>>
79424>>>>>>>    End_Procedure
79425>>>>>>>
79425>>>>>>>
79425>>>>>>>    //***
79425>>>>>>>    Procedure DFLockDiagram Handle hDiagram
79427>>>>>>>        Boolean bOk
79427>>>>>>>
79427>>>>>>>        Move (WP_LockDiagram(hDiagram)) To bOk
79428>>>>>>>
79428>>>>>>>        If not bOk Begin
79430>>>>>>>            Error DFERR_WINPRINT DFPrintError949
79431>>>>>>>>
79431>>>>>>>        End
79431>>>>>>>>
79431>>>>>>>    End_Procedure
79432>>>>>>>
79432>>>>>>>
79432>>>>>>>
79432>>>>>>>    //***
79432>>>>>>>    Procedure DFDrawDiagram Handle hDiagram Number nYPos Number nXPos Boolean bUCp
79434>>>>>>>        Boolean bOk
79434>>>>>>>        Integer iXPos
79434>>>>>>>        Integer iYPos
79434>>>>>>>
79434>>>>>>>        move (nXPos*100) To iXPos
79435>>>>>>>        move (nYPos*100) To iYPos
79436>>>>>>>
79436>>>>>>>        If nYPos Eq -999 Move -999 To iYPos
79439>>>>>>>
79439>>>>>>>        Move (WP_DrawDiagram(hDiagram,iXPos,iYPos,bUCp)) To bOk
79440>>>>>>>
79440>>>>>>>        If not bOk Begin
79442>>>>>>>            Error DFERR_WINPRINT DFPrintError950
79443>>>>>>>>
79443>>>>>>>        End
79443>>>>>>>>
79443>>>>>>>    End_Procedure
79444>>>>>>>
79444>>>>>>>
79444>>>>>>>
79444>>>>>>>    //***
79444>>>>>>>    Procedure DFDiagramLabel handle hDiagram String sLabel
79446>>>>>>>        Boolean bOk
79446>>>>>>>        Integer iLabelLen
79446>>>>>>>
79446>>>>>>>        Get ToAnsi sLabel To sLabel
79447>>>>>>>
79447>>>>>>>        Move (WP_SetDiagramCaption(hDiagram,sLabel)) To bOk
79448>>>>>>>
79448>>>>>>>        if not bOk Begin
79450>>>>>>>            Error DFERR_WINPRINT DFPrintError952
79451>>>>>>>>
79451>>>>>>>        End
79451>>>>>>>>
79451>>>>>>>    End_Procedure
79452>>>>>>>
79452>>>>>>>
79452>>>>>>>    //***
79452>>>>>>>    Procedure DFDiagramXLabel handle hDiagram String sLabel
79454>>>>>>>        Boolean bOk
79454>>>>>>>        Get ToAnsi sLabel To sLabel
79455>>>>>>>
79455>>>>>>>        Move (WP_SetDiagramXText(hDiagram,sLabel)) To bOk
79456>>>>>>>
79456>>>>>>>        if not bOk Begin
79458>>>>>>>            Error DFERR_WINPRINT DFPrintError953
79459>>>>>>>>
79459>>>>>>>        End
79459>>>>>>>>
79459>>>>>>>    End_Procedure
79460>>>>>>>
79460>>>>>>>
79460>>>>>>>    //***
79460>>>>>>>    Procedure DFDiagramYLabel handle hDiagram String sLabel Boolean bVertical
79462>>>>>>>        Boolean bOk
79462>>>>>>>        Get ToAnsi sLabel To sLabel
79463>>>>>>>
79463>>>>>>>        Move (WP_SetDiagramYText(hDiagram,sLabel,bVertical)) To bOk
79464>>>>>>>
79464>>>>>>>        if not bOk Begin
79466>>>>>>>            Error DFERR_WINPRINT DFPrintError954
79467>>>>>>>>
79467>>>>>>>        End
79467>>>>>>>>
79467>>>>>>>    End_Procedure
79468>>>>>>>
79468>>>>>>>
79468>>>>>>>    //***
79468>>>>>>>    Procedure DFWriteXYLine Number nStartX Number nStartY Number nStopX Number nStopY;              Dword dwColor Number nWeight Boolean bWrap Boolean bUCp
79470>>>>>>>
79470>>>>>>>        Boolean bOk
79470>>>>>>>        Integer iStartX iStartY iStopX iStopY
79470>>>>>>>        Integer iWeight
79470>>>>>>>
79470>>>>>>>        move (nStartX*100)  To iStartX
79471>>>>>>>        move (nStartY*100)  To iStartY
79472>>>>>>>        move (nStopX*100)   To iStopX
79473>>>>>>>        move (nStopY*100)   To iStopY
79474>>>>>>>
79474>>>>>>>        move (nWeight*100) To iWeight
79475>>>>>>>
79475>>>>>>>        If (nStopY  = -998) Move -998 To iStopY
79478>>>>>>>        If (nStopX  = -998) Move -998 To iStopX
79481>>>>>>>
79481>>>>>>>        If (nStartY  = -999) Move -999 To iStartY
79484>>>>>>>        If (nStartX  = -999) Move -999 To iStartX
79487>>>>>>>
79487>>>>>>>        Move (WP_DrawXYLine(iStartX,iStartY,iStopX,iStopY,dwColor,iWeight,bUCp,bWrap)) To bOk
79488>>>>>>>
79488>>>>>>>        if not bOk Begin
79490>>>>>>>            Error DFERR_WINPRINT DFPrintError955
79491>>>>>>>>
79491>>>>>>>        End
79491>>>>>>>>
79491>>>>>>>    End_Procedure
79492>>>>>>>
79492>>>>>>>
79492>>>>>>>    //***
79492>>>>>>>    Procedure DFWriteLine Number nStartX Number nStartY Number nLength;                          Boolean bHorizontal Dword dwColor Number nWeight Boolean bUCp
79494>>>>>>>
79494>>>>>>>        Boolean bOk
79494>>>>>>>        Integer iStartX iStartY iLength
79494>>>>>>>        Integer iWeight
79494>>>>>>>
79494>>>>>>>        move (nStartX*100)  To iStartX
79495>>>>>>>        move (nStartY*100)  To iStartY
79496>>>>>>>        move (nLength*100)  To iLength
79497>>>>>>>        move (nWeight*100)  To iWeight
79498>>>>>>>
79498>>>>>>>        If (nStartY = -999) Move -999 To iStartY
79501>>>>>>>        If (nStartX = -999) Move -999 To iStartX
79504>>>>>>>        If (nLength = -998) Move -998 To iLength
79507>>>>>>>
79507>>>>>>>        Move (WP_DrawLine(iSTartX,iStartY,iLength,bHorizontal,dwColor,iWeight,bUCp)) To bOk
79508>>>>>>>
79508>>>>>>>        if not bOk Begin
79510>>>>>>>            Error DFERR_WINPRINT DFPrintError956
79511>>>>>>>>
79511>>>>>>>        End
79511>>>>>>>>
79511>>>>>>>    End_Procedure
79512>>>>>>>
79512>>>>>>>
79512>>>>>>>    //***
79512>>>>>>>    Procedure DFClearPrinter
79514>>>>>>>        Boolean bOk
79514>>>>>>>
79514>>>>>>>        Move (WP_ClearPrinter()) To bOk
79515>>>>>>>
79515>>>>>>>        If not bOk Begin
79517>>>>>>>            Error DFERR_WINPRINT DFPrintError957
79518>>>>>>>>
79518>>>>>>>        End
79518>>>>>>>>
79518>>>>>>>    End_Procedure
79519>>>>>>>
79519>>>>>>>
79519>>>>>>>
79519>>>>>>>    //***
79519>>>>>>>     Function DFGetCurrentDevice Returns String
79521>>>>>>>        Boolean bOk
79521>>>>>>>        String  sDFStr
79521>>>>>>>        Address pDFStr
79521>>>>>>>
79521>>>>>>>        Move (Repeat( Character(0), 255 )) to sDFStr
79522>>>>>>>        GetAddress of sDFStr to pDFStr
79523>>>>>>>
79523>>>>>>>        Move (WP_GetCurrentDevice(pDFStr)) To bOk
79524>>>>>>>
79524>>>>>>>        If not bOk Begin
79526>>>>>>>            Error DFERR_WINPRINT DFPrintError959
79527>>>>>>>>
79527>>>>>>>        End
79527>>>>>>>>
79527>>>>>>>
79527>>>>>>>        Move (CString(sDFStr)) To sDFStr
79528>>>>>>>        Function_Return sDFStr
79529>>>>>>>     End_Function
79530>>>>>>>
79530>>>>>>>
79530>>>>>>>    // Note: DfGetCurrentPort and DFGetCurrentDriver do not exist in winprint2. Trying to
79530>>>>>>>    //       use these will result in a runtime error (which is good - don't use them)
79530>>>>>>>
79530>>>>>>>
79530>>>>>>>    //***
79530>>>>>>>     Function DFGetPrintDialogFlags Returns Dword
79532>>>>>>>        Dword dwRetVal
79532>>>>>>>
79532>>>>>>>        Move (WP_GetPrintDialogFlags()) To dwRetVal
79533>>>>>>>
79533>>>>>>>        Function_Return dwRetVal
79534>>>>>>>     End_Function
79535>>>>>>>
79535>>>>>>>
79535>>>>>>>    //***
79535>>>>>>>    //*** Returns PRN_TRUE=  if the flag is set     (1)
79535>>>>>>>    //*** Returns PRN_FALSE= If the flag not is set (0)
79535>>>>>>>    //***
79535>>>>>>>     Function DFCheckPrintDialogFlag Dword dwPDFlag Returns Boolean
79537>>>>>>>        Boolean bIsSet
79537>>>>>>>
79537>>>>>>>        Move (WP_IsPrintDialogFlagSet(dwPDFlag)) To bIsSet
79538>>>>>>>
79538>>>>>>>        Function_Return bIsSet
79539>>>>>>>     End_Function
79540>>>>>>>
79540>>>>>>>
79540>>>>>>>    //***
79540>>>>>>>     Procedure DFSetSpecPrintFlag Dword dwPDFlag
79542>>>>>>>        Boolean bOk
79542>>>>>>>
79542>>>>>>>        Move (WP_SetSpecificPrintDialogFlag(dwPDFlag)) To bOk
79543>>>>>>>
79543>>>>>>>        If not bOk Begin
79545>>>>>>>            Error DFERR_WINPRINT DFPrintError961
79546>>>>>>>>
79546>>>>>>>        End
79546>>>>>>>>
79546>>>>>>>     End_Procedure
79547>>>>>>>
79547>>>>>>>
79547>>>>>>>    //***
79547>>>>>>>     Function DFGetUserDefinedLength Returns Number
79549>>>>>>>        Integer iRetVal
79549>>>>>>>        Number  nRetVal
79549>>>>>>>
79549>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79550>>>>>>>
79550>>>>>>>        If (iRetVal=0) Begin
79552>>>>>>>            Error DFERR_WINPRINT DFPrintError962
79553>>>>>>>>
79553>>>>>>>            Function_Return 0
79554>>>>>>>        End
79554>>>>>>>>
79554>>>>>>>
79554>>>>>>>        Move (Hi(iRetVal)) To nRetVal
79555>>>>>>>        move (nRetVal/100) To nRetVal //Returns CM
79556>>>>>>>
79556>>>>>>>        Function_Return nRetVal
79557>>>>>>>     End_Function
79558>>>>>>>
79558>>>>>>>
79558>>>>>>>    //***
79558>>>>>>>     Function DFGetUserDefinedWidth Returns Number
79560>>>>>>>        Integer iRetVal
79560>>>>>>>        Number  nRetVal
79560>>>>>>>
79560>>>>>>>        Move (WP_GetUserDefinedPapersize()) To iRetVal
79561>>>>>>>
79561>>>>>>>        If (iRetVal=0) Begin
79563>>>>>>>            Error DFERR_WINPRINT DFPrintError963
79564>>>>>>>>
79564>>>>>>>            Function_Return 0
79565>>>>>>>        End
79565>>>>>>>>
79565>>>>>>>
79565>>>>>>>        Move (Low(iRetVal)) To nRetVal
79566>>>>>>>        Move (nRetVal/100) To nRetVal //Returns CM
79567>>>>>>>
79567>>>>>>>        Function_Return nRetVal
79568>>>>>>>     End_Function
79569>>>>>>>
79569>>>>>>>
79569>>>>>>>    //*** To be set in CM
79569>>>>>>>     Procedure DFSetUserDefinedPapersize Number nLength Number nWidth
79571>>>>>>>        Integer bOk
79571>>>>>>>        Integer iLength iWidth iSize
79571>>>>>>>
79571>>>>>>>        move (nLength*100) To iLength
79572>>>>>>>        move (nWidth*100)  To iWidth
79573>>>>>>>        move ((iLength*65536)+iWidth) To iSize
79574>>>>>>>
79574>>>>>>>        Move (WP_SetUserDefinedPapersize(iSize)) To bOk
79575>>>>>>>
79575>>>>>>>        If not bOk Begin
79577>>>>>>>            Error DFERR_WINPRINT DFPrintError964
79578>>>>>>>>
79578>>>>>>>        End
79578>>>>>>>>
79578>>>>>>>     End_Procedure
79579>>>>>>>
79579>>>>>>>     Procedure DFSetNumberOfCopies Integer iNrOfCopies
79581>>>>>>>        Boolean bOk
79581>>>>>>>
79581>>>>>>>        Move (WP_SetNumberOfPrintCopies(iNrOfCopies)) to bOk
79582>>>>>>>
79582>>>>>>>        If not bOk Begin
79584>>>>>>>            Error DFERR_WINPRINT DFPrintError965
79585>>>>>>>>
79585>>>>>>>        end
79585>>>>>>>>
79585>>>>>>>     End_Procedure
79586>>>>>>>
79586>>>>>>>
79586>>>>>>>
79586>>>>>>>
79586>>>>>>>    //*************************************************************
79586>>>>>>>    //*** This procedures and functions are used when building  ***
79586>>>>>>>    //*** complex graphics when you need to change value of the ***
79586>>>>>>>    //*** current diagram, so you can mix diagrams within each  ***
79586>>>>>>>    //*** other.                                                ***
79586>>>>>>>    //*************************************************************
79586>>>>>>>
79586>>>>>>>
79586>>>>>>>    Function DFGetCurrentDiagram Returns Integer
79588>>>>>>>        Integer iRetVal
79588>>>>>>>        Get DFCurrent_Diagram To iRetVal
79589>>>>>>>        Function_Return iRetVal
79590>>>>>>>    End_Function
79591>>>>>>>
79591>>>>>>>    Procedure DFSetCurrentDiagram Integer iDiagram
79593>>>>>>>        Set DFCurrent_Diagram To iDiagram
79594>>>>>>>    End_Procedure
79595>>>>>>>
79595>>>>>>>    Procedure DFSetDiagramList Integer iItem Integer iDiagram
79597>>>>>>>        Set Value of oDiagramArray iItem To iDiagram
79598>>>>>>>    End_Procedure
79599>>>>>>>
79599>>>>>>>    Function DFGetDiagramList Integer iItem Returns Integer
79601>>>>>>>        Integer iRetVal
79601>>>>>>>        Get Value of oDiagramArray iItem To iRetVal
79602>>>>>>>        Function_Return iRetVal
79603>>>>>>>    End_Function
79604>>>>>>>
79604>>>>>>>    Procedure DFClearDiagramList
79606>>>>>>>        Send Delete_Data To oDiagramArray
79607>>>>>>>    End_Procedure
79608>>>>>>>
79608>>>>>>>
79608>>>>>>>    Function DFGetColor Integer iColor Returns Dword
79610>>>>>>>        Dword   dwRetVal
79610>>>>>>>        Get Value of oDFColorArray iColor To dwRetVal
79611>>>>>>>        Function_Return dwRetVal
79612>>>>>>>    End_Function
79613>>>>>>>
79613>>>>>>>    Function DFGetCurrentColor Returns Dword
79615>>>>>>>        Dword   dwRetVal
79615>>>>>>>        Integer iCurrColor
79615>>>>>>>
79615>>>>>>>        Get DFCurrent_Color To iCurrColor
79616>>>>>>>        Get DFGetColor iCurrColor To dwRetVal
79617>>>>>>>
79617>>>>>>>        Function_Return dwRetVal
79618>>>>>>>    End_Function
79619>>>>>>>
79619>>>>>>>    Procedure DFEndDocument
79621>>>>>>>        integer iVoid
79621>>>>>>>        Move (WP_EndDocument()) To iVoid
79622>>>>>>>        Send DfSuspendGui False
79623>>>>>>>    End_procedure
79624>>>>>>>
79624>>>>>>>    Procedure DFClosePreview
79626>>>>>>>        integer iVoid
79626>>>>>>>        Move (WP_ClosePreview()) To iVoid
79627>>>>>>>        Send DfSuspendGui False
79628>>>>>>>    End_procedure
79629>>>>>>>
79629>>>>>>>    Procedure SetProgressCaption string sCaption
79631>>>>>>>        integer iVoid
79631>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79632>>>>>>>        Move (WP_SetProgressCaption(sCaption)) To iVoid
79633>>>>>>>    End_procedure
79634>>>>>>>
79634>>>>>>>    Procedure SetReportTitle string sTitle
79636>>>>>>>        integer iVoid
79636>>>>>>>        Move (ToAnsi(sTitle)) to sTitle
79637>>>>>>>        Move (WP_SetReportTitle(sTitle)) To iVoid
79638>>>>>>>    End_procedure
79639>>>>>>>
79639>>>>>>>    Function PreviewYesNoBox string sCaption string sText returns integer
79641>>>>>>>        integer eResult
79641>>>>>>>        Move (ToAnsi(sCaption)) to sCaption
79642>>>>>>>        Move (ToAnsi(sText))    to sText
79643>>>>>>>        Move (WP_DisplayMessageBox(sCaption, sText)) To eResult
79644>>>>>>>        Function_return eResult
79645>>>>>>>    end_function
79646>>>>>>>
79646>>>>>>>    // internal function, used to extract different printer flags ranges based on
79646>>>>>>>    // the print flag integer. These flags use a decimal style of packing information
79646>>>>>>>    // where different printer options (paper, bin, etc) use different ranges and
79646>>>>>>>    // different steps. Everything above iTopVal is removed and everything that is not
79646>>>>>>>    // within the iStep range is removed.
79646>>>>>>>    Function PrintFlagRange integer iTopVal integer iStep returns integer
79648>>>>>>>        integer iFgs iFg
79648>>>>>>>        Get DFGetPrintDialogFlags to iFg
79649>>>>>>>        Move (mod(iFg,iTopVal) / iStep * iStep ) to iFg
79650>>>>>>>        function_return iFg
79651>>>>>>>    end_Function
79652>>>>>>>
79652>>>>>>>    Procedure DFSetPrinterPaper integer ePaperType
79654>>>>>>>        Send DFSetSpecPrintFlag ePaperType
79655>>>>>>>    End_Procedure
79656>>>>>>>
79656>>>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
79658>>>>>>>        integer ePaperType
79658>>>>>>>        Get PrintFlagRange 500 10 to ePaperType // 10-490 in steps of 10
79659>>>>>>>        function_return ePaperType
79660>>>>>>>    End_Function
79661>>>>>>>
79661>>>>>>>
79661>>>>>>>    Procedure DFSetPrinterBin integer eBinType
79663>>>>>>>        Send DFSetSpecPrintFlag eBinType
79664>>>>>>>    End_Procedure
79665>>>>>>>
79665>>>>>>>    Function DFGetPrinterBin returns integer //eBinType
79667>>>>>>>        integer eBinType
79667>>>>>>>        Get PrintFlagRange 10000 500 to eBinType // 1000-9000 steps 500
79668>>>>>>>        function_return eBinType
79669>>>>>>>    End_Function
79670>>>>>>>
79670>>>>>>>
79670>>>>>>>    Procedure DFSetPrinterResolution integer eResType
79672>>>>>>>        Send DFSetSpecPrintFlag eResType
79673>>>>>>>    End_Procedure
79674>>>>>>>
79674>>>>>>>    Function DFGetPrinterResolution returns integer //eResType
79676>>>>>>>        integer eResType
79676>>>>>>>        Get PrintFlagRange 50000 10000 to eResType // 10000-500000 steps 10000
79677>>>>>>>        function_return eResType
79678>>>>>>>    End_Function
79679>>>>>>>
79679>>>>>>>
79679>>>>>>>    Procedure DFSetLandscape boolean bIsLandscape
79681>>>>>>>        Send DFSetSpecPrintFlag (If(bIsLandscape,DF_Landscape,DF_Portrait))
79682>>>>>>>    End_Procedure
79683>>>>>>>
79683>>>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
79685>>>>>>>        boolean bIsLandscape
79685>>>>>>>        Get DFCheckPrintDialogFlag DF_Landscape to bIsLandscape
79686>>>>>>>        function_return bIsLandscape
79687>>>>>>>    End_Function
79688>>>>>>>
79688>>>>>>>    Function RGBToWPColor integer iRgb returns integer
79690>>>>>>>        integer iRed iGreen iBlue
79690>>>>>>>        integer iWPColor
79690>>>>>>>        Move (R_from_rgb(iRGB)) to iRed
79691>>>>>>>        Move (G_from_rgb(iRGB)) to iGreen
79692>>>>>>>        Move (B_from_rgb(iRGB)) to iBlue
79693>>>>>>>        Get DfGetDfColor iRed iGreen iBlue to iWPColor
79694>>>>>>>        function_Return iWPColor
79695>>>>>>>    end_function
79696>>>>>>>
79696>>>>>>>
79696>>>>>>>
79696>>>>>>>End_Class
79697>>>>>>>
79697>>>>>>>Global_Variable Integer ghoWinPrint2
79697>>>>>>>
79697>>>>>>>Get Create of desktop U_cWinPrint2 to ghoWinPrint2
79698>>>>>>>
79698>>>>>>>
79698>>>>>Use Winprint_Commands.pkg  // commands used by this class
79698>>>>>
79698>>>>>Class cWinReport2 is a BasicReport
79699>>>>>
79699>>>>>    Procedure Construct_Object
79701>>>>>        Forward send construct_object
79703>>>>>
79703>>>>>        Date Today
79703>>>>>        Sysdate Today
79704>>>>>
79704>>>>>        // should use built in DF function CurrentDateTime()
79704>>>>>        Property Date  RptToday    Today
79705>>>>>
79705>>>>>        Object RptTotal is an Array
79707>>>>>        End_Object
79708>>>>>
79708>>>>>        // If true, report is output upon completion. Either preview
79708>>>>>        // or printer depending on output_device_mode
79708>>>>>        Property Boolean AutoOutput_State True
79709>>>>>
79709>>>>>        // When a new page is created (DFNew_Page) and the number
79709>>>>>        // of columns is not passed, this is used.
79709>>>>>        Property Integer Print_Columns 0
79710>>>>>
79710>>>>>        // This determines if a DFNew_Page should be executed when the
79710>>>>>        // report starts. In some rare cases, you would not want this to
79710>>>>>        // occur until a subheader
79710>>>>>        Property Boolean AutoNew_Page_State True
79711>>>>>
79711>>>>>        // Output device (print or preview). Normally this is delegated to
79711>>>>>        // the report view.
79711>>>>>        //
79711>>>>>
79711>>>>>        Property Integer Private.Output_Device_Mode PRINT_TO_UNDEFINED
79712>>>>>
79712>>>>>        Property Handle phoWinPrint  ghoWinPrint2 // the report engine to use.
79713>>>>>
79713>>>>>        // JJT: For now this is for testing.
79713>>>>>        Property boolean pbModalViewer False
79714>>>>>
79714>>>>>        Property boolean pbMultiReports False
79715>>>>>
79715>>>>>        Property boolean pbFirstPagePrinted false
79716>>>>>
79716>>>>>    End_Procedure
79717>>>>>
79717>>>>>    // returns the current status of Winprint Document object. dsNotStarted, dsStarted, dsFinished
79717>>>>>    // note that the status can reflect a status from a different report. The winprint object is global.
79717>>>>>    Function DocumentStatus returns Boolean
79719>>>>>        integer iStatus
79719>>>>>        Get DocumentStatus of (phoWinprint(self)) to iStatus
79720>>>>>        function_return iStatus
79721>>>>>    End_function
79722>>>>>
79722>>>>>    Function IsViewerActive Returns Boolean
79724>>>>>        Boolean bIsActive
79724>>>>>        Get IsViewerActive of (phoWinPrint(Self)) to bIsActive
79725>>>>>        Function_Return bIsActive
79726>>>>>    End_Function
79727>>>>>
79727>>>>>    Function IsPrinterValid Returns Boolean
79729>>>>>        Function_Return (WP_IsPrinterValid()<>0)
79730>>>>>    End_Function
79731>>>>>
79731>>>>>    Function ArePrintersInstalled Returns Boolean
79733>>>>>        Function_Return (WP_ArePrintersInstalled()<>0)
79734>>>>>    End_Function
79735>>>>>
79735>>>>>
79735>>>>>    // All subtotal commands use the outer main report. This makes it easier to keep
79735>>>>>    // track of these numbers
79735>>>>>
79735>>>>>    Procedure Add_SubTotal Integer iCounter Number nData
79737>>>>>        Number nValue
79737>>>>>        Integer iObj
79737>>>>>        Move (RptTotal(Main_Report_Id(Self))) to iObj
79738>>>>>        Get Number_Value of iObj iCounter To nValue
79739>>>>>        Add nData To nValue
79740>>>>>        Set Array_Value of iObj iCounter To nValue
79741>>>>>    End_Procedure
79742>>>>>
79742>>>>>    Procedure Clr_SubTotal Integer iCounter
79744>>>>>        Set Array_Value of (RptTotal(Main_Report_Id(Self))) iCounter To 0
79745>>>>>    End_Procedure
79746>>>>>
79746>>>>>    Procedure Clr_AllSubTotals
79748>>>>>        Send Delete_Data of (RptTotal(Main_Report_Id(Self)))
79749>>>>>    End_Procedure
79750>>>>>
79750>>>>>    Function Sum_SubTotal Integer iTotal Returns Number
79752>>>>>        Number nRetVal
79752>>>>>        Get Number_Value of (RptTotal(Main_Report_Id(Self))) iTotal To nRetVal
79753>>>>>        Function_Return nRetVal
79754>>>>>    End_Function
79755>>>>>
79755>>>>>    //Return sub-total and clear accumulator
79755>>>>>    //
79755>>>>>    Function SubTotal Integer iTotal Returns Number
79757>>>>>        Number nRetVal
79757>>>>>        Get Sum_SubTotal  iTotal to nRetVal
79758>>>>>        Send Clr_SubTotal iTotal
79759>>>>>        Function_Return nRetVal
79760>>>>>    End_Function
79761>>>>>
79761>>>>>
79761>>>>>    // Note: Cols is optional. If no argument is passed it will use
79761>>>>>    //       the object's property Print_Columns (0 by default)
79761>>>>>    //
79761>>>>>    Procedure DFNew_Page Integer Cols
79763>>>>>        Integer PageNumber Columns
79763>>>>>        Boolean bFirstPagePrinted
79763>>>>>        // If no args passed used default setting
79763>>>>>        If (Num_Arguments=0) ;           Move (Print_Columns(Main_Report_id(Self))) to Columns
79766>>>>>        Else ;           Move Cols to Columns
79768>>>>>        Set Page_Feed   to -2   // No FormFeed
79769>>>>>        If (Child_Rpt_State(self)) ;            Send DFNew_Page of (Main_Report_Id(Self)) Columns
79772>>>>>        Else Begin
79773>>>>>            // we only want to print report_header once. When report starts
79773>>>>>            // this is set true, after the first print it is false. You can set
79773>>>>>            // this to true before and explicit dfNew_page to force a header
79773>>>>>            Get pbFirstPagePrinted to bFirstPagePrinted
79774>>>>>            Get  DFNewPage of (phoWinPrint(self)) Columns To PageNumber
79775>>>>>            If (PageNumber<>0) begin // if 0, it failed
79777>>>>>                Set No_PageCheck_State to True
79778>>>>>
79778>>>>>                //Top section
79778>>>>>                Send Page_Top
79779>>>>>                If Not bFirstPagePrinted Send Report_Header
79782>>>>>                Send Page_Header
79783>>>>>                Send Page_Title
79784>>>>>
79784>>>>>                Set New_Page_State to False
79785>>>>>                Set Page_End_State to False
79786>>>>>                Set No_PageCheck_State to False        // No longer Paging
79787>>>>>                Set pbFirstPagePrinted to True
79788>>>>>            End
79788>>>>>>
79788>>>>>        End
79788>>>>>>
79788>>>>>
79788>>>>>        // Footer section
79788>>>>>        //
79788>>>>>        // DO NOT CHANGE THE ORDER OF BOTTOM SECTIONS !!!!!
79788>>>>>        //
79788>>>>>
79788>>>>>        Send Page_Bottom
79789>>>>>
79789>>>>>        // in WinPrint it is not possible to replace Page_Footer
79789>>>>>        // with Report_Footer. If you use Report_Footer you will
79789>>>>>        // have both Page_Footer and Report_Footer
79789>>>>>        //
79789>>>>>        //If LastTime eq 0 Send Page_Footer
79789>>>>>        //else             Send Report_Footer
79789>>>>>
79789>>>>>        Send Page_Footer
79790>>>>>        Send Page_Total
79791>>>>>    End_Procedure
79792>>>>>
79792>>>>>    Procedure Ending_Main_Report
79794>>>>>        Boolean bCancel bMultiReports
79794>>>>>
79794>>>>>        Get Cancelled_state to bCancel
79795>>>>>        Get pbMultiReports to bMultiReports
79796>>>>>
79796>>>>>        Forward Send Ending_Main_Report
79798>>>>>
79798>>>>>        If bCancel Begin
79800>>>>>            Send DFEndDocument
79801>>>>>            Send DFClearDoc // this will also close the previewer
79802>>>>>        end
79802>>>>>>
79802>>>>>        Else Begin
79803>>>>>            Send Report_Footer
79804>>>>>
79804>>>>>            // if multi-reports, we don't do an end of report yet. The programmer must
79804>>>>>            // manually end the report by sending EndMultiReport
79804>>>>>            If (not(bMultiReports)) begin
79806>>>>>                Send EndWinPrintReport
79807>>>>>            end
79807>>>>>>
79807>>>>>
79807>>>>>        end
79807>>>>>>
79807>>>>>
79807>>>>>    End_Procedure
79808>>>>>
79808>>>>>    // This must get called when you are running multiple reports (pbMultiReport).
79808>>>>>    // Send this when the last report is complete.
79808>>>>>    Procedure EndMultiReport
79810>>>>>        Send EndWinPrintReport
79811>>>>>    End_procedure
79812>>>>>
79812>>>>>
79812>>>>>    Procedure EndWinPrintReport
79814>>>>>        Boolean bAutoOutput
79814>>>>>        integer iStatus eMode
79814>>>>>        Get DocumentStatus to iStatus
79815>>>>>        If (iStatus<>dsStarted) procedure_return
79818>>>>>
79818>>>>>        // this tells winprint that the report is complete
79818>>>>>        Send DFEndDocument
79819>>>>>        // if auto-output we print or display automatically.
79819>>>>>        // for winprint2, if in preview mode you must do this so the previewer can enter
79819>>>>>        // a modal state (which it may or may not need to do).
79819>>>>>        Get AutoOutput_state to bAutoOutput
79820>>>>>        Get Output_device_mode to eMode
79821>>>>>        If (bAutoOutput or eMode=PRINT_TO_WINDOW) begin
79823>>>>>            Send PrintReport
79824>>>>>            // if auto output, we assume that you are done when it is all over
79824>>>>>            // we only can do this with the modal viewer
79824>>>>>            If (bAutoOutput and pbModalViewer(self)) begin
79826>>>>>                Send DFClearDoc
79827>>>>>            end
79827>>>>>>
79827>>>>>        end
79827>>>>>>
79827>>>>>
79827>>>>>    End_Procedure
79828>>>>>
79828>>>>>
79828>>>>>    Function Setup_Report Returns Integer
79830>>>>>        Integer iErr iStatus eMode
79830>>>>>        Boolean bActiveViewer bChildReport bMultiReports bOk
79830>>>>>
79830>>>>>        Get Child_rpt_state to bChildReport
79831>>>>>
79831>>>>>        If not bChildReport Begin
79833>>>>>
79833>>>>>            // This makes sure that we are pointing to the new winprint2 engine object.
79833>>>>>            // normally this will be the new winprint, but it can be redirected
79833>>>>>            Get phoWinPrint to WinPrintID
79834>>>>>
79834>>>>>            // winprint must have installed printer. If not installed, generate error and stop the report
79834>>>>>            Get ArePrintersInstalled to bOk
79835>>>>>            If not bOk Begin
79837>>>>>                Error DFERR_WINPRINT C_$NoInstalledPrinters
79838>>>>>>
79838>>>>>                Function_Return 1
79839>>>>>            End
79839>>>>>>
79839>>>>>
79839>>>>>            // check if selected printer is valid. If not, generate error and stop the report
79839>>>>>            Get IsPrinterValid to bOk
79840>>>>>            If not bOk Begin
79842>>>>>                Error DFERR_WINPRINT DFPrintError936    // Could not select a valid printer
79843>>>>>>
79843>>>>>                Function_Return 1
79844>>>>>            End
79844>>>>>>
79844>>>>>
79844>>>>>            // make sure it is ok to start a new report but try to be smart about it.
79844>>>>>            // if a report is active (dsstarted or dsFinished) check to see if it is
79844>>>>>            // finished w/ no viewer. If so, assume the user closed the report and is done
79844>>>>>            // so just clear the report. If a viewer is present, declare an error.
79844>>>>>            Get DocumentStatus to iStatus
79845>>>>>            Get pbMultiReports to bMultiReports
79846>>>>>            // multi-report only in-progress is multi and it is started
79846>>>>>            Move (bMultiReports and iStatus=dsStarted) to bMultiReports
79847>>>>>            If not bMultiReports Begin
79849>>>>>                If (iStatus<>dsNotStarted) Begin
79851>>>>>                    Get IsViewerActive to bActiveViewer
79852>>>>>                    If (iStatus=dsFinished and not(bActiveViewer)) Begin
79854>>>>>                        Send DfClearDoc
79855>>>>>                    End
79855>>>>>>
79855>>>>>                    Else Begin
79856>>>>>                        Error DFERR_WINPRINT DFPrintError967
79857>>>>>>
79857>>>>>                        Function_Return 1
79858>>>>>                    End
79858>>>>>>
79858>>>>>                End
79858>>>>>>
79858>>>>>
79858>>>>>                // all new reports by default allow printing from viewer and they have the print job set up when you select print
79858>>>>>                // if you need to change these defaults, you can change these inside of Starting_main_report
79858>>>>>                // We only do this with non-multi-reports.
79858>>>>>                Send DFSetPrintDlgInPreview      True
79859>>>>>                Send DFSetEnablePrintFromPreview True
79860>>>>>
79860>>>>>            End
79860>>>>>>
79860>>>>>
79860>>>>>            // In the new winprint, this message is not needed and is a stub. For
79860>>>>>            // now it is in here for compatibility purposes
79860>>>>>            //You MUST always start a new report with this procedure
79860>>>>>            Send DFZeroCounters of (phoWinPrint(Self))
79861>>>>>            Send Clr_AllSubTotals
79862>>>>>
79862>>>>>        End
79862>>>>>>
79862>>>>>
79862>>>>>        Forward Get Setup_report to iErr
79864>>>>>
79864>>>>>        If (iErr=0) Begin
79866>>>>>            If not bChildReport Begin
79868>>>>>                // if part of a multi-report we don't do a new doc
79868>>>>>                If not bMultiReports Begin
79870>>>>>                    Get Output_Device_Mode to eMode
79871>>>>>                    Send DFNewDoc of (phoWinPrint(Self))  (eMode = PRINT_TO_WINDOW) // pass True of display while printing
79872>>>>>                End
79872>>>>>>
79872>>>>>                // Do new page if not part of a multi-report and we say don't do a new page
79872>>>>>                If (not(bMultiReports) or AutoNew_Page_State(Self)) Begin
79874>>>>>                    Set pbFirstPagePrinted to False // tells new page that this is the first time for this report
79875>>>>>                    Send DFNew_page
79876>>>>>                End
79876>>>>>>
79876>>>>>            End
79876>>>>>>
79876>>>>>        End
79876>>>>>>
79876>>>>>        Function_Return iErr
79877>>>>>    End_Function
79878>>>>>
79878>>>>>
79878>>>>>
79878>>>>>    // Cancel RO behavior - there is no device to close
79878>>>>>    //
79878>>>>>    Procedure Close_Output_Device
79880>>>>>    End_Procedure
79881>>>>>
79881>>>>>    // Cancel RO Behavior
79881>>>>>    //
79881>>>>>    Procedure Initialize_Output_Device
79883>>>>>    End_procedure
79884>>>>>
79884>>>>>
79884>>>>>    Function Output_Device_Mode Returns Integer
79886>>>>>        Integer hoId
79886>>>>>        String DevMode
79886>>>>>        Get Private.Output_Device_Mode to DevMode
79887>>>>>        If (DevMode=PRINT_TO_UNDEFINED) Begin
79889>>>>>            Get Report_View_Id to hoId
79890>>>>>            If hoID ;                Get OutPut_Device_Mode of hoID to DevMode
79893>>>>>            If (DevMode=PRINT_TO_UNDEFINED) ;                Move PRINT_TO_WINDOW to DevMode
79896>>>>>        End
79896>>>>>>
79896>>>>>        Function_Return DevMode
79897>>>>>    End_Function // Output_Destination
79898>>>>>
79898>>>>>    Procedure Set Output_Device_Mode Integer DevMode
79900>>>>>        Set Private.Output_Device_Mode to DevMode
79901>>>>>    End_Procedure // Set Output_Device
79902>>>>>
79902>>>>>    // displays a metric ruler in .5 increments. This can be
79902>>>>>    // sent to make it easy to see how fields and labels should
79902>>>>>    // be moved for alignment.
79902>>>>>    //
79902>>>>>    Procedure ShowRuler
79904>>>>>        integer i
79904>>>>>        number n
79904>>>>>        for i from 0 to 30
79910>>>>>>
79910>>>>>            Send DFWritePos of (phoWinPrint(self)) (String(i)) FONT_DEFAULT i -1 0
79911>>>>>            Move (i+.5) to n
79912>>>>>            Send DFWritePos of (phoWinPrint(self)) "." FONT_DEFAULT n -1 0
79913>>>>>        Loop
79914>>>>>>
79914>>>>>        Send DFWriteln of (phoWinPrint(self)) ''  FONT_DEFAULT FONT_DEFAULT -1
79915>>>>>    End_procedure
79916>>>>>
79916>>>>>      // status panel related agumentations to handle the auto-previewer
79916>>>>>
79916>>>>>      Procedure Update_Status string sVal
79918>>>>>         Integer eMode
79918>>>>>         Get Output_device_mode to eMode
79919>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79921>>>>>            Send SetProgressCaption  of (phoWinPrint(self)) sVal
79922>>>>>         End
79922>>>>>>
79922>>>>>         Else Begin
79923>>>>>            forward Send Update_Status sVal
79925>>>>>         end
79925>>>>>>
79925>>>>>      End_Procedure
79926>>>>>
79926>>>>>      Procedure Start_Status
79928>>>>>         Integer eMode
79928>>>>>         string sTitle sCaption
79928>>>>>         Get Output_device_mode to eMode
79929>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79931>>>>>            Get Report_Caption to sCaption
79932>>>>>            Get Report_Title to sTitle
79933>>>>>            If (sTitle<>"" and sCaption<>"") begin
79935>>>>>                Move ( sCaption- ":" * sTitle) to sTitle
79936>>>>>            end
79936>>>>>>
79936>>>>>            else begin
79937>>>>>                Move (sCaption - sTitle) to sTitle
79938>>>>>            end
79938>>>>>>
79938>>>>>            Send SetReportTitle of (phoWinPrint(self)) sTitle
79939>>>>>         End
79939>>>>>>
79939>>>>>         Else Begin
79940>>>>>            forward Send Start_status
79942>>>>>         end
79942>>>>>>
79942>>>>>      End_Procedure
79943>>>>>
79943>>>>>      Procedure Resume_Status
79945>>>>>         Integer eMode
79945>>>>>         Get Output_device_mode to eMode
79946>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79948>>>>>            Send DfPreviewNoWait of (phoWinPrint(self))
79949>>>>>         End
79949>>>>>>
79949>>>>>         Else Begin
79950>>>>>            forward Send Resume_Status
79952>>>>>         end
79952>>>>>>
79952>>>>>      End_Procedure
79953>>>>>
79953>>>>>      Procedure End_Status
79955>>>>>         Integer eMode
79955>>>>>         Get Output_device_mode to eMode
79956>>>>>         If (error_processing_state(self)) Begin
79958>>>>>            Send DFClosePreview
79959>>>>>         end
79959>>>>>>
79959>>>>>         If (eMode=PRINT_TO_WINDOW) Begin
79961>>>>>         End
79961>>>>>>
79961>>>>>         Else Begin
79962>>>>>            forward Send End_Status
79964>>>>>         end
79964>>>>>>
79964>>>>>      End_Procedure
79965>>>>>
79965>>>>>    Function Report_Interrupt Returns Integer
79967>>>>>         integer eStat
79967>>>>>         String sMess
79967>>>>>         Boolean bActiveViewer
79967>>>>>         Get IsViewerActive to bActiveViewer
79968>>>>>         If (Error_Check_State(self)) begin
79970>>>>>            Move C_$AnErrorWishToCancel to sMess
79971>>>>>         end
79971>>>>>>
79971>>>>>         Else begin
79972>>>>>            Move  C_$CancelThisReport to sMess
79973>>>>>         end
79973>>>>>>
79973>>>>>         If bActiveViewer Begin
79975>>>>>            Get PreviewYesNoBox of (phoWinPrint(self)) C_$ReportInterrupt sMess to eStat
79976>>>>>         end
79976>>>>>>
79976>>>>>         Else Begin
79977>>>>>            Get YesNo_Box sMess C_$ReportInterrupt to eStat
79978>>>>>         End
79978>>>>>>
79978>>>>>
79978>>>>>         Function_Return (eStat=MBR_YES)
79979>>>>>
79979>>>>>  End_Function
79980>>>>>
79980>>>>>  Function Test_KeyPressed Returns Integer
79982>>>>>     Boolean bStop bError bActiveViewer
79982>>>>>     integer eMode
79982>>>>>     // winreport will do this also, but this makes sure that this gets called
79982>>>>>     // for each body loop -- even if the body loop prints nothing
79982>>>>>     Send PumpMsgQueue of (phoWinPrint(self)) // permit painting
79983>>>>>     Get IsViewerActive to bActiveViewer
79984>>>>>     Get Output_device_mode to eMode
79985>>>>>     If bActiveViewer Begin
79987>>>>>        Get ViewerWantsToClose of (phoWinPrint(self)) to bStop
79988>>>>>        Get Error_Check_State to bError
79989>>>>>        if (bStop or bError) begin
79991>>>>>            Get Report_Interrupt to bStop
79992>>>>>        end
79992>>>>>>
79992>>>>>     end
79992>>>>>>
79992>>>>>     Else Begin
79993>>>>>        Forward Get Test_KeyPressed to bStop
79995>>>>>        If (eMode=PRINT_TO_WINDOW and not(bStop)) Begin
79997>>>>>            Send DfPreviewNoWait
79998>>>>>        end
79998>>>>>>
79998>>>>>     End
79998>>>>>>
79998>>>>>
79998>>>>>     Function_Return bStop
79999>>>>>  End_Function
80000>>>>>
80000>>>>>    Procedure OnClosingView
80002>>>>>        Send DFClearDoc
80003>>>>>    end_procedure
80004>>>>>
80004>>>>>
80004>>>>>    // Attempt to make this as intuitive as possible. You cannot invoke this when a
80004>>>>>    // report is active. If a report is not finished, you cannot do this.
80004>>>>>    // If a report is finsihed it may or may not have a viewer present.
80004>>>>>    // If a viewer is not present, we will clear the exising report (making the assumption
80004>>>>>    // that a modeless viewer was closed and the report will not be invoked again). If a viewer
80004>>>>>    // is active, we will pass this through to the winprint object which will show an error
80004>>>>>
80004>>>>>    Function DFPrintSetupDialog Returns Boolean// invoke printer setup dialog
80006>>>>>        Integer iStatus
80006>>>>>        Boolean bActiveViewer bOk
80006>>>>>        // we must have printers installed for this to work
80006>>>>>        Get ArePrintersInstalled to bOk
80007>>>>>        If not bOk Begin
80009>>>>>            Error DFERR_WINPRINT C_$NoInstalledPrinters
80010>>>>>>
80010>>>>>        End
80010>>>>>>
80010>>>>>        Else Begin
80011>>>>>            Get DocumentStatus to iStatus
80012>>>>>            If (iStatus=dsFinished) Begin
80014>>>>>                Get IsViewerActive to bActiveViewer
80015>>>>>                If not bActiveViewer Begin
80017>>>>>                    Send DfClearDoc
80018>>>>>                End
80018>>>>>>
80018>>>>>            End
80018>>>>>>
80018>>>>>            // the winprint object will generate an error if the status is not dsNotStarted.
80018>>>>>            // we want those errors
80018>>>>>            Get DFPrintSetupDialog of (phoWinPrint(Self)) to bOk
80019>>>>>        End
80019>>>>>>
80019>>>>>        Function_Return bOk
80020>>>>>    End_Procedure
80021>>>>>
80021>>>>>    // It is better to use DFPrintSetupDialog which tells you if the dialog was canceled
80021>>>>>    Procedure DFPrintSetup // invoke printer setup dialog
80023>>>>>        Boolean bOk
80023>>>>>        Get DFPrintSetupDialog to bOk
80024>>>>>    End_Procedure
80025>>>>>
80025>>>>>    Procedure DFClearDoc // clear document, remove viewer
80027>>>>>        Send DFClearDoc of (phoWinPrint(self))
80028>>>>>    end_procedure
80029>>>>>
80029>>>>>    Procedure DFEndDocument // tell winprint that the report is complete
80031>>>>>        Send DfEndDocument of (phoWinPrint(self))
80032>>>>>    end_procedure
80033>>>>>
80033>>>>>    Procedure DFClosePreview //close the previewer, does not clear the document
80035>>>>>        Send DfClosePreview of (phoWinPrint(self))
80036>>>>>    end_procedure
80037>>>>>
80037>>>>>    Procedure DFPrintDialog // popup print job dialog
80039>>>>>        Send DFPrintDialog of (phoWinPrint(self))
80040>>>>>    End_procedure
80041>>>>>
80041>>>>>    Procedure DFPrint // print with printer dialog
80043>>>>>        Send DFPrint of (phoWinPrint(self))
80044>>>>>    End_procedure
80045>>>>>
80045>>>>>    Procedure DFPrintDoc // print without printer dialog
80047>>>>>        Send DFPrintDoc of (phoWinPrint(self))
80048>>>>>    End_Procedure
80049>>>>>
80049>>>>>    Procedure DFPreviewWait // invoke previewer in modal mode
80051>>>>>       Send DFPreviewWait of (phoWinPrint(self))
80052>>>>>    End_Procedure
80053>>>>>
80053>>>>>    Procedure DFPreviewNoWait // invoke previwer in modeless mode
80055>>>>>       Send DFPreviewNoWait of (phoWinPrint(self))
80056>>>>>    End_Procedure
80057>>>>>
80057>>>>>    Procedure DFPreview // invokde previewer based on pbModalViewer property
80059>>>>>       Boolean bModalViewer
80059>>>>>       Get pbModalViewer to bModalViewer
80060>>>>>       If bModalViewer Begin
80062>>>>>           Send DFPreviewWait
80063>>>>>       end
80063>>>>>>
80063>>>>>       else Begin
80064>>>>>           Send DFPreviewNoWait
80065>>>>>       end
80065>>>>>>
80065>>>>>   End_Procedure
80066>>>>>
80066>>>>>    // Print report to appropriate device (printer, preview) based
80066>>>>>    // on output_device_mode
80066>>>>>    //
80066>>>>>    Procedure PrintReport
80068>>>>>        Integer eMode
80068>>>>>        Get OutPut_Device_Mode to eMode
80069>>>>>        If ((eMode=PRINT_TO_WINDOW) or (eMode=DEFERRED_PRINT_TO_WINDOW)) Begin
80071>>>>>           Send DFPreview
80072>>>>>        end
80072>>>>>>
80072>>>>>        Else If (eMode=PRINT_TO_PRINTER_NO_DIALOG) Begin
80075>>>>>           Send DFPrintDoc // print, no print job dialog
80076>>>>>        end
80076>>>>>>
80076>>>>>        Else Begin // (eMode=PRINT_TO_PRINTER)
80077>>>>>           Send DFPrint // print with print job dialog
80078>>>>>        end
80078>>>>>>
80078>>>>>    End_Procedure
80079>>>>>
80079>>>>>
80079>>>>>    Procedure DFSetPrinterPaper integer ePaperType
80081>>>>>        Send DFSetPrinterPaper of (phoWinPrint(self)) ePaperType
80082>>>>>    End_Procedure
80083>>>>>
80083>>>>>    Function DFGetPrinterPaper returns integer //ePaperType
80085>>>>>        integer ePaperType
80085>>>>>        Get DFGetPrinterPaper of (phoWinPrint(self)) to ePaperType
80086>>>>>        Function_return ePaperType
80087>>>>>    end_function
80088>>>>>
80088>>>>>
80088>>>>>    Procedure DFSetPrinterBin integer eBinType
80090>>>>>        Send DFSetPrinterBin of (phoWinPrint(self)) eBinType
80091>>>>>    End_Procedure
80092>>>>>
80092>>>>>    Function DFGetPrinterBin returns integer //eBinType
80094>>>>>        integer eBinType
80094>>>>>        Get DFGetPrinterBin of (phoWinPrint(self)) to eBinType
80095>>>>>        Function_return eBinType
80096>>>>>    end_function
80097>>>>>
80097>>>>>
80097>>>>>    Procedure DFSetPrinterResolution integer eResType
80099>>>>>        Send DFSetPrinterResolution of (phoWinPrint(self)) eResType
80100>>>>>    End_Procedure
80101>>>>>
80101>>>>>    Function DFGetPrinterResolution returns integer //eResType
80103>>>>>        Boolean eResType
80103>>>>>        Get DFGetPrinterResolution of (phoWinPrint(self)) to eResType
80104>>>>>        Function_return eResType
80105>>>>>    end_function
80106>>>>>
80106>>>>>
80106>>>>>    Procedure DFSetLandscape boolean bIsLandscape
80108>>>>>        Send DFSetLandscape of (phoWinPrint(self)) bIsLandscape
80109>>>>>    End_Procedure
80110>>>>>
80110>>>>>    Function DFGetLandscape returns boolean // bIsLandscape
80112>>>>>        Boolean bIsLandscape
80112>>>>>        Get DFGetLandscape of (phoWinPrint(self)) to bIsLandscape
80113>>>>>        Function_return bIsLandscape
80114>>>>>    end_function
80115>>>>>
80115>>>>>    Procedure DFSetMetrics integer eType
80117>>>>>        Send DFSetMetrics of (phoWinPrint(self)) eType
80118>>>>>    End_Procedure
80119>>>>>
80119>>>>>    Function DFGetMetrics returns integer
80121>>>>>        integer eType
80121>>>>>        Get DFGetMetrics of (phoWinPrint(self)) to eType
80122>>>>>        Function_return eType
80123>>>>>    end_function
80124>>>>>
80124>>>>>
80124>>>>>    Procedure DFSetPrintDlgInPreview boolean bShowDialog
80126>>>>>        Set PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80127>>>>>    End_Procedure
80128>>>>>
80128>>>>>    Function DFGetPrintDlgInPreview returns boolean
80130>>>>>        boolean bShowDialog
80130>>>>>        Get PrintDlgInPreview of (phoWinPrint(self)) to bShowDialog
80131>>>>>        Function_return bShowDialog
80132>>>>>    end_function
80133>>>>>
80133>>>>>
80133>>>>>    Procedure DFSetEnablePrintFromPreview boolean bEnablePrint
80135>>>>>        Set EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80136>>>>>    End_Procedure
80137>>>>>
80137>>>>>    Function DFGetEnablePrintFromPreview returns boolean
80139>>>>>        boolean bEnablePrint
80139>>>>>        Get EnablePrintFromPreview of (phoWinPrint(self)) to bEnablePrint
80140>>>>>        Function_return bEnablePrint
80141>>>>>    end_function
80142>>>>>
80142>>>>>
80142>>>>>
80142>>>>>    Procedure DFSetMargins number nLeft number nTop number nRight number nBottom
80144>>>>>        Send DFSetMargins of (phoWinPrint(self)) nLeft nTop nRight nBottom
80145>>>>>    End_Procedure
80146>>>>>
80146>>>>>    Procedure DFSetTopBottom number nTop number nBottom Boolean bAllPages
80148>>>>>        Send DFSetTopBottom of (phoWinPrint(self)) nTop nBottom bAllPages
80149>>>>>    End_Procedure
80150>>>>>
80150>>>>>
80150>>>>>    Procedure DFSetDevice string sPrinterName
80152>>>>>        Send DFSetDevice of (phoWinPrint(self)) sPrinterName
80153>>>>>    End_Procedure
80154>>>>>
80154>>>>>    Function DFGetCurrentDevice returns string // sPrinterName
80156>>>>>        String sPrinterName
80156>>>>>        Get DFGetCurrentDevice of (phoWinPrint(self)) to sPrinterName
80157>>>>>        Function_return sPrinterName
80158>>>>>    end_function
80159>>>>>
80159>>>>>
80159>>>>>    Procedure DFSetUserDefinedPapersize number nLength number nWidth
80161>>>>>        Send DFSetUserDefinedPapersize of (phoWinPrint(self)) nLength nWidth
80162>>>>>    End_Procedure
80163>>>>>
80163>>>>>    Function DFGetUserDefinedLength returns number
80165>>>>>        number nSize
80165>>>>>        Get DFGetUserDefinedLength of (phoWinPrint(self)) to nSize
80166>>>>>        Function_return nSize
80167>>>>>    end_function
80168>>>>>
80168>>>>>    Function DFGetUserDefinedWidth returns number
80170>>>>>        number nSize
80170>>>>>        Get DFGetUserDefinedWidth of (phoWinPrint(self)) to nSize
80171>>>>>        Function_return nSize
80172>>>>>    end_function
80173>>>>>
80173>>>>>
80173>>>>>    Procedure DFSetNumberOfCopies integer iCopies
80175>>>>>        Send DFSetNumberOfCopies of (phoWinPrint(self)) iCopies
80176>>>>>    End_Procedure
80177>>>>>
80177>>>>>    Procedure DFPrinterBinFirstPage integer eBinType
80179>>>>>        Send DFPrinterBinFirstPage of (phoWinPrint(self)) eBinType
80180>>>>>    End_Procedure
80181>>>>>
80181>>>>>    Procedure DFClearPrinter
80183>>>>>        Send DFClearPrinter of (phoWinPrint(self))
80184>>>>>    End_Procedure
80185>>>>>
80185>>>>>    Function DFGetDFColor integer iRed integer iGreen integer iBlue returns integer
80187>>>>>        integer iWPColor
80187>>>>>        Get DFGetDFColor of (phoWinPrint(self)) iRed iGreen iBlue to iWPColor
80188>>>>>        Function_return iWPColor
80189>>>>>    end_function
80190>>>>>
80190>>>>>    Function RGBToWPColor integer iRgb returns integer
80192>>>>>        integer iWPColor
80192>>>>>        Get RGBToWPColor of (phoWinPrint(self)) iRGB to iWPColor
80193>>>>>        Function_return iWPColor
80194>>>>>    end_function
80195>>>>>
80195>>>>>
80195>>>>>End_Class
80196>>>Use CUSTOMER.DD
80196>>>
80196>>>ACTIVATE_VIEW Activate_oCustomerListWP FOR oCustomerListWP
80206>>>>
80206>>>
80206>>>Object oCustomerListWP is a ReportView
80208>>>
80208>>>    Property Boolean pbComments False
80210>>>    
80210>>>    Set Label to "Customer List"
80211>>>    Set Location to 6 6
80212>>>    Set Size to 95 180
80213>>>
80213>>>    Object Customer_DD is a Customer_DataDictionary
80215>>>    End_Object    // Customer_DD
80216>>>
80216>>>    Set Main_DD to Customer_DD
80217>>>    Set Server to Customer_DD
80218>>>
80218>>>    Object oPrintTo is a RadioGroup
80220>>>        Set Size to 50 80
80221>>>        Set Location to 5 5
80222>>>        Set Label to "Send Report to"
80223>>>        Object oScreenRadio is a Radio
80225>>>            Set Label to "Report Viewer"
80226>>>            Set Size to 10 61
80227>>>            Set Location to 15 10
80228>>>            Set Status_Help to "Preview the report to screen"
80229>>>        End_Object    // oScreenRadio
80230>>>
80230>>>        Object oPrinterRadio is a Radio
80232>>>            Set Label to "Printer"
80233>>>            Set Size to 10 37
80234>>>            Set Location to 30 10
80235>>>            Set Status_Help to "Send the report to the default printer"
80236>>>        End_Object    // oPrinterRadio
80237>>>
80237>>>        Function IsToPrinter Returns boolean
80240>>>            integer iRadio
80240>>>            Get Current_radio to iRadio
80241>>>            Function_return (iRadio=1)
80242>>>        End_Function // IsToPrinter
80243>>>
80243>>>    End_Object    // oPrintTo
80244>>>
80244>>>    Object oOrder is a RadioGroup
80246>>>        Set Size to 50 80
80247>>>        Set Location to 5 95
80248>>>        Set Label to "Report Order"
80249>>>        Object oNumberRadio is a Radio
80251>>>            Set Label to "Number"
80252>>>            Set Size to 10 41
80253>>>            Set Location to 15 10
80254>>>            Set Status_Help to "Sort by customer number"
80255>>>        End_Object    // oNumberRadio
80256>>>
80256>>>        Object oNameRadio is a Radio
80258>>>            Set Label to "Name"
80259>>>            Set Size to 10 35
80260>>>            Set Location to 30 10
80261>>>            Set Status_Help to "Sort by customer name"
80262>>>        End_Object    // oNameRadio
80263>>>
80263>>>        Function IsSortedByNumber Returns boolean
80266>>>            integer iRadio
80266>>>            Get Current_radio to iRadio
80267>>>            Function_return (iRadio=1)
80268>>>        End_Function // IsSortedByNumber
80269>>>
80269>>>    End_Object    // oOrder
80270>>>
80270>>>    Object oCommentsCkBx is a CheckBox
80272>>>        Set Label to "Print Comments"
80273>>>        Set Size to 10 65
80274>>>        Set Location to 59 95
80275>>>
80275>>>    End_Object    // oCommentsCkBx
80276>>>
80276>>>    Object oBtnPrint is a Button
80278>>>        Set Label to "Print"
80279>>>        Set Location to 76 7
80280>>>
80280>>>        Procedure OnClick
80283>>>            Send StartReport
80284>>>        End_Procedure
80285>>>
80285>>>    End_Object    // oBtnPrint
80286>>>
80286>>>    Object oBtnCancel is a Button
80288>>>        Set Label to "Cancel"
80289>>>        Set Location to 76 65
80290>>>
80290>>>        Procedure OnClick
80293>>>            Send Close_Panel
80294>>>        End_Procedure
80295>>>
80295>>>    End_Object    // oBtnCancel
80296>>>
80296>>>    Object oBtnPrinterSetup is a Button
80298>>>        Set Label to "Printer Setup"
80299>>>        Set Location to 76 123
80300>>>
80300>>>        Procedure OnClick
80303>>>            Boolean bSetupOk
80303>>>            Get DFPrintSetupDialog of oReport to bSetupOk
80304>>>        End_Procedure
80305>>>
80305>>>    End_Object    // oBtnPrinterSetup
80306>>>
80306>>>    Object oReport is a cWinReport2
80308>>>        Set Report_Title to "Customer List"
80309>>>
80309>>>        // Set DDO, Index and breaks for the report
80309>>>        Set Server to Customer_DD
80310>>>        Set Ordering to 1
80311>>>
80311>>>        // Report_Breaks file.field // no breaks in this report
80311>>>        
80311>>>        Property Boolean pbLandscape false
80313>>>        
80313>>>        Function Starting_Main_Report Returns Integer
80316>>>            Integer iIndex
80316>>>            Boolean bOn bErr
80316>>>        
80316>>>            Send DFSetMetrics wpm_cm
80317>>>            Send DFSetmargins 1 1 1 1
80318>>>        
80318>>>            Get pbComments to bOn
80319>>>            Send DFSetLandscape (if(bOn,True,false))  // This can be used to force a page orientation
80320>>>            Get DFGetLandscape to bOn
80321>>>            Set pbLandscape to bOn
80322>>>        
80322>>>            Forward Get Starting_Main_Report To bErr
80324>>>        
80324>>>            Function_return bErr
80325>>>        End_Function
80326>>>        
80326>>>        // Page_Top is printed first at the top margin of each page
80326>>>        Procedure Page_Top
80329>>>            string sFont
80329>>>            integer iFontSize iStyle
80329>>>        
80329>>>            Move "arial" to sFont
80330>>>            Move 8 to iFontSize
80331>>>            Move (Font_Default) to iStyle
80332>>>        
80332>>>            DFFont sFont
80333>>>            DFFontSize iFontSize
80334>>>            DFBeginHeader DFPageTop
80335>>>                DFHeaderFrame Hdr_NoFrame
80336>>>                DFHeaderPos   Hdr_Left
80337>>>                DFWriteLn ("Page:" * "#pagecount#") iStyle
80338>>>            DFEndHeader
80340>>>        
80340>>>        End_Procedure
80341>>>        
80341>>>        Procedure Page_Header
80344>>>            integer iFill iBorder iStyle
80344>>>            string  sFont sReportTitle
80344>>>            integer iFontSize
80344>>>        
80344>>>            Move "arial" to sFont
80345>>>            Move 16 to iFontSize
80346>>>            Move (Font_bold + rgb_White) to iStyle
80347>>>            Move (rgb_dGrey) to iFill
80348>>>            Move (rgb_dGrey) to iBorder
80349>>>            Get Report_Title to sReportTitle
80350>>>        
80350>>>            DFFont sFont
80351>>>            DFFontSize iFontSize
80352>>>            DFBeginHeader DFPageHeader
80353>>>                DFHeaderPos   Hdr_Left
80354>>>                DFHeaderFrame Hdr_Margins 0.01 iBorder iFill
80355>>>                DFWritelnPos sReportTitle 0.1 iStyle
80356>>>                DFHeaderMargin HM_BottomOuter 0.08
80357>>>            DFEndHeader
80359>>>        
80359>>>        End_Procedure // Page_Header
80360>>>        
80360>>>        Procedure Page_Title
80363>>>            string  sFont
80363>>>            integer iFontSize iHeaderStyle iFill iBorder
80363>>>            Boolean bOn
80363>>>        
80363>>>            Get pbLandscape to bOn
80364>>>        
80364>>>            Move "arial" to sFont
80365>>>            Move 8 to iFontSize
80366>>>            Move (Font_Bold + rgb_dBlue) to iHeaderStyle
80367>>>            Move (rgb_Grey) to iFill
80368>>>            Move (rgb_Grey) to iBorder
80369>>>        
80369>>>            DFFont sFont
80370>>>            DFFontSize iFontSize
80371>>>            DFBeginHeader DFPageTitle
80372>>>                DFHeaderPos   Hdr_Left
80373>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80374>>>                DfHeaderMargin HM_TopInner    0.01
80375>>>                DfHeaderMargin HM_BottomInner 0.01
80376>>>                DFHeaderMargin HM_BottomOuter 0.16
80377>>>        
80377>>>                DfWritePos "Number"                        0.1 (iHeaderStyle)
80378>>>                DfWritePos "Customer Name"                   2 (iHeaderStyle)
80379>>>                DfWritePos "Address"                         7 (iHeaderStyle)
80380>>>                DfWritePos "City"                           12 (iHeaderStyle)
80381>>>                DfWritePos "St."                            15 (iHeaderStyle)
80382>>>                DfWritePos "Zip"                            17 (iHeaderStyle)
80383>>>        
80383>>>                If bOn begin
80385>>>                   DfWritePos "Comments"                    19 (iHeaderStyle)
80386>>>                end
80386>>>>
80386>>>                DfWriteln
80387>>>            DFEndHeader
80389>>>        
80389>>>        End_Procedure // Page_Title
80390>>>        
80390>>>        Procedure Body
80393>>>            string  sFont
80393>>>            integer iFontSize iStyle
80393>>>            Boolean bOn
80393>>>        
80393>>>            Send Update_Status (String(Customer.Customer_number))
80394>>>        
80394>>>            Get pbLandscape to bOn
80395>>>        
80395>>>            Move "arial" to sFont
80396>>>            Move 8 to iFontSize
80397>>>            Move (font_default) to iStyle
80398>>>        
80398>>>            DFFont sFont
80399>>>            DFFontSize iFontSize
80400>>>            DFLineCheck 5
80401>>>        
80401>>>            DfWritePos Customer.Customer_Number       0.8 (iStyle + Font_Right) 0
80402>>>            DfWritePos Customer.Name                    2 iStyle -1 4.98
80403>>>            DfWritePos Customer.Address                 7 iStyle -1 4.98
80404>>>            DfWritePos Customer.City                   12 iStyle -1 3.98
80405>>>            DfWritePos Customer.State                  15 iStyle -1 0.98
80406>>>            DfWritePos Customer.Zip                    17 iStyle -1 1.98
80407>>>        
80407>>>            If bOn begin
80409>>>                DfWritePos Customer.Comments           19 iStyle -1 0
80410>>>                dfWriteln
80411>>>            end
80411>>>>
80411>>>            dfWriteln
80412>>>        End_Procedure  // Body
80413>>>        
80413>>>        // Page_Bottom is printed last at the bottom margin of each page
80413>>>        Procedure Page_Bottom
80416>>>            string sFont
80416>>>            integer iFontSize iBorder iStyle iFill
80416>>>            DateTime dtDT
80416>>>        
80416>>>            Move (CurrentDateTime()) to dtDT
80417>>>        
80417>>>            Move "arial" to sFont
80418>>>            Move 8 to iFontSize
80419>>>            Move (font_default) to iStyle
80420>>>            Move (rgb_dGrey) to iBorder
80421>>>            Move (rgb_White) to iFill
80422>>>        
80422>>>            DFFont sFont
80423>>>            DFFontSize iFontSize
80424>>>            DFBeginHeader DFPageBottom
80425>>>                DFHeaderFrame Hdr_Margins 0 iBorder iFill
80426>>>                DFHeaderPos Hdr_Center  // Write data in center
80427>>>                DFWriteln ("Report Printed on" * string(dtDT)) (iStyle)
80428>>>            DFEndHeader
80430>>>        
80430>>>        End_Procedure // Page_Bottom
80431>>>        
80431>>>    End_Object    // oReport
80432>>>
80432>>>    Procedure StartReport
80435>>>        Boolean bToPrinter bComments bSortByNumber
80435>>>    
80435>>>        // determine if direct print
80435>>>        Get IsToPrinter of oPrintTo to bToPrinter
80436>>>        Set OutPut_Device_Mode of oReport to (If(bToPrinter, PRINT_TO_PRINTER, PRINT_TO_WINDOW))
80437>>>    
80437>>>        // determine if sort order is by number or name
80437>>>        Get IsSortedByNumber of oOrder to bSortByNumber
80438>>>        Set Ordering of oReport to (if(bSortByNumber, 2, 1))
80439>>>    
80439>>>        Get Checked_State of oCommentsCkBx to bComments
80440>>>        Set pbComments to bComments
80441>>>    
80441>>>        // run the report
80441>>>        Send Run_Report of oReport
80442>>>    
80442>>>    End_Procedure // StartReport
80443>>>
80443>>>End_Object    // oCustomerListWP
80444>        Use WinPrint\ItemsPerOrderWP.rv
Including file: WinPrint\ItemsPerOrderWP.rv    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\WinPrint\ItemsPerOrderWP.rv)
80444>>>Use dfrptvw.pkg
80444>>>Use DataDict.pkg
80444>>>Use dfRadio.pkg
80444>>>Use Windows.pkg
80444>>>Use cWinReport2.pkg
80444>>>Use VENDOR.DD
80444>>>Use INVT.DD
80444>>>Use CUSTOMER.DD
80444>>>Use SALESP.DD
80444>>>Use ORDERHEA.DD
80444>>>Use ORDERDTL.DD
80444>>>
80444>>>ACTIVATE_VIEW Activate_oItemsPerOrderWP FOR oItemsPerOrderWP
80454>>>>
80454>>>
80454>>>Object oItemsPerOrderWP is a ReportView
80456>>>    Set Label to "Items per Order"
80457>>>    Set Location to 6 6
80458>>>    Set Size to 84 140
80459>>>
80459>>>    Object Vendor_DD is a Vendor_DataDictionary
80461>>>    End_Object    // Vendor_DD
80462>>>
80462>>>    Object Invt_DD is a Invt_DataDictionary
80464>>>        Set DDO_Server to Vendor_DD
80465>>>    End_Object    // Invt_DD
80466>>>
80466>>>    Object Customer_DD is a Customer_DataDictionary
80468>>>    End_Object    // Customer_DD
80469>>>
80469>>>    Object SalesP_DD is a Salesp_DataDictionary
80471>>>    End_Object    // SalesP_DD
80472>>>
80472>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80474>>>        Set DDO_Server to Customer_DD
80475>>>        Set DDO_Server to SalesP_DD
80476>>>    End_Object    // Orderhea_DD
80477>>>
80477>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80479>>>        Set DDO_Server to Orderhea_DD
80480>>>        Set DDO_Server to Invt_DD
80481>>>    End_Object    // Orderdtl_DD
80482>>>
80482>>>    Object oPrintTo is a RadioGroup
80484>>>        Set Size to 38 131
80485>>>        Set Location to 5 5
80486>>>        Set Label to "Print to"
80487>>>        Object oRadio1 is a Radio
80489>>>            Set Label to "Preview"
80490>>>            Set Size to 10 42
80491>>>            Set Location to 12 6
80492>>>            Set Status_Help to "Prints the report to screen"
80493>>>        End_Object    // oRadio1
80494>>>
80494>>>        Object oRadio2 is a Radio
80496>>>            Set Label to "Printer"
80497>>>            Set Size to 10 42
80498>>>            Set Location to 24 6
80499>>>            Set Status_Help to "Prints the report to printer"
80500>>>        End_Object    // oRadio2
80501>>>
80501>>>    End_Object    // oPrintTo
80502>>>
80502>>>    Object oBtnPrint is a Button
80504>>>        Set Label to "Print"
80505>>>        Set Location to 48 85
80506>>>        Set Status_Help to "Print the Selected report"
80507>>>        Set Default_State to True
80508>>>
80508>>>        Procedure OnClick
80511>>>            Send StartReport
80512>>>        End_Procedure
80513>>>
80513>>>    End_Object    // oBtnPrint
80514>>>
80514>>>    Object oBtnCancel is a Button
80516>>>        Set Label to "Cancel"
80517>>>        Set Location to 66 85
80518>>>        Set Status_Help to "Close this Panel"
80519>>>
80519>>>        Procedure OnClick
80522>>>            Send Close_Panel
80523>>>        End_Procedure
80524>>>
80524>>>    End_Object    // oBtnCancel
80525>>>
80525>>>    Object oOrders is a cWinReport2
80527>>>        Set Report_Title to "Customer Report"
80528>>>
80528>>>        //Main File for the report
80528>>>        Set Server to Orderdtl_DD
80529>>>
80529>>>        //Breaks and Index for the report
80529>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80543>>>        Set Ordering to 1
80544>>>
80544>>>        Function Starting_Main_Report Returns Integer
80547>>>            Integer iRetVal
80547>>>            Send DFSetMetrics WPM_CM
80548>>>            Send DFSetmargins 1 1 1 1
80549>>>            Forward Get Starting_Main_Report To iRetVal
80551>>>            If iRetVal Function_return iRetVal
80554>>>        End_Function
80555>>>
80555>>>        Procedure Page_Top
80558>>>            DFFont "Arial" //  Use Arial
80559>>>            DFFontSize 8
80560>>>            DFBeginHeader DFPageTop
80561>>>                DFHeaderPos   HDR_RIGHT
80562>>>                DFHeaderFrame HDR_NOFRAME
80563>>>                DFWriteLn ("Page:" * "#pagecount#")
80564>>>            DFEndHeader
80566>>>        End_Procedure
80567>>>
80567>>>        Procedure Page_Header
80570>>>            DFFont "Arial"
80571>>>            DFFontSize 14
80572>>>            DFBeginHeader DFPageHeader
80573>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80574>>>                DFHEADERPOS HDR_LEFT
80575>>>                DFHeaderMargin HM_BottomOuter 0.08
80576>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80577>>>            DFEndHeader
80579>>>        End_Procedure
80580>>>
80580>>>        Procedure Page_Title
80583>>>            DFFont "Arial"
80584>>>            DFFontSize 8
80585>>>            DFBeginHeader DFPageTitle
80586>>>                DFHeaderFrame HDR_MARGINs 0 RGB_GREY RGB_GREY
80587>>>                DFHEADERPOS HDR_LEFT
80588>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80589>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80590>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80591>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80592>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
80593>>>                DFWriteln
80594>>>            DFEndHeader
80596>>>        End_Procedure
80597>>>
80597>>>        Procedure SubHeader1
80600>>>
80600>>>            DFFont "Arial" //  Use Arial
80601>>>            DFFontSize 10
80602>>>
80602>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80603>>>
80603>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80604>>>
80604>>>                DFHeaderWrap HDR_WRAP
80605>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80606>>>
80606>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80607>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80608>>>
80608>>>                DFWriteLnPos    ("Order: "+string(Orderhea.ORDER_NUMBER)) 0.1 (FONT_BOLD)
80609>>>
80609>>>              DFEndHeader                     //End and print header
80611>>>
80611>>>        End_Procedure
80612>>>
80612>>>        Procedure Body
80615>>>
80615>>>            DFFont "Arial" //  Use Arial
80616>>>            DFFontSize 8
80617>>>
80617>>>            DFLineCheck 5
80618>>>
80618>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80619>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80620>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80621>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80622>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
80623>>>            DFWriteln ""
80624>>>
80624>>>            // Using SubTotal in WinPrint.
80624>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80625>>>
80625>>>        End_Procedure
80626>>>
80626>>>        Procedure SubTotal1
80629>>>            Number nAmount
80629>>>            Get SubTotal 1 to nAmount
80630>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80631>>>
80631>>>            DFFont "Arial" //  Use Arial
80632>>>            DFFontSize 8
80633>>>            DFBeginHeader DFSubTotal 1
80634>>>
80634>>>                DFHEADERPOS HDR_LEFT
80635>>>                DFHEADERFRAME HDR_NOFRAME
80636>>>
80636>>>                DFWritelnPos  nAmount         16.0      (FONT_BOLD+FONT_RIGHT) 2 0
80637>>>                DFWriteLine DFGR_CURRLINE DFGR_CURRLINE DFGR_RB_MARGIN DFGR_HORI Rgb_dGrey
80638>>>
80638>>>            DFEndHeader
80640>>>
80640>>>        End_Procedure
80641>>>
80641>>>        Procedure Total
80644>>>            Number nTotal
80644>>>            Get SubTotal 2 to nTotal
80645>>>
80645>>>            DFFont "Arial" //  Use Arial
80646>>>            DFFontSize 8
80647>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80648>>>
80648>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80649>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80650>>>
80650>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80651>>>
80651>>>            DFEndHeader                     //End and print header
80653>>>
80653>>>        End_Procedure
80654>>>
80654>>>        Procedure Page_Bottom
80657>>>            DateTime dtDT
80657>>>            Move (CurrentDateTime()) to dtDT
80658>>>
80658>>>            DFFont "Arial" //  Use Arial
80659>>>            DFFontSize 8
80660>>>            DFBeginHeader DFPageBottom
80661>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80662>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80663>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80664>>>            DFEndHeader
80666>>>
80666>>>        End_Procedure
80667>>>
80667>>>    End_Object    // oOrders
80668>>>
80668>>>    // Procedures and functions used by the user interface
80668>>>
80668>>>    //This function is called by the procedure StartReport
80668>>>    Function Print_to_Screen_State Returns Integer
80671>>>        Integer iRad
80671>>>        Get Current_Radio of oPrintTo To iRad
80672>>>        Function_Return (iRad=1)
80673>>>    End_Function
80674>>>
80674>>>    // Use this procedure to do print setup
80674>>>    Procedure SetupReport
80677>>>        Boolean bSetupOk
80677>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80678>>>    End_Procedure
80679>>>
80679>>>    // Use this procedure to start the report
80679>>>    Procedure StartReport
80682>>>        Integer iToPrinter iRepObj
80682>>>        String sVal
80682>>>        Get Report_Object_Id To iRepObj
80683>>>
80683>>>        Get Print_to_Screen_State to iToPrinter
80684>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80687>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80689>>>
80689>>>        Send Run_Report to iRepObj
80690>>>
80690>>>    End_Procedure
80691>>>
80691>>>End_Object    // oItemsPerOrderWP
80692>        Use WinPrint\OrdersWP.rv
Including file: WinPrint\OrdersWP.rv    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\WinPrint\OrdersWP.rv)
80692>>>Use dfrptvw.pkg
80692>>>Use DataDict.pkg
80692>>>Use dfRadio.pkg
80692>>>Use Windows.pkg
80692>>>Use cWinReport2.pkg
80692>>>Use VENDOR.DD
80692>>>Use INVT.DD
80692>>>Use CUSTOMER.DD
80692>>>Use SALESP.DD
80692>>>Use ORDERHEA.DD
80692>>>Use ORDERDTL.DD
80692>>>
80692>>>ACTIVATE_VIEW Activate_oOrdersWP FOR oOrdersWP
80702>>>>
80702>>>
80702>>>Object oOrdersWP is a ReportView
80704>>>    Set Label to "Orders by Order Number"
80705>>>    Set Location to 6 6
80706>>>    Set Size to 46 175
80707>>>
80707>>>    Object Vendor_DD is a Vendor_DataDictionary
80709>>>    End_Object    // Vendor_DD
80710>>>
80710>>>    Object Invt_DD is a Invt_DataDictionary
80712>>>        Set DDO_Server to Vendor_DD
80713>>>    End_Object    // Invt_DD
80714>>>
80714>>>    Object Customer_DD is a Customer_DataDictionary
80716>>>    End_Object    // Customer_DD
80717>>>
80717>>>    Object SalesP_DD is a Salesp_DataDictionary
80719>>>    End_Object    // SalesP_DD
80720>>>
80720>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80722>>>        Set DDO_Server to Customer_DD
80723>>>        Set DDO_Server to SalesP_DD
80724>>>    End_Object    // Orderhea_DD
80725>>>
80725>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80727>>>        Set DDO_Server to Orderhea_DD
80728>>>        Set DDO_Server to Invt_DD
80729>>>    End_Object    // Orderdtl_DD
80730>>>
80730>>>    Object oPrintTo is a RadioGroup
80732>>>        Set Size to 38 105
80733>>>        Set Location to 4 5
80734>>>        Set Label to "Print to"
80735>>>        Object oRadio1 is a Radio
80737>>>            Set Label to "Preview"
80738>>>            Set Size to 10 42
80739>>>            Set Location to 12 6
80740>>>            Set Status_Help to "Prints the report to screen"
80741>>>        End_Object    // oRadio1
80742>>>
80742>>>        Object oRadio2 is a Radio
80744>>>            Set Label to "Printer"
80745>>>            Set Size to 10 42
80746>>>            Set Location to 24 6
80747>>>            Set Status_Help to "Prints the report to printer"
80748>>>        End_Object    // oRadio2
80749>>>
80749>>>    End_Object    // oPrintTo
80750>>>
80750>>>    Object oBtnPrint is a Button
80752>>>        Set Label to "Print"
80753>>>        Set Location to 10 120
80754>>>        Set Status_Help to "Print the Selected report"
80755>>>        Set Default_State to True
80756>>>
80756>>>        Procedure OnClick
80759>>>            Send StartReport
80760>>>        End_Procedure
80761>>>
80761>>>    End_Object    // oBtnPrint
80762>>>
80762>>>    Object oBtnCancel is a Button
80764>>>        Set Label to "Cancel"
80765>>>        Set Location to 28 120
80766>>>        Set Status_Help to "Close this Panel"
80767>>>
80767>>>        Procedure OnClick
80770>>>            Send Close_Panel
80771>>>        End_Procedure
80772>>>
80772>>>    End_Object    // oBtnCancel
80773>>>
80773>>>    Object oOrders is a cWinReport2
80775>>>        Set Report_Title to "Customer Report"
80776>>>
80776>>>        //Main File for the report
80776>>>        Set Server to Orderdtl_DD
80777>>>
80777>>>        //Breaks and Index for the report
80777>>>        Report_Breaks ORDERHEA.ORDER_NUMBER
80791>>>        Report_Index By 1
80793>>>
80793>>>        Function Starting_Main_Report Returns Integer
80796>>>            Integer iRetVal
80796>>>            Set PrintDlgInPreview of WinprintId to True
80797>>>            Send DFSetMetrics To WinPrintId "CM"
80798>>>            Send DFSetmargins To WinPrintId 1 1 1 1
80799>>>            Forward Get Starting_Main_Report To iRetVal
80801>>>            If iRetVal Function_return iRetVal
80804>>>        End_Function
80805>>>
80805>>>        Procedure Page_Top
80808>>>            DFFont "Arial" //  Use Arial
80809>>>            DFFontSize 8
80810>>>            DFBeginHeader DFPageTop
80811>>>                DFHeaderPos   HDR_RIGHT
80812>>>                DFHeaderFrame HDR_NOFRAME
80813>>>                DFWriteLn ("Page:" * "#pagecount#")
80814>>>            DFEndHeader
80816>>>        End_Procedure
80817>>>
80817>>>        Procedure Page_Title
80820>>>            DFFont "Arial"
80821>>>            DFFontSize 14
80822>>>            DFBeginHeader DFPageTitle
80823>>>                DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_DGREY
80824>>>                DFHEADERPOS HDR_LEFT
80825>>>                DFWritelnPos "Orders by Order Number Report" 0.10 (FONT_BOLD+RGB_WHITE)
80826>>>            DFEndHeader
80828>>>        End_Procedure
80829>>>
80829>>>        Procedure SubHeader1
80832>>>
80832>>>            DFFont "Arial" //  Use Arial
80833>>>            DFFontSize 8
80834>>>
80834>>>            DFBeginHeader DFSubHeader 1    //Header of type DFSubHeader
80835>>>
80835>>>                Send Update_Status ("Order:" * String(OrderHea.Order_number))
80836>>>
80836>>>
80836>>>                DFHeaderWrap HDR_WRAP
80837>>>                DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
80838>>>
80838>>>                DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80839>>>                DFHeaderFrame HDR_NoFrame      //Set the box from margin to margin using size 0.05
80840>>>                DFHeaderMargin hm_BottomOuter 0.04
80841>>>
80841>>>                DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
80842>>>                DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
80843>>>                DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
80844>>>                DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
80845>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
80846>>>                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
80847>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
80848>>>                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
80849>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
80850>>>                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
80851>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
80852>>>                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
80853>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
80854>>>                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
80855>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
80856>>>                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
80857>>>                DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
80858>>>                DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
80859>>>                DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
80860>>>                DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
80861>>>                DFFontSize 2
80862>>>                DFWriteLn
80863>>>
80863>>>                DFFontSize 8
80864>>>                DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
80865>>>                DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
80866>>>                DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
80867>>>                DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
80868>>>                DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
80869>>>                DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.40
80870>>>                DFWriteln
80871>>>
80871>>>              DFEndHeader                     //End and print header
80873>>>
80873>>>        End_Procedure
80874>>>
80874>>>        Procedure Body
80877>>>
80877>>>            DFFont "Arial" //  Use Arial
80878>>>            DFFontSize 8
80879>>>
80879>>>            DFLineCheck 5
80880>>>
80880>>>            DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.28
80881>>>            DFWritePos    Invt.DESCRIPTION            4.00    (FONT_DEFAULT)            -1 4.77
80882>>>            DFWritePos    Orderdtl.QTY_ORDERED        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
80883>>>            DFWritePos    Orderdtl.PRICE              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
80884>>>            DFWritePos    Orderdtl.EXTENDED_PRICE     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.40
80885>>>            DFWriteln
80886>>>
80886>>>            // Using SubTotal in WinPrint.
80886>>>            Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
80887>>>
80887>>>        End_Procedure
80888>>>
80888>>>        Procedure SubTotal1
80891>>>            Number nAmount
80891>>>            Get SubTotal 1 to nAmount
80892>>>            Send Add_SubTotal 2 nAmount // subtotal 2 is total
80893>>>
80893>>>            DFFont "Arial" //  Use Arial
80894>>>            DFFontSize 8
80895>>>            DFBeginHeader DFSubTotal 1
80896>>>
80896>>>                DFHEADERPOS HDR_LEFT
80897>>>                  DFHeaderFrame hdr_margins 0.01 rgb_grey rgb_Grey
80898>>>                  dfHeaderMargin hm_bottomOuter 0.10
80899>>>                  dfHeaderMargin hm_bottomInner 0.01
80900>>>                  dfHeaderMargin hm_TopInner    0.01
80901>>>
80901>>>                DFWritelnPos  nAmount         16.0      (Font_BOLD+FONT_RIGHT) 2 0
80902>>>            DFEndHeader
80904>>>
80904>>>        End_Procedure
80905>>>
80905>>>        Procedure Total
80908>>>            Number nTotal
80908>>>            Get SubTotal 2 to nTotal
80909>>>
80909>>>            DFFont "Arial" //  Use Arial
80910>>>            DFFontSize 8
80911>>>            DFBeginHeader DFTotal           //Header of type DFTotal
80912>>>
80912>>>              DFHeaderPos   HDR_LEFT         //Write data from left margin in the header
80913>>>              DFHeaderFrame HDR_MARGINs 0 RGB_DGREY RGB_GREY //rgb_Cyan rgb_Cyan
80914>>>
80914>>>              DFWritelnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
80915>>>
80915>>>            DFEndHeader                     //End and print header
80917>>>
80917>>>        End_Procedure
80918>>>
80918>>>        Procedure Page_Bottom
80921>>>            DateTime dtDT
80921>>>            Move (CurrentDateTime()) to dtDT
80922>>>
80922>>>            DFFont "Arial" //  Use Arial
80923>>>            DFFontSize 8
80924>>>            DFBeginHeader DFPageBottom
80925>>>                DFHeaderPos   HDR_CENTER       //Write data in center
80926>>>                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
80927>>>                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
80928>>>            DFEndHeader
80930>>>
80930>>>        End_Procedure
80931>>>
80931>>>    End_Object    // oOrders
80932>>>
80932>>>    // Procedures and functions used by the user interface
80932>>>
80932>>>    //This function is called by the procedure StartReport
80932>>>    Function Print_to_Screen_State Returns Integer
80935>>>        Integer iRad
80935>>>        Get Current_Radio of oPrintTo To iRad
80936>>>        Function_Return (iRad=1)
80937>>>    End_Function
80938>>>
80938>>>    // Use this procedure to do print setup
80938>>>    Procedure SetupReport
80941>>>        Boolean bSetupOk
80941>>>        Get DFPrintSetupDialog of (Report_Object_Id(Self)) to bSetupOk
80942>>>    End_Procedure
80943>>>
80943>>>    // Use this procedure to start the report
80943>>>    Procedure StartReport
80946>>>        Integer iToPrinter iRepObj
80946>>>        String sVal
80946>>>        Get Report_Object_Id To iRepObj
80947>>>
80947>>>        Get Print_to_Screen_State to iToPrinter
80948>>>        If iToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
80951>>>        Else Set OutPut_Device_Mode to PRINT_TO_WINDOW
80953>>>
80953>>>        Send Run_Report to iRepObj
80954>>>
80954>>>    End_Procedure
80955>>>
80955>>>End_Object    // oOrdersWP
80956>        Use WinPrint\OrdersByCustomerWP.rv
Including file: WinPrint\OrdersByCustomerWP.rv    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\WinPrint\OrdersByCustomerWP.rv)
80956>>>Use dfrptvw.pkg
80956>>>Use DataDict.pkg
80956>>>Use dfRadio.pkg
80956>>>Use Windows.pkg
80956>>>Use cWinReport2.pkg
80956>>>Use VENDOR.DD
80956>>>Use INVT.DD
80956>>>Use CUSTOMER.DD
80956>>>Use SALESP.DD
80956>>>Use ORDERHEA.DD
80956>>>Use ORDERDTL.DD
80956>>>
80956>>>ACTIVATE_VIEW Activate_oOrdersByCustomerWP FOR oOrdersByCustomerWP
80966>>>>
80966>>>
80966>>>Object oOrdersByCustomerWP is a ReportView
80968>>>
80968>>>    property integer main_dd
80970>>>    Property integer server
80972>>>
80972>>>    Set Label to "Orders by Customer"
80973>>>    Set Location to 6 6
80974>>>    Set Size to 110 174
80975>>>
80975>>>    Object Vendor_DD is a Vendor_DataDictionary
80977>>>    End_Object    // Vendor_DD
80978>>>
80978>>>    Object Invt_DD is a Invt_DataDictionary
80980>>>        Set DDO_Server to Vendor_DD
80981>>>    End_Object    // Invt_DD
80982>>>
80982>>>    Object Customer_DD is a Customer_DataDictionary
80984>>>    End_Object    // Customer_DD
80985>>>
80985>>>    Object SalesP_DD is a Salesp_DataDictionary
80987>>>    End_Object    // SalesP_DD
80988>>>
80988>>>    Object Orderhea_DD is a Orderhea_DataDictionary
80990>>>        Set DDO_Server to Customer_DD
80991>>>        Set DDO_Server to SalesP_DD
80992>>>        Set Constrain_File to Customer.File_Number
80993>>>    End_Object    // Orderhea_DD
80994>>>
80994>>>    Object Orderdtl_DD is a Orderdtl_DataDictionary
80996>>>        Set DDO_Server to Orderhea_DD
80997>>>        Set DDO_Server to Invt_DD
80998>>>        Set Constrain_File to Orderhea.File_Number
80999>>>    End_Object    // Orderdtl_DD
81000>>>
81000>>>    Set Main_DD to Customer_DD
81001>>>    Set Server to Customer_DD
81002>>>
81002>>>    Object oPrintTo is a RadioGroup
81004>>>        Set Size to 38 105
81005>>>        Set Location to 5 5
81006>>>        Set Label to "Print to"
81007>>>        Object oRadio1 is a Radio
81009>>>            Set Label to "Preview"
81010>>>            Set Size to 10 42
81011>>>            Set Location to 12 6
81012>>>            Set Status_Help to "Prints the report to screen"
81013>>>        End_Object    // oRadio1
81014>>>
81014>>>        Object oRadio2 is a Radio
81016>>>            Set Label to "Printer"
81017>>>            Set Size to 10 42
81018>>>            Set Location to 24 6
81019>>>            Set Status_Help to "Prints the report to printer"
81020>>>        End_Object    // oRadio2
81021>>>
81021>>>    End_Object    // oPrintTo
81022>>>
81022>>>    Object oReportOrder is a RadioGroup
81024>>>        Set Size to 38 105
81025>>>        Set Location to 45 5
81026>>>        Set Label to "Report Order"
81027>>>        Object oRadio3 is a Radio
81029>>>            Set Label to "Customer Number"
81030>>>            Set Size to 10 73
81031>>>            Set Location to 12 6
81032>>>            Set Status_Help to "Prints the report to screen"
81033>>>        End_Object    // oRadio3
81034>>>
81034>>>        Object oRadio4 is a Radio
81036>>>            Set Label to "Customer Name"
81037>>>            Set Size to 10 67
81038>>>            Set Location to 24 6
81039>>>            Set Status_Help to "Prints the report to printer"
81040>>>        End_Object    // oRadio4
81041>>>
81041>>>        Function OrderByNumber returns boolean
81044>>>            function_return (current_radio(self)=0)
81045>>>        end_function
81046>>>        
81046>>>    End_Object    // oReportOrder
81047>>>
81047>>>    Object oSetupButton is a Button
81049>>>        Set Label to "Printer Setup"
81050>>>        Set Location to 7 120
81051>>>
81051>>>        Procedure OnClick
81054>>>            Boolean bSetupOk
81054>>>            Get DFPrintSetupDialog of oOrders to bSetupOk
81055>>>        End_Procedure
81056>>>
81056>>>    End_Object    // oSetupButton
81057>>>
81057>>>    Object oBtnPrint is a Button
81059>>>        Set Label to "Print"
81060>>>        Set Location to 49 120
81061>>>        Set Status_Help to "Print the Selected report"
81062>>>        Set Default_State to True
81063>>>
81063>>>        Procedure OnClick
81066>>>            boolean bByNumber
81066>>>            Get OrderByNumber of oReportOrder  to bByNumber
81067>>>            Set Ordering of oOrders to (if(bByNumber,1,2))
81068>>>            Send StartReport
81069>>>        End_Procedure
81070>>>
81070>>>    End_Object    // oBtnPrint
81071>>>
81071>>>    Object oBtnCancel is a Button
81073>>>        Set Label to "Cancel"
81074>>>        Set Location to 67 120
81075>>>        Set Status_Help to "Close this Panel"
81076>>>
81076>>>        Procedure OnClick
81079>>>            Send Close_Panel
81080>>>        End_Procedure
81081>>>
81081>>>    End_Object    // oBtnCancel
81082>>>
81082>>>    Object oOnePageCkBx is a CheckBox
81084>>>        Set Label to "New Page for Each Customer"
81085>>>        Set Size to 10 110
81086>>>        Set Location to 92 6
81087>>>
81087>>>        Procedure OnChange
81090>>>            Boolean bChecked
81090>>>        
81090>>>            Get Checked_State To bChecked
81091>>>        End_Procedure // OnChange
81092>>>
81092>>>    End_Object    // oOnePageCkBx
81093>>>
81093>>>    Object oOrders is a cWinReport2
81095>>>
81095>>>        Property Boolean pbOnePagePerCust False
81097>>>        
81097>>>        Set Report_Title to "Printing all Orders by Customer"
81098>>>        
81098>>>        //Main File for the report
81098>>>        Set Server to Customer_DD
81099>>>        //Breaks and Index for the report
81099>>>        Report_Breaks Customer.Customer_number
81113>>>        
81113>>>        Set Ordering to 2
81114>>>        
81114>>>        Object oOrderHea is a cWinReport2
81116>>>
81116>>>            Set Server to Orderhea_DD
81117>>>            Report_Breaks ORDERHEA.Order_number
81131>>>            set Ordering to 2
81132>>>
81132>>>            Object oOrderDtl is a cWinReport2
81134>>>
81134>>>                Set Server to Orderdtl_DD
81135>>>                Report_Breaks Orderhea.Order_Number
81149>>>                Set Ordering to 1
81150>>>                
81150>>>                Procedure SubHeader1
81153>>>                      Send Update_Status (Customer.Name - '/' - string(Orderhea.Order_number))
81154>>>                
81154>>>                      DFFont "Arial"
81155>>>                      DFFontSize 8
81156>>>                
81156>>>                      DFBeginHeader DFSubHeader 2
81157>>>                        DFHeaderFrame hdr_NoFrame
81158>>>                        DFHeaderPos   hdr_Left
81159>>>                        DFHeaderWrap hdr_Wrap
81160>>>                        DfHeaderMargin hm_BottomOuter 0.04
81161>>>                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81162>>>                
81162>>>                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81163>>>                        DFWritelnPos  Orderhea.Order_number       4.0   (FONT_DEFAULT)
81164>>>                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81165>>>                        DFWritelnPos  Orderhea.Order_date         4.0   (FONT_DEFAULT)
81166>>>                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81167>>>                        DFWritelnPos  Orderhea.Terms              4.0   (FONT_DEFAULT)
81168>>>                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81169>>>                        DFWritelnPos  Orderhea.Ship_via           4.0   (FONT_DEFAULT)
81170>>>                
81170>>>                        DfWriteRect dfgr_CurrLine 0 0.34 dfgr_rb_Margin rgb_Grey 0.0 dfgr_NoWrap rgb_Grey
81171>>>                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81172>>>                        DFWritePos    "Description"             4.00    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81173>>>                        DFWritePos    "Qty Ordered"             11.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81174>>>                        DFWritePos    "Price"                   13.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81175>>>                        DFWritePos    "Extended Price"          16.0    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.50
81176>>>                        DFWriteln
81177>>>                
81177>>>                      DFEndHeader
81179>>>                
81179>>>                End_Procedure
81180>>>                
81180>>>                Procedure Body // order detail body
81183>>>                
81183>>>                    DFFont "Arial"
81184>>>                    DFFontSize 8
81185>>>                
81185>>>                    DFLineCheck 5
81186>>>                
81186>>>                    DFWritePos    Invt.Item_id                0.1     (FONT_DEFAULT)            -1 2.28
81187>>>                    DFWritePos    Invt.Description            4.00    (FONT_DEFAULT)            -1 4.77
81188>>>                    DFWritePos    Orderdtl.Qty_ordered        11.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81189>>>                    DFWritePos    Orderdtl.Price              13.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81190>>>                    DFWritePos    Orderdtl.Extended_price     16.0    (FONT_DEFAULT+FONT_RIGHT)  2 2.50
81191>>>                    DFWriteln
81192>>>                
81192>>>                    // Using rectotal in WinPrint.
81192>>>                    Send Add_SubTotal 1 (Orderdtl.Extended_price)
81193>>>                
81193>>>                End_Procedure
81194>>>                
81194>>>                Procedure SubTotal1 // order total
81197>>>                    Number nAmount
81197>>>                
81197>>>                    Get SubTotal 1 to nAmount
81198>>>                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81199>>>                
81199>>>                    DFFont "Arial"
81200>>>                    DFFontSize 8
81201>>>                    DFBeginHeader DFSubTotal 2
81202>>>                        DFHeaderPos hdr_Left
81203>>>                        DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81204>>>                        DfHeaderMargin hm_TopInner 0.02
81205>>>                        DfHeaderMargin hm_BottomInner 0.02
81206>>>                        DfHeaderMargin hm_BottomOuter 0.08
81207>>>                        DfHeaderMargin hm_TopOuter 0.04
81208>>>                
81208>>>                        DFWritePos   "Order Total:"  14.0  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81209>>>                        DFWritelnPos nAmount         16.0   (FONT_RIGHT) 2
81210>>>                    DFEndHeader
81212>>>                
81212>>>                End_Procedure
81213>>>                
81213>>>            End_Object    // oOrderDtl
81214>>>
81214>>>        End_Object    // oOrderHea
81215>>>        
81215>>>        Function Starting_Main_Report Returns Integer
81218>>>            Integer iRetVal bBreak
81218>>>            Get OnePagePerCust to bBreak
81219>>>            Set pbOnePagePerCust to bBreak
81220>>>            Send DFSetMetrics to WinPrintId "CM"
81221>>>            Send DFSetmargins to WinPrintId 1 1 1 1
81222>>>            Forward Get Starting_Main_Report to iRetVal
81224>>>            If iRetVal Function_Return iRetVal
81227>>>        End_Function
81228>>>        
81228>>>        Procedure Page_Top
81231>>>            DFFont "Arial"
81232>>>            DFFontSize 8
81233>>>            DFBeginHeader DFPageTop
81234>>>                DFHeaderFrame hdr_NoFrame
81235>>>                DFHeaderPos   hdr_Right
81236>>>        
81236>>>                DFWriteLn ("Page:" * "#pagecount#")
81237>>>            DFEndHeader
81239>>>        End_Procedure
81240>>>        
81240>>>        Procedure Page_Title
81243>>>            DFFont "Arial"
81244>>>            DFFontSize 14
81245>>>            DFBeginHeader DFPageTitle
81246>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_dGrey
81247>>>                DFHeaderPos hdr_Left
81248>>>                DFHeaderMargin hm_BottomOuter 0.08
81249>>>        
81249>>>                DFWriteLnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81250>>>            DFEndHeader
81252>>>        End_Procedure
81253>>>        
81253>>>        Procedure SubHeader1
81256>>>            Integer iClr
81256>>>            DFFont "Arial" //  Use Arial
81257>>>            DFFontSize 8
81258>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr  can be used instead
81259>>>        
81259>>>            DFBeginHeader DFSubHeader 1 // customer sub-header
81260>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81261>>>                DFHeaderPos   hdr_Left
81262>>>                DFHeaderWrap hdr_Wrap
81263>>>                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81264>>>        
81264>>>                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81265>>>                DFWriteLnPos  Customer.Customer_number    4.0
81266>>>                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81267>>>                DFWriteLnPos  Customer.Name               4.0   (FONT_DEFAULT)
81268>>>                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81269>>>                DFWriteLnPos  Customer.Address            4.0   (FONT_DEFAULT)
81270>>>                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81271>>>                DFWriteLnPos  Customer.City               4.0   (FONT_DEFAULT)
81272>>>                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81273>>>                DFWriteLnPos  Customer.State              4.0   (FONT_DEFAULT)
81274>>>                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81275>>>                DFWriteLnPos  Customer.Zip                4.0   (FONT_DEFAULT)
81276>>>            DFEndHeader
81278>>>        End_Procedure
81279>>>        
81279>>>        Procedure SubTotal1 // customer total
81282>>>            Number nAmount
81282>>>            Integer iClr
81282>>>            Boolean bBreak
81282>>>        
81282>>>            Get SubTotal 2 to nAmount
81283>>>            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81284>>>        
81284>>>            Get DFGetDFColor of winprintId  242 242 242 to iClr // Move -218959360 to iClr   can be used instead
81285>>>        
81285>>>            DFFont "Arial" //  Use Arial
81286>>>            DFFontSize 8
81287>>>            DFBeginHeader DFSubTotal 1
81288>>>                DFHeaderPos hdr_Left
81289>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81290>>>                DFHeaderMargin hm_BottomOuter 0.16
81291>>>        
81291>>>                DFWritePos   "Customer Total:"  14.0 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81292>>>                DFWriteLnPos nAmount 16.0              (FONT_RIGHT+FONT_Bold) 2 0
81293>>>            DFEndHeader
81295>>>            Get pbOnePagePerCust to bBreak
81296>>>            If bBreak Begin
81298>>>                Send DFNew_Page
81299>>>            End
81299>>>>
81299>>>        End_Procedure
81300>>>        
81300>>>        Procedure Total // total of all customers
81303>>>            Number nTotal
81303>>>            Get SubTotal 3 to nTotal
81304>>>        
81304>>>            DFFont "Arial" //  Use Arial
81305>>>            DFFontSize 10
81306>>>        
81306>>>            DFBeginHeader DFTotal
81307>>>        
81307>>>                DFHeaderPos   hdr_Left
81308>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey rgb_Grey
81309>>>        
81309>>>                DFWritePos    "Grand Total:"  14.0        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81310>>>                DFWriteLnPos   nTotal         16.0      (FONT_BOLD+FONT_RIGHT) 2
81311>>>        
81311>>>            DFEndHeader                     //End and print header
81313>>>        
81313>>>        End_Procedure
81314>>>        
81314>>>        Procedure Page_Bottom
81317>>>            DateTime dtDT
81317>>>            Move (CurrentDateTime()) to dtDT
81318>>>        
81318>>>            DFFont "Arial"
81319>>>            DFFontSize 8
81320>>>            DFBeginHeader DFPageBottom
81321>>>                DFHeaderPos   hdr_Center
81322>>>                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey
81323>>>                DFWriteLn   ("Report Printed on: " +String(dtDT)) (rgb_dBlue)
81324>>>            DFEndHeader
81326>>>        
81326>>>        End_Procedure
81327>>>
81327>>>    End_Object    // oOrders
81328>>>
81328>>>    // Procedures and functions used by the user interface
81328>>>    
81328>>>    //This function is called by the procedure StartReport
81328>>>    Function Print_to_Screen_State Returns Integer
81331>>>        Integer iRad
81331>>>        Get Current_Radio of oPrintTo To iRad
81332>>>        Function_Return (iRad=1)
81333>>>    End_Function
81334>>>    
81334>>>    // Use this procedure to do print setup
81334>>>    Procedure SetupReport
81337>>>        Boolean bSetupOk
81337>>>        Get DFPrintSetupDialog of oOrders to bSetupOk
81338>>>    End_Procedure
81339>>>    
81339>>>    // Use this procedure to start the report
81339>>>    Procedure StartReport
81342>>>        Boolean bToPrinter
81342>>>        String sVal
81342>>>        Get Print_to_Screen_State to bToPrinter
81343>>>        If bToPrinter Set OutPut_Device_Mode to PRINT_TO_PRINTER
81346>>>        Else          Set OutPut_Device_Mode to PRINT_TO_WINDOW
81348>>>    
81348>>>        Send Run_Report of oOrders
81349>>>    
81349>>>    End_Procedure
81350>>>    
81350>>>    Function OnePagePerCust returns boolean
81353>>>        boolean bBreak
81353>>>        Get checked_state of oOnePageCkBx to bBreak
81354>>>        Function_return bBreak
81355>>>    end_function
81356>>>    
81356>>>    // The Report
81356>>>    //    Object oOrders is a cWinReport2
81356>>>    //    //Object oOrders is a WinReport
81356>>>    
81356>>>    //        Property Boolean pbOnePagePerCust False
81356>>>    //        Set Report_Title to "Printing all Orders by Customer"
81356>>>    
81356>>>    //        //Main File for the report
81356>>>    //        Set Server to Customer_DD
81356>>>    //        //Breaks and Index for the report
81356>>>    //        Report_Breaks ORDERHEA.CUSTOMER_NUMBER
81356>>>    //        Set Ordering to 2
81356>>>    
81356>>>    //        Function Starting_Main_Report Returns Integer
81356>>>    //            Integer iRetVal bBreak
81356>>>    //            Get OnePagePerCust to bBreak
81356>>>    //            Set pbOnePagePerCust to bBreak
81356>>>    //            Send DFSetMetrics To WinPrintId "CM"
81356>>>    //            Send DFSetmargins To WinPrintId 1 1 1 1
81356>>>    //            Forward Get Starting_Main_Report To iRetVal
81356>>>    //            If iRetVal Function_return iRetVal
81356>>>    //        End_Function
81356>>>    
81356>>>    //        Procedure Page_Top
81356>>>    //            DFFont "Arial"
81356>>>    //            DFFontSize 8
81356>>>    //            DFBeginHeader DFPageTop
81356>>>    //                DFHeaderFrame HDR_NOFRAME
81356>>>    //                DFHeaderPos   HDR_RIGHT
81356>>>    
81356>>>    //                DFWriteLn ("Page:" * "#pagecount#")
81356>>>    //            DFEndHeader
81356>>>    //        End_Procedure
81356>>>    
81356>>>    //        Procedure Page_Title
81356>>>    //            DFFont "Arial"
81356>>>    //            DFFontSize 14
81356>>>    //            DFBeginHeader DFPageTitle
81356>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_DGREY
81356>>>    //                DFHEADERPOS HDR_LEFT
81356>>>    //                DfHeaderMargin hm_BottomOuter 0.08
81356>>>    
81356>>>    //                DFWritelnPos "Orders by Customer Report" 0.10 (FONT_BOLD+RGB_WHITE)
81356>>>    //            DFEndHeader
81356>>>    //        End_Procedure
81356>>>    
81356>>>    //        Procedure SubHeader1
81356>>>    //            integer iClr
81356>>>    //            DFFont "Arial" //  Use Arial
81356>>>    //            DFFontSize 8
81356>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81356>>>    //            Move -218959360 to iClr
81356>>>    
81356>>>    //            DFBeginHeader DFSubHeader 1 // customer sub-header
81356>>>    //                DFHeaderFrame hdr_Margins 0.01 rgb_dGrey iClr
81356>>>    //                DFHeaderPos   HDR_LEFT
81356>>>    //                DFHeaderWrap HDR_WRAP
81356>>>    //                DFHeaderLineCheck 10 //Check that the header + 10 lines fits on the page, if not wrap
81356>>>    
81356>>>    //                DFWritePos    "Customer Number"         0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.CUSTOMER_NUMBER    4.0
81356>>>    //                DFWritePos    "Name"                    0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.NAME               4.0   (FONT_DEFAULT)
81356>>>    //                DFWritePos    "Address"                 0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.ADDRESS            4.0   (FONT_DEFAULT)
81356>>>    //                DFWritePos    "City"                    0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.CITY               4.0   (FONT_DEFAULT)
81356>>>    //                DFWritePos    "State"                   0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.STATE              4.0   (FONT_DEFAULT)
81356>>>    //                DFWritePos    "Zip"                     0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                DFWritelnPos  Customer.ZIP                4.0   (FONT_DEFAULT)
81356>>>    //            DFEndHeader
81356>>>    //        End_Procedure
81356>>>    
81356>>>    //        Object oOrderHea is a cWinReport2
81356>>>    //    //        Object oOrders is a WinReport
81356>>>    
81356>>>    //            Set Server to Orderhea_DD
81356>>>    //            Report_Breaks ORDERHEA.Order_number
81356>>>    //            set Ordering to 2
81356>>>    
81356>>>    //            Object oOrderDtl is a cWinReport2
81356>>>    //    //            Object oOrders is a WinReport
81356>>>    
81356>>>    //                Set Server to Orderdtl_DD
81356>>>    //                Report_Breaks ORDERHEA.Order_Number
81356>>>    //                Set Ordering to 1
81356>>>    
81356>>>    //                Procedure SubHeader1 // order sub-header
81356>>>    //                      Send Update_Status (Customer.Name - '/' - string(Orderhea.order_number))
81356>>>    
81356>>>    //                      DFFont "Arial"
81356>>>    //                      DFFontSize 8
81356>>>    
81356>>>    //                      DFBeginHeader DFSubHeader 2
81356>>>    //                        DFHeaderFrame hdr_NoFrame
81356>>>    //                        DFHeaderPos   HDR_LEFT
81356>>>    //                        DFHeaderWrap HDR_WRAP
81356>>>    //                        DfHeaderMargin hm_BottomOuter 0.04
81356>>>    //                        DFHeaderLineCheck 5            //Check that the header + 5 lines fits on the page, if not wrap
81356>>>    
81356>>>    //                        DFWritePos    "Order Number"            0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                        DFWritelnPos  Orderhea.ORDER_NUMBER       4.0   (FONT_DEFAULT)
81356>>>    //                        DFWritePos    "Order Date"              0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                        DFWritelnPos  Orderhea.ORDER_DATE         4.0   (FONT_DEFAULT)
81356>>>    //                        DFWritePos    "Terms"                   0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                        DFWritelnPos  Orderhea.TERMS              4.0   (FONT_DEFAULT)
81356>>>    //                        DFWritePos    "Ship Via"                0.10  (FONT_BOLD+RGB_DBLUE)
81356>>>    //                        DFWritelnPos  Orderhea.SHIP_VIA           4.0   (FONT_DEFAULT)
81356>>>    
81356>>>    //                        DfWriteRect DFGR_CURRLINE 0 0.34 DFGR_RB_MARGIN RGB_GREY 0.0 dfgr_noWrap RGB_GREY
81356>>>    //                        DFWritePos    "Item Id"                 0.1     (FONT_BOLD+RGB_DBLUE)            -1 1.36
81356>>>    //                        DFWritePos    "Description"             2.36    (FONT_BOLD+RGB_DBLUE)            -1 4.77
81356>>>    //                        DFWritePos    "Qty Ordered"             9.5     (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.87
81356>>>    //                        DFWritePos    "Price"                   11.22   (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 1.22
81356>>>    //                        DFWritePos    "Extended Price"          14.1    (FONT_BOLD+FONT_RIGHT+RGB_DBLUE) -1 2.38
81356>>>    //                        DFWriteln
81356>>>    
81356>>>    //                      DFEndHeader
81356>>>    
81356>>>    //                End_Procedure
81356>>>    
81356>>>    //                Procedure Body // order detail body
81356>>>    
81356>>>    //                    DFFont "Arial"
81356>>>    //                    DFFontSize 8
81356>>>    
81356>>>    //                    DFLineCheck 5
81356>>>    
81356>>>    //                    DFWritePos    Invt.ITEM_ID                0.1     (FONT_DEFAULT)            -1 2.24
81356>>>    //                    DFWritePos    Invt.DESCRIPTION            2.36    (FONT_DEFAULT)            -1 4.77
81356>>>    //                    DFWritePos    Orderdtl.QTY_ORDERED        9.5     (FONT_DEFAULT+FONT_RIGHT)  0 1.87
81356>>>    //                    DFWritePos    Orderdtl.PRICE              11.22   (FONT_DEFAULT+FONT_RIGHT)  2 1.22
81356>>>    //                    DFWritePos    Orderdtl.EXTENDED_PRICE     14.1    (FONT_DEFAULT+FONT_RIGHT)  2 2.38
81356>>>    //                    DFWriteln
81356>>>    
81356>>>    //                    // Using rectotal in WinPrint.
81356>>>    //                    Send Add_SubTotal 1 (Orderdtl.EXTENDED_PRICE)
81356>>>    
81356>>>    //                End_Procedure
81356>>>    
81356>>>    //                Procedure SubTotal1 // order total
81356>>>    //                    Number nAmount
81356>>>    
81356>>>    //                    Get SubTotal 1 to nAmount
81356>>>    //                    Send Add_SubTotal 2 nAmount // subtotal 2 is customer total
81356>>>    
81356>>>    //                    DFFont "Arial"
81356>>>    //                    DFFontSize 8
81356>>>    //                    DFBeginHeader DFSubTotal 2
81356>>>    //                        DFHEADERPOS HDR_LEFT
81356>>>    //                        DFHEADERFRAME HDR_Margins 0.01 rgb_dGrey rgb_Grey
81356>>>    //                        DfHeaderMargin hm_TopInner 0.02
81356>>>    //                        DfHeaderMargin hm_BottomInner 0.02
81356>>>    //                        DfHeaderMargin hm_BottomOuter 0.08
81356>>>    //                        DfHeaderMargin hm_TopOuter 0.04
81356>>>    
81356>>>    //                        DFWritePos   "Order Total:"  12.00  (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81356>>>    //                        DFWritelnPos nAmount         14.1   (FONT_RIGHT) 2
81356>>>    //                    DFEndHeader
81356>>>    
81356>>>    //                End_Procedure
81356>>>    
81356>>>    //            end_object // orderdtl nested report
81356>>>    
81356>>>    //        end_object // orderhea nested report
81356>>>    
81356>>>    //        Procedure SubTotal1 // customer total
81356>>>    //            Number nAmount
81356>>>    //            integer iClr
81356>>>    //            Boolean bBreak
81356>>>    
81356>>>    //            Get SubTotal 2 to nAmount
81356>>>    //            Send Add_SubTotal 3 nAmount // subtotal 3 is total of all
81356>>>    
81356>>>    //            //Get DFGetDFColor of winprintId  242 242 242 to iClr // doesn't work YET
81356>>>    //            Move -218959360 to iClr
81356>>>    
81356>>>    //            DFFont "Arial" //  Use Arial
81356>>>    //            DFFontSize 8
81356>>>    //            DFBeginHeader DFSubTotal 1
81356>>>    //                DFHEADERPOS HDR_LEFT
81356>>>    //                DFHeaderFrame HDR_Margins 0.01 RGB_DGREY iClr
81356>>>    //                DfHeaderMargin hm_BottomOuter 0.16
81356>>>    
81356>>>    //                DFWritePos   "Customer Total:"  12.00 (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81356>>>    //                DFWritelnPos nAmount 14.1              (FONT_RIGHT+FONT_Bold) 2 0
81356>>>    //            DFEndHeader
81356>>>    //            Get pbOnePagePerCust to bBreak
81356>>>    //            If bBreak Begin
81356>>>    //                send DFNew_Page
81356>>>    //            end
81356>>>    //        end_procedure
81356>>>    
81356>>>    //        Procedure Total // total of all customers
81356>>>    //            Number nTotal
81356>>>    //            Get SubTotal 3 to nTotal
81356>>>    
81356>>>    //            DFFont "Arial" //  Use Arial
81356>>>    //            DFFontSize 10
81356>>>    
81356>>>    //            DFBeginHeader DFTotal
81356>>>    
81356>>>    //                DFHeaderPos   HDR_LEFT
81356>>>    //                DFHeaderFrame HDR_MARGINs 0.01 RGB_DGREY RGB_GREY
81356>>>    
81356>>>    //                DFWritePos    "Grand Total:"  12        (FONT_BOLD+RGB_DBLUE+FONT_RIGHT)
81356>>>    //                DFWritelnPos   nTotal         14.1      (FONT_BOLD+FONT_RIGHT) 2
81356>>>    
81356>>>    //            DFEndHeader                     //End and print header
81356>>>    
81356>>>    //        End_Procedure
81356>>>    
81356>>>    //        Procedure Page_Bottom
81356>>>    //            DateTime dtDT
81356>>>    //            Move (CurrentDateTime()) to dtDT
81356>>>    
81356>>>    //            DFFont "Arial"
81356>>>    //            DFFontSize 8
81356>>>    //            DFBeginHeader DFPageBottom
81356>>>    //                DFHeaderPos   HDR_CENTER
81356>>>    //                DFHeaderFrame HDR_MARGINS 0.01 rgb_dGrey
81356>>>    //                DFWriteLn   ("Report Printed on: " +string(dtDT)) (rgb_dBlue)
81356>>>    //            DFEndHeader
81356>>>    
81356>>>    //        End_Procedure
81356>>>    
81356>>>    //    End_Object // customer main report
81356>>>    
81356>>>End_Object    // oOrdersByCustomerWP
81357>
81357>        On_Key Key_Ctrl+Key_1 Send Activate_oCustomerView
81358>        On_Key Key_Ctrl+Key_2 Send Activate_oInventoryView
81359>        On_Key Key_Ctrl+Key_3 Send Activate_oOrderEntryView
81360>        On_Key Key_Ctrl+Key_4 Send Activate_oSalesPersonView
81361>        On_Key Key_Ctrl+Key_5 Send Activate_oVendorView
81362>        On_Key Key_Ctrl+Key_6 Send Activate_oCustomerListWP
81363>        On_Key Key_Ctrl+Key_7 Send Activate_oItemsPerOrderWP
81364>        On_Key Key_Ctrl+Key_8 Send Activate_oOrdersByCustomerWP
81365>        On_Key Key_Ctrl+Key_9 Send Activate_oOrdersWP
81366>
81366>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\StdAbout.pkg)
81366>>>//************************************************************************
81366>>>// Confidential Trade Secret.
81366>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81366>>>// as an unpublished work.  All rights reserved.
81366>>>// DataFlex is a registered trademark of Data Access Corporation.
81366>>>//
81366>>>//************************************************************************
81366>>>//************************************************************************
81366>>>//
81366>>>// $File name  : StdAbout.pkg
81366>>>// $File title : Standard about object package for VDF
81366>>>// Notice      :
81366>>>// $Author(s)  : John Tuohy
81366>>>//
81366>>>// $Rev History
81366>>>//
81366>>>// JT 06/27/97   File created
81366>>>//************************************************************************
81366>>>
81366>>>// This provides a quick and simple way to create an about package for a program.
81366>>>// You need to create a message inside you client area called Activate_About.
81366>>>// Within this message you should send the message DoAbout passing needed
81366>>>// string information.
81366>>>//
81366>>>//       Procedure Activate_About
81366>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
81366>>>//       End_Procedure
81366>>>//    where: sTitle =     Name of application. If none provided, uses caption
81366>>>//                        bar title
81366>>>//           sVersion   = Version Line. If none provided, will be blank
81366>>>//           sCopyRight = Copyright Line. If none provided, will be blank
81366>>>//           sAuthor    = Author name, blank if none provided
81366>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
81366>>>//                        is used.
81366>>>// It is expected that you will place this in your own object package. For
81366>>>// example an order about package may look like this:
81366>>>//
81366>>>//   // OrderAbout.pkg
81366>>>//   Use StdAbout.pkg
81366>>>//   Procedure Activate_About
81366>>>//      String sTitle sCopyright sVersion sAuthor
81366>>>//      Move "My Order Entry System" to sTitle
81366>>>//      Move "Version 2.1" to sVersion
81366>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
81366>>>//      Move "John Smith"  to sAuthor
81366>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
81366>>>//   end_procedure
81366>>>//   // end of file.
81366>>>
81366>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dfabout.pkg)
81366>>>>>//************************************************************************
81366>>>>>// Confidential Trade Secret.
81366>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
81366>>>>>// as an unpublished work.  All rights reserved.
81366>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
81366>>>>>//
81366>>>>>//************************************************************************
81366>>>>>//************************************************************************
81366>>>>>//
81366>>>>>// $File name  : DfAbout.pkg
81366>>>>>// $File title : About class support
81366>>>>>// Notice      :
81366>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
81366>>>>>//
81366>>>>>// $Rev History
81366>>>>>//
81366>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
81366>>>>>//                Windows for the size first. 
81366>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
81366>>>>>//                with anchor technique. Removed unnessary property in the
81366>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
81366>>>>>//                object To better look in Windows XP. Repositioned the close
81366>>>>>//                button in the sysinfo dialog To line up with the display area
81366>>>>>//                Replaced obsolete code and techniques. Removed dead code.
81366>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
81366>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
81366>>>>>//                the global Workspace object, if it is present
81366>>>>>// JJT 11/05/98   Added version information
81366>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
81366>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
81366>>>>>//                workspace package.
81366>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
81366>>>>>//                class can create this object.
81366>>>>>//                Cleaned up the interface (used correct classes and messages)
81366>>>>>//                Added workspace reporting support To sys-info.
81366>>>>>//                Turned off wrapping in the sys-info editor.
81366>>>>>// KR  ??/??/96   File created
81366>>>>>//************************************************************************
81366>>>>>Use LanguageText.pkg
81366>>>>>Use Windows.pkg
81366>>>>>Use DFbitmap.pkg
81366>>>>>Use GlobalFunctionsProcedures.pkg
81366>>>>>Use cTextEdit.pkg
81366>>>>>
81366>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cli.pkg)
81366>>>>>>>//*****************************************************************************
81366>>>>>>>//*** CLI.PKG                                                               ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//*** Author: Ben Weijers                                                   ***
81366>>>>>>>//***         Data Access Nederland                                         ***
81366>>>>>>>//***         10 September 1998                                             ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//*** Purpose:                                                              ***
81366>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
81366>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
81366>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
81366>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
81366>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//***   This package defines the common functionality for all CLI based     ***
81366>>>>>>>//***   drivers.                                                            ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
81366>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
81366>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
81366>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
81366>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
81366>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
81366>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
81366>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
81366>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81366>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81366>>>>>>>//***             mssqldrv.pkg                                              ***
81366>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
81366>>>>>>>//***             Added type mappings attributes                            ***
81366>>>>>>>//***   Updated:  october 11, 2013 (Current CK build: 6.0.0.18)             ***
81366>>>>>>>//***             Added DF_FILE_SQL_FILTER_EQ attribute                     ***
81366>>>>>>>//*****************************************************************************
81366>>>>>>>
81366>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
81366>>>>>>>//*** Driver attributes
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//------------------------------------------------------------
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//-------------------------------------
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Replacement for logical column number that indicates all columns
81366>>>>>>>
81366>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
81366>>>>>>>
81366>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
81366>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
81366>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>// Moved to Mssqldrv.pkg
81366>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81366>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
81366>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
81366>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
81366>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
81366>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
81366>>>>>>>
81366>>>>>>>//*** Possible SQL Column type values
81366>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
81366>>>>>>>Define SQL_CHAR           For    1
81366>>>>>>>Define SQL_NUMERIC        For    2
81366>>>>>>>Define SQL_DECIMAL        For    3
81366>>>>>>>Define SQL_INTEGER        For    4
81366>>>>>>>Define SQL_SMALLINT       For    5
81366>>>>>>>Define SQL_FLOAT          For    6
81366>>>>>>>Define SQL_REAL           For    7
81366>>>>>>>Define SQL_DOUBLE         For    8
81366>>>>>>>Define SQL_DATETIME       For    9
81366>>>>>>>Define SQL_VARCHAR        For   12
81366>>>>>>>Define SQL_TYPE_DATE      For   91
81366>>>>>>>Define SQL_TYPE_TIME      For   92
81366>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
81366>>>>>>>// Moved to mssqldrv.pkg
81366>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>Define SQL_DATE           For    9
81366>>>>>>>Define SQL_INTERVAL       For   10
81366>>>>>>>Define SQL_TIME           For   10
81366>>>>>>>Define SQL_TIMESTAMP      For   11
81366>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
81366>>>>>>>Define SQL_BINARY         For  (-2)
81366>>>>>>>Define SQL_VARBINARY      For  (-3)
81366>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
81366>>>>>>>Define SQL_BIGINT         For  (-5)
81366>>>>>>>Define SQL_TINYINT        For  (-6)
81366>>>>>>>Define SQL_BIT            For  (-7)
81366>>>>>>>Define SQL_WCHAR          For  (-8)
81366>>>>>>>Define SQL_WVARCHAR       For  (-9)
81366>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
81366>>>>>>>Define SQL_GUID           For (-11)
81366>>>>>>>
81366>>>>>>>//*** Driver level attributes
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Error number constants
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Call driver function identifiers
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Init data source types
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*** Dummy strings used in the commands
81366>>>>>>>    String  CLI$StrDummy 255
81366>>>>>>>    Integer CLI$IntDummy
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*****************************************************************************
81366>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//***   Setup a constraint for a file.                                      ***
81366>>>>>>>//*****************************************************************************
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*****************************************************************************
81366>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
81366>>>>>>>//***                                                                       ***
81366>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
81366>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
81366>>>>>>>//*** permanently set driver level attributes change the driver             ***
81366>>>>>>>//*** configuration file.                                                   ***
81366>>>>>>>//*****************************************************************************
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>
81366>>>>>>>//*****************************************************************************
81366>>>>>>>//*** Class  : cCLIHandler                                                  ***
81366>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81366>>>>>>>//***          call several CLI releated methods.                           ***
81366>>>>>>>//*****************************************************************************
81366>>>>>>>
81366>>>>>>>Class cCLIHandler Is An Array
81367>>>>>>>
81367>>>>>>>    Procedure Construct_Object Integer iImage
81369>>>>>>>        Forward Send Construct_object iImage
81371>>>>>>>
81371>>>>>>>        Property String  psDriverID       Public ""
81372>>>>>>>    End_Procedure // Construct_Object
81373>>>>>>>
81373>>>>>>>
81373>>>>>>>
81373>>>>>>>    //***
81373>>>>>>>    //*** Fucntion: CKRevsion
81373>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
81373>>>>>>>    //***
81373>>>>>>>
81373>>>>>>>    Function CKRevision Returns String
81375>>>>>>>        Local String  sDriverID
81375>>>>>>>        Local String  sRevision
81375>>>>>>>        Local String  sVoid
81375>>>>>>>        Local Integer iRetval
81375>>>>>>>
81375>>>>>>>        Get psDriverID To sDriverID
81376>>>>>>>        If (sDRiverID <> "") Begin
81378>>>>>>>            Move (Repeat(" ", 255)) To sRevision
81379>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81384>>>>>>>        End
81384>>>>>>>>
81384>>>>>>>
81384>>>>>>>        Function_Return sRevision
81385>>>>>>>    End_Function // CKRevision
81386>>>>>>>
81386>>>>>>>
81386>>>>>>>
81386>>>>>>>    //***
81386>>>>>>>    //*** Function: ExtractPartFromRevision
81386>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81386>>>>>>>    //***
81386>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81386>>>>>>>    //***
81386>>>>>>>
81386>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81388>>>>>>>        Local Integer iPartRev
81388>>>>>>>        Local Integer iCurrentPart
81388>>>>>>>        Local Integer iSeparatorPos
81388>>>>>>>
81388>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81391>>>>>>>
81391>>>>>>>        Move 0 To iCurrentPart
81392>>>>>>>        Repeat
81392>>>>>>>>
81392>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81393>>>>>>>            If (iSeparatorPos > 0) Begin
81395>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81396>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81397>>>>>>>                Increment iCurrentPart
81398>>>>>>>            End
81398>>>>>>>>
81398>>>>>>>            Else If (sRevision <> "") Begin
81401>>>>>>>                Move sRevision To iPartRev
81402>>>>>>>                Move "" To sRevision
81403>>>>>>>                Increment iCurrentPart
81404>>>>>>>            End
81404>>>>>>>>
81404>>>>>>>            Else ;                Move -1 To iPartRev
81406>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81408>>>>>>>
81408>>>>>>>        Function_Return iPartRev
81409>>>>>>>    End_Function // EcxtractPartFromRevision
81410>>>>>>>
81410>>>>>>>
81410>>>>>>>
81410>>>>>>>    //***
81410>>>>>>>    //*** Function: CKMajorRevision
81410>>>>>>>    //*** Purpose : Returns the major revision of the CK
81410>>>>>>>    //***
81410>>>>>>>
81410>>>>>>>    Function CKMajorRevision Returns Integer
81412>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81413>>>>>>>    End_Function // CKMajorRevision
81414>>>>>>>
81414>>>>>>>
81414>>>>>>>
81414>>>>>>>    //***
81414>>>>>>>    //*** Function: CKMinorRevision
81414>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81414>>>>>>>    //***
81414>>>>>>>
81414>>>>>>>    Function CKMinorRevision Returns Integer
81416>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81417>>>>>>>    End_Function // CKMinorRevision
81418>>>>>>>
81418>>>>>>>
81418>>>>>>>
81418>>>>>>>    //***
81418>>>>>>>    //*** Function: CKReleaseRevision
81418>>>>>>>    //*** Purpose : Returns the release revision of the CK
81418>>>>>>>    //***
81418>>>>>>>
81418>>>>>>>    Function CKReleaseRevision Returns Integer
81420>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81421>>>>>>>    End_Function // CKReleaseRevision
81422>>>>>>>
81422>>>>>>>
81422>>>>>>>
81422>>>>>>>    //***
81422>>>>>>>    //*** Function: CKBuildRevision
81422>>>>>>>    //*** Purpose : Returns the major revision of the CK
81422>>>>>>>    //***
81422>>>>>>>
81422>>>>>>>    Function CKBuildRevision Returns Integer
81424>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81425>>>>>>>    End_Function // CKBuildRevision
81426>>>>>>>
81426>>>>>>>
81426>>>>>>>
81426>>>>>>>    //***
81426>>>>>>>    //*** Function: IsMinimalRevision
81426>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81426>>>>>>>    //***
81426>>>>>>>
81426>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81428>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81431>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81434>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81437>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81440>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81443>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81447>>>>>>>            End
81447>>>>>>>>
81447>>>>>>>        End
81447>>>>>>>>
81447>>>>>>>
81447>>>>>>>        Function_Return (FALSE)
81448>>>>>>>    End_Function // IsMinimalRevision
81449>>>>>>>
81449>>>>>>>
81449>>>>>>>
81449>>>>>>>    //***
81449>>>>>>>    //*** Function: RegistrationName
81449>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
81449>>>>>>>    //***
81449>>>>>>>
81449>>>>>>>    Function RegistrationName Returns String
81451>>>>>>>        Local String  sRegistration
81451>>>>>>>        Local String  sDRiverId
81451>>>>>>>        Local String  sVoid
81451>>>>>>>        Local Integer iRetval
81451>>>>>>>
81451>>>>>>>        Get psDriverID To sDriverID
81452>>>>>>>        If (sDRiverID <> "") Begin
81454>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
81455>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
81460>>>>>>>        End
81460>>>>>>>>
81460>>>>>>>
81460>>>>>>>        Function_Return sRegistration
81461>>>>>>>    End_Function // RegistrationName
81462>>>>>>>
81462>>>>>>>
81462>>>>>>>
81462>>>>>>>    //***
81462>>>>>>>    //*** Function: SerialNumber
81462>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
81462>>>>>>>    //***
81462>>>>>>>
81462>>>>>>>    Function SerialNumber Returns Integer
81464>>>>>>>        Local String  sDRiverId
81464>>>>>>>        Local String  sVoid
81464>>>>>>>        Local Integer iRetval
81464>>>>>>>
81464>>>>>>>        Get psDriverID To sDriverID
81465>>>>>>>        If (sDRiverID <> "") Begin
81467>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
81472>>>>>>>        End
81472>>>>>>>>
81472>>>>>>>
81472>>>>>>>        Function_Return iRetval
81473>>>>>>>    End_Function // SerialNumber
81474>>>>>>>
81474>>>>>>>
81474>>>>>>>
81474>>>>>>>    //***
81474>>>>>>>    //*** Function: MaxUsers
81474>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
81474>>>>>>>    //***
81474>>>>>>>
81474>>>>>>>    Function MaxUsers Returns Integer
81476>>>>>>>        Local String  sDRiverId
81476>>>>>>>        Local String  sVoid
81476>>>>>>>        Local Integer iRetval
81476>>>>>>>
81476>>>>>>>        Get psDriverID To sDriverID
81477>>>>>>>        If (sDRiverID <> "") Begin
81479>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
81484>>>>>>>        End
81484>>>>>>>>
81484>>>>>>>
81484>>>>>>>        Function_Return iRetval
81485>>>>>>>    End_Function // MaxUsers
81486>>>>>>>
81486>>>>>>>
81486>>>>>>>
81486>>>>>>>    //***
81486>>>>>>>    //*** Procedure: DumpStatus
81486>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
81486>>>>>>>    //***
81486>>>>>>>
81486>>>>>>>    Procedure DumpStatus String sFileName
81488>>>>>>>        Local String  sVoid
81488>>>>>>>        Local String  sDriverID
81488>>>>>>>        Local Integer iVoid
81488>>>>>>>
81488>>>>>>>        Get psDriverID To sDriverID
81489>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
81496>>>>>>>    End_Procedure // DumpStatus
81497>>>>>>>
81497>>>>>>>
81497>>>>>>>
81497>>>>>>>    //***
81497>>>>>>>    //*** Procedure: ReadConfiguration
81497>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
81497>>>>>>>    //***            default value and then reread the configuration.
81497>>>>>>>    //***
81497>>>>>>>
81497>>>>>>>    Procedure ReadConfiguration
81499>>>>>>>        Local String  sVoid
81499>>>>>>>        Local String  sDriverID
81499>>>>>>>        Local Integer iVoid
81499>>>>>>>
81499>>>>>>>        Get psDriverID To sDriverID
81500>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
81507>>>>>>>    End_Procedure // ReadConfiguration
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>    //***
81508>>>>>>>    //*** Function: TextToRIMValue
81508>>>>>>>    //*** Purpose : Convert a text to the corresponding
81508>>>>>>>    //***           Generate_Record_ID_Method attribute value
81508>>>>>>>    //***
81508>>>>>>>
81508>>>>>>>    Function TextToRIMValue String sText Returns Integer
81510>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
81513>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
81517>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
81521>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
81525>>>>>>>    End_Function // TextToRIMValue
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>    //***
81526>>>>>>>    //*** Function: RIMValueTotext
81526>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81526>>>>>>>    //***           corresponding text.
81526>>>>>>>    //***
81526>>>>>>>
81526>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
81528>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
81531>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
81535>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
81539>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
81543>>>>>>>    End_Function // RIMValueToText
81544>>>>>>>
81544>>>>>>>
81544>>>>>>>
81544>>>>>>>    //***
81544>>>>>>>    //*** Function: TextToROValue
81544>>>>>>>    //*** Purpose : Convert a text to the corresponding
81544>>>>>>>    //***           Generate_Record_ID_Method attribute value
81544>>>>>>>    //***
81544>>>>>>>
81544>>>>>>>    Function TextToROValue String sText Returns Integer
81546>>>>>>>        If (sText = "No") ;            Function_return RO_NO
81549>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
81553>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
81557>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
81561>>>>>>>    End_Function // TextToRIMValue
81562>>>>>>>
81562>>>>>>>
81562>>>>>>>
81562>>>>>>>    //***
81562>>>>>>>    //*** Function: ROValueTotext
81562>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
81562>>>>>>>    //***           corresponding text.
81562>>>>>>>    //***
81562>>>>>>>
81562>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
81564>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
81567>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
81571>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
81575>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
81579>>>>>>>    End_Function // RIMValueToText
81580>>>>>>>
81580>>>>>>>
81580>>>>>>>
81580>>>>>>>    //***
81580>>>>>>>    //*** Function: LastDriverError
81580>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
81580>>>>>>>    //***
81580>>>>>>>
81580>>>>>>>    Function LastDriverError Returns String
81582>>>>>>>        Local String  sDriverID
81582>>>>>>>        Local String  sLastError
81582>>>>>>>        Local String  sLastErrorLength
81582>>>>>>>        Local Integer iLastErrorLength
81582>>>>>>>        Local Integer iVoid
81582>>>>>>>
81582>>>>>>>        //*** Initialize
81582>>>>>>>        Move "" To sLastError
81583>>>>>>>
81583>>>>>>>        Get psDriverID To sDriverID
81584>>>>>>>        If (sDriverID <> "") Begin
81586>>>>>>>            //*** Get the text of the last error
81586>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
81587>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
81592>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
81593>>>>>>>
81593>>>>>>>            If (iLastErrorLength > 0) Begin
81595>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
81596>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
81601>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
81602>>>>>>>            End
81602>>>>>>>>
81602>>>>>>>        End
81602>>>>>>>>
81602>>>>>>>
81602>>>>>>>        Function_Return sLastError
81603>>>>>>>    End_Function // LastDriverError
81604>>>>>>>
81604>>>>>>>
81604>>>>>>>
81604>>>>>>>    //***
81604>>>>>>>    //*** Function: EnumerateTables
81604>>>>>>>    //*** Purpose : Enumerate the tables in a database
81604>>>>>>>    //***
81604>>>>>>>
81604>>>>>>>    Function EnumerateTables String sLogin Returns Integer
81606>>>>>>>        Local String  sDriver
81606>>>>>>>        Local String  sVoid
81606>>>>>>>        Local Integer iNumTables
81606>>>>>>>        Local Integer iVoid
81606>>>>>>>
81606>>>>>>>        Get psDriverID To sDriver
81607>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
81614>>>>>>>
81614>>>>>>>        Function_Return iNumTables
81615>>>>>>>    End_Function // EnumerateTables
81616>>>>>>>
81616>>>>>>>
81616>>>>>>>
81616>>>>>>>    //***
81616>>>>>>>    //*** Function: TableName
81616>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
81616>>>>>>>    //***
81616>>>>>>>
81616>>>>>>>    Function TableName Integer iIndex Returns String
81618>>>>>>>        Local String  sDriver
81618>>>>>>>        Local String  sTableName
81618>>>>>>>        Local String  sVoid
81618>>>>>>>        Local Integer iVoid
81618>>>>>>>
81618>>>>>>>        Get psDriverID To sDriver
81619>>>>>>>        If (sDriver <> "") Begin
81621>>>>>>>            Move (Repeat(" ", 255)) To sTableName
81622>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
81627>>>>>>>        End
81627>>>>>>>>
81627>>>>>>>
81627>>>>>>>        Function_Return sTableName
81628>>>>>>>    End_Function // TableName
81629>>>>>>>
81629>>>>>>>
81629>>>>>>>
81629>>>>>>>    //***
81629>>>>>>>    //*** Function: SchemaName
81629>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
81629>>>>>>>    //***
81629>>>>>>>
81629>>>>>>>    Function SchemaName Integer iIndex Returns String
81631>>>>>>>        Local String  sDriver
81631>>>>>>>        Local String  sSchemaName
81631>>>>>>>        Local String  sVoid
81631>>>>>>>        Local Integer iVoid
81631>>>>>>>
81631>>>>>>>        Get psDriverID To sDriver
81632>>>>>>>        If (sDriver <> "") Begin
81634>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
81635>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
81640>>>>>>>        End
81640>>>>>>>>
81640>>>>>>>
81640>>>>>>>        Function_Return sSchemaName
81641>>>>>>>    End_Function // SchemaName
81642>>>>>>>
81642>>>>>>>
81642>>>>>>>
81642>>>>>>>    //***
81642>>>>>>>    //*** Function: TableType
81642>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
81642>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
81642>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
81642>>>>>>>    //***
81642>>>>>>>
81642>>>>>>>    Function TableType Integer iIndex Returns String
81644>>>>>>>        Local String  sDriver
81644>>>>>>>        Local String  sTableType
81644>>>>>>>        Local String  sVoid
81644>>>>>>>        Local Integer iVoid
81644>>>>>>>
81644>>>>>>>        Get psDriverID To sDriver
81645>>>>>>>        If (sDriver <> "") Begin
81647>>>>>>>            Move (Repeat(" ", 25)) To sTableType
81648>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
81653>>>>>>>        End
81653>>>>>>>>
81653>>>>>>>
81653>>>>>>>        Function_Return sTableType
81654>>>>>>>    End_Function // TableType
81655>>>>>>>
81655>>>>>>>
81655>>>>>>>
81655>>>>>>>    //***
81655>>>>>>>    //*** Function: TableComment
81655>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
81655>>>>>>>    //***
81655>>>>>>>
81655>>>>>>>    Function TableComment Integer iIndex Returns String
81657>>>>>>>        Local String  sDriver
81657>>>>>>>        Local String  sTableComment
81657>>>>>>>        Local String  sVoid
81657>>>>>>>        Local Integer iVoid
81657>>>>>>>
81657>>>>>>>        Get psDriverID To sDriver
81658>>>>>>>        If (sDriver <> "") Begin
81660>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
81661>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
81666>>>>>>>        End
81666>>>>>>>>
81666>>>>>>>
81666>>>>>>>        Function_Return sTableComment
81667>>>>>>>    End_Function // TableComment
81668>>>>>>>
81668>>>>>>>
81668>>>>>>>
81668>>>>>>>    //***
81668>>>>>>>    //*** Function: EnumerateColumns
81668>>>>>>>    //*** Purpose : Enumerate the columns in a table
81668>>>>>>>    //***
81668>>>>>>>
81668>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
81670>>>>>>>        Local String  sDriver
81670>>>>>>>        Local Integer iNumColumns
81670>>>>>>>        Local Integer iVoid
81670>>>>>>>
81670>>>>>>>        Get psDriverID To sDriver
81671>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
81678>>>>>>>
81678>>>>>>>        Function_Return iNumColumns
81679>>>>>>>    End_Function // EnumerateColumns
81680>>>>>>>
81680>>>>>>>
81680>>>>>>>
81680>>>>>>>    //***
81680>>>>>>>    //*** Function: ColumnName
81680>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
81680>>>>>>>    //***
81680>>>>>>>
81680>>>>>>>    Function ColumnName Integer iIndex Returns String
81682>>>>>>>        Local String  sDriver
81682>>>>>>>        Local String  sColumnName
81682>>>>>>>        Local String  sVoid
81682>>>>>>>        Local Integer iVoid
81682>>>>>>>
81682>>>>>>>        Get psDriverID To sDriver
81683>>>>>>>        If (sDriver <> "") Begin
81685>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
81686>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
81691>>>>>>>        End
81691>>>>>>>>
81691>>>>>>>
81691>>>>>>>        Function_Return sColumnName
81692>>>>>>>    End_Function // ColumnName
81693>>>>>>>
81693>>>>>>>
81693>>>>>>>
81693>>>>>>>    //***
81693>>>>>>>    //*** Function: CLIDFDateToSQLDate
81693>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
81693>>>>>>>    //***
81693>>>>>>>
81693>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
81695>>>>>>>        Local String sSQLDate
81695>>>>>>>        Local Integer iOrgDateFmt
81695>>>>>>>        Local Integer iOrgDateSep
81695>>>>>>>
81695>>>>>>>        //*** Change date format to military, SQL dates are military dates
81695>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81698>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81701>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81704>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81707>>>>>>>
81707>>>>>>>        //*** We only need to convert if the date is 0
81707>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
81716>>>>>>>        Else ;            Move dDFDate To sSQLDate
81718>>>>>>>
81718>>>>>>>        //*** Change date format back to original
81718>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81721>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81724>>>>>>>
81724>>>>>>>        Function_Return sSQLDate
81725>>>>>>>    End_Function // CLIDFDateToSQLDate
81726>>>>>>>
81726>>>>>>>
81726>>>>>>>
81726>>>>>>>    //***
81726>>>>>>>    //*** Function: CLISQLDateToDFDate
81726>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
81726>>>>>>>    //***
81726>>>>>>>
81726>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
81728>>>>>>>        Local Date dDFDate
81728>>>>>>>        Local String sDummyDateValue
81728>>>>>>>        Local Integer iOrgDateFmt
81728>>>>>>>        Local Integer iOrgDateSep
81728>>>>>>>
81728>>>>>>>        //*** Change date format to military, SQL dates are military dates
81728>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
81731>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81734>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
81737>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
81740>>>>>>>
81740>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
81740>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
81747>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
81750>>>>>>>        Else ;            Move sSQLDate To dDFDate
81752>>>>>>>
81752>>>>>>>        //*** Change date format back to original
81752>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
81755>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
81758>>>>>>>
81758>>>>>>>        Function_Return dDFDate
81759>>>>>>>    End_Function // CLISQLDateToDFDate
81760>>>>>>>
81760>>>>>>>
81760>>>>>>>
81760>>>>>>>    //***
81760>>>>>>>    //*** Function: RedirectConnection
81760>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
81760>>>>>>>    //***           will point to another database but all tables will stay
81760>>>>>>>    //***           open!
81760>>>>>>>    //***
81760>>>>>>>
81760>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
81762>>>>>>>        Local String  sDriver
81762>>>>>>>        Local String  sVoid
81762>>>>>>>        Local Integer iResult
81762>>>>>>>        Local Integer iVoid
81762>>>>>>>
81762>>>>>>>        Get psDriverID To sDriver
81763>>>>>>>        If (sDriver <> "") Begin
81765>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
81770>>>>>>>        End
81770>>>>>>>>
81770>>>>>>>        Function_Return iResult
81771>>>>>>>    End_Function // RedirectConnect
81772>>>>>>>
81772>>>>>>>
81772>>>>>>>
81772>>>>>>>    //***
81772>>>>>>>    //*** Function: CreateConnectionID
81772>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
81772>>>>>>>    //***
81772>>>>>>>
81772>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
81774>>>>>>>        Local String  sDriver
81774>>>>>>>        Local Integer iResult
81774>>>>>>>        Local Integer iOptions
81774>>>>>>>
81774>>>>>>>        Get psDriverID to sDriver
81775>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
81778>>>>>>>        Else ;            Move iOpt to iOptions
81780>>>>>>>        If (sDriver <> "") Begin
81782>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
81787>>>>>>>        End
81787>>>>>>>>
81787>>>>>>>        Function_Return iResult
81788>>>>>>>    End_Function // CreateConnectionID
81789>>>>>>>
81789>>>>>>>
81789>>>>>>>
81789>>>>>>>    //***
81789>>>>>>>    //*** Function: DeleteConnectionID
81789>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
81789>>>>>>>    //***
81789>>>>>>>
81789>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
81791>>>>>>>        Local String  sDriver
81791>>>>>>>        Local Integer iResult
81791>>>>>>>        Local String sVoid
81791>>>>>>>
81791>>>>>>>        Get psDriverID To sDriver
81792>>>>>>>        If (sDriver <> "") Begin
81794>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
81799>>>>>>>        End
81799>>>>>>>>
81799>>>>>>>        Function_Return iResult
81800>>>>>>>    End_Function // DeleteConnectionID
81801>>>>>>>
81801>>>>>>>End_Class // cCLIHandler
81802>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 18.2\Pkg\DFBTRDRV.PKG)
81802>>>>>>>//****************************************************************************
81802>>>>>>>//
81802>>>>>>>// $File name  : DFBTRDRV.PKG
81802>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81802>>>>>>>// Notice      : This package contains constants and commands, used to call
81802>>>>>>>//               specific functions in the DFBTRDRV.
81802>>>>>>>// $Author(s)  : Eddy Kleinjan
81802>>>>>>>//
81802>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81802>>>>>>>// Created     : 01-07-97 @ 12:00:00
81802>>>>>>>//
81802>>>>>>>// Changed     : 04-04-2001.
81802>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81802>>>>>>>//
81802>>>>>>>// Changed     : June 6, 2001
81802>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81802>>>>>>>//
81802>>>>>>>//               Added DFBTR_DDF_OWNER command.
81802>>>>>>>//
81802>>>>>>>// Changed     : June 12, 2001
81802>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81802>>>>>>>//
81802>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81802>>>>>>>//
81802>>>>>>>// Changed     : August 4, 2004
81802>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81802>>>>>>>//
81802>>>>>>>//               Added cDfbtrdrvHandler class.
81802>>>>>>>//               New functions in this class:
81802>>>>>>>//                  Function CKRevision Returns String
81802>>>>>>>//                  Function CkUsesUri Returns Integer
81802>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81802>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81802>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81802>>>>>>>//
81802>>>>>>>// Changed     : September 30, 2005
81802>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81802>>>>>>>//
81802>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81802>>>>>>>//****************************************************************************
81802>>>>>>>Use Ui
81802>>>>>>>//
81802>>>>>>>// Driver Indentification
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//*** Driver attributes
81802>>>>>>>//
81802>>>>>>>// Call_Driver functions ID's
81802>>>>>>>//
81802>>>>>>>//
81802>>>>>>>// DFBTRFN_CONVERT_FILE options
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// DFBTRFN_SET_OWNER options
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to create all vars which may be needed
81802>>>>>>>// in other commands.
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to set the owner of a Btrieve file.
81802>>>>>>>// File must have been opened.
81802>>>>>>>// Filenumber needs to be passed.
81802>>>>>>>// To clear set the owner to "".
81802>>>>>>>// Examples:
81802>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81802>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81802>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81802>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81802>>>>>>>// To clear:
81802>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to parse DFBTR_SET_OWNVER
81802>>>>>>>// options.
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to parse for Callback
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to clear the owner of a Btrieve file.
81802>>>>>>>// File must have been opened.
81802>>>>>>>// Filenumber needs to be passed.
81802>>>>>>>// Examples:
81802>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to add a owner name to the internal list of ownernames
81802>>>>>>>// which will be tries when opening files.
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to remove all owners from the internal list of ownernames
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81802>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81802>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81802>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to change the transaction type.
81802>>>>>>>// Valid types are:
81802>>>>>>>//     DFBTRTT_NONE
81802>>>>>>>//     DFBTRTT_EXCLUSIVE
81802>>>>>>>//     DFBTRTT_CONCURRENT
81802>>>>>>>//
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to get the current transaction type.
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to set explicit_locking
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to get explicit locking
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//
81802>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81802>>>>>>>//
81802>>>>>>>
81802>>>>>>>//*****************************************************************************
81802>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81802>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81802>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81802>>>>>>>//*****************************************************************************
81802>>>>>>>
81802>>>>>>>Class cDFBtrDrvHandler Is An Array
81803>>>>>>>
81803>>>>>>>    Procedure Construct_Object Integer iImage
81805>>>>>>>        Forward Send Construct_object iImage
81807>>>>>>>
81807>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81808>>>>>>>    End_Procedure // Construct_Object
81809>>>>>>>
81809>>>>>>>
81809>>>>>>>
81809>>>>>>>    //***
81809>>>>>>>    //*** Function: CKRevsion
81809>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81809>>>>>>>    //***
81809>>>>>>>
81809>>>>>>>    Function CKRevision Returns String
81811>>>>>>>        Local String  sDriverID
81811>>>>>>>        Local String  sRevision
81811>>>>>>>        Local String  sVoid
81811>>>>>>>        Local Integer iRetval
81811>>>>>>>
81811>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81811>>>>>>>        // This error would otherwise be raised when we have an older
81811>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81811>>>>>>>        Send Ignore_error To Error_object_Id 20491
81812>>>>>>>        Get psDriverID To sDriverID
81813>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81814>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81819>>>>>>>        Send Trap_Error To Error_object_Id 20491
81820>>>>>>>        If (Trim(sRevision) = "") Begin
81822>>>>>>>            // Unable to get the revision. return all zeroes.
81822>>>>>>>            Move "0.0.0.0" To sRevision
81823>>>>>>>        End
81823>>>>>>>>
81823>>>>>>>        Function_Return sRevision
81824>>>>>>>    End_Function // CKRevision
81825>>>>>>>
81825>>>>>>>    Function CkUsesUri Returns Integer
81827>>>>>>>        Local String  sDriverID
81827>>>>>>>        Local String  sVoid1
81827>>>>>>>        Local String  sVoid2
81827>>>>>>>        Local Integer iRetval
81827>>>>>>>
81827>>>>>>>        Get psDriverID To sDriverID
81828>>>>>>>
81828>>>>>>>        Move 0 To iRetval
81829>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81829>>>>>>>        // This error would otherwise be raised when we have an older
81829>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81829>>>>>>>        Send Ignore_error To Error_object_Id 20491
81830>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81835>>>>>>>        Send Trap_Error To Error_object_Id 20491
81836>>>>>>>
81836>>>>>>>        Function_Return iRetval
81837>>>>>>>    End_Function // CKUsesUri
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>
81838>>>>>>>    //***
81838>>>>>>>    //*** Function: ExtractPartFromRevsion
81838>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81838>>>>>>>    //***
81838>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81838>>>>>>>    //***
81838>>>>>>>
81838>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81840>>>>>>>        Local Integer iPartRev
81840>>>>>>>        Local Integer iCurrentPart
81840>>>>>>>        Local Integer iSeparatorPos
81840>>>>>>>
81840>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81843>>>>>>>
81843>>>>>>>        Move 0 To iCurrentPart
81844>>>>>>>        Repeat
81844>>>>>>>>
81844>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81845>>>>>>>            If (iSeparatorPos > 0) Begin
81847>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81848>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81849>>>>>>>                Increment iCurrentPart
81850>>>>>>>            End
81850>>>>>>>>
81850>>>>>>>            Else If (sRevision <> "") Begin
81853>>>>>>>                Move sRevision To iPartRev
81854>>>>>>>                Move "" To sRevision
81855>>>>>>>                Increment iCurrentPart
81856>>>>>>>            End
81856>>>>>>>>
81856>>>>>>>            Else ;                Move -1 To iPartRev
81858>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81860>>>>>>>
81860>>>>>>>        Function_Return iPartRev
81861>>>>>>>    End_Function // EcxtractPartFromRevision
81862>>>>>>>
81862>>>>>>>
81862>>>>>>>
81862>>>>>>>    //***
81862>>>>>>>    //*** Function: CKMajorRevision
81862>>>>>>>    //*** Purpose : Returns the major revision of the CK
81862>>>>>>>    //***
81862>>>>>>>
81862>>>>>>>    Function CKMajorRevision Returns Integer
81864>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81865>>>>>>>    End_Function // CKMajorRevision
81866>>>>>>>
81866>>>>>>>
81866>>>>>>>
81866>>>>>>>    //***
81866>>>>>>>    //*** Function: CKMinorRevision
81866>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81866>>>>>>>    //***
81866>>>>>>>
81866>>>>>>>    Function CKMinorRevision Returns Integer
81868>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81869>>>>>>>    End_Function // CKMinorRevision
81870>>>>>>>
81870>>>>>>>
81870>>>>>>>
81870>>>>>>>    //***
81870>>>>>>>    //*** Function: CKReleaseRevision
81870>>>>>>>    //*** Purpose : Returns the release revision of the CK
81870>>>>>>>    //***
81870>>>>>>>
81870>>>>>>>    Function CKReleaseRevision Returns Integer
81872>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81873>>>>>>>    End_Function // CKReleaseRevision
81874>>>>>>>
81874>>>>>>>
81874>>>>>>>
81874>>>>>>>    //***
81874>>>>>>>    //*** Function: CKBuildRevision
81874>>>>>>>    //*** Purpose : Returns the major revision of the CK
81874>>>>>>>    //***
81874>>>>>>>
81874>>>>>>>    Function CKBuildRevision Returns Integer
81876>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81877>>>>>>>    End_Function // CKBuildRevision
81878>>>>>>>
81878>>>>>>>
81878>>>>>>>
81878>>>>>>>    //***
81878>>>>>>>    //*** Function: IsMinimalRevision
81878>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81878>>>>>>>    //***
81878>>>>>>>
81878>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81880>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81883>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81886>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81889>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81892>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81895>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81899>>>>>>>            End
81899>>>>>>>>
81899>>>>>>>        End
81899>>>>>>>>
81899>>>>>>>
81899>>>>>>>        Function_Return (FALSE)
81900>>>>>>>    End_Function // IsMinimalRevision
81901>>>>>>>
81901>>>>>>>    //   Functions to query the Pervasive.SQL version:
81901>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81901>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81901>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81901>>>>>>>    //
81901>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81901>>>>>>>    //   in the following format:
81901>>>>>>>    //       <version>.<revision>.<type>
81901>>>>>>>    //   possible values for <type>:
81901>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81901>>>>>>>    //         server using Workgroup authentication mode
81901>>>>>>>    //       C for client cache engine
81901>>>>>>>    //       D for DOS workstation
81901>>>>>>>    //       N for client Requester
81901>>>>>>>    //       S for NetWare server
81901>>>>>>>    //       T for 32-bit Windows server engine
81901>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81901>>>>>>>    //
81901>>>>>>>    //   example:
81901>>>>>>>    //       8.50.T
81901>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81901>>>>>>>    //   32-bits Windows server.
81901>>>>>>>    //
81901>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81901>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81901>>>>>>>    //
81901>>>>>>>    //   If the version information is not available or can not be obtained
81901>>>>>>>    //   the functions will return "0.0.0"
81901>>>>>>>
81901>>>>>>>
81901>>>>>>>    //***
81901>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81901>>>>>>>    //*** Purpose : Returns the version information of the
81901>>>>>>>    //***           Pervasive.SQL Client requester.
81901>>>>>>>
81901>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81903>>>>>>>
81903>>>>>>>        Local String  sDriverID
81903>>>>>>>        Local String  sVersion
81903>>>>>>>        Local String  sVoid
81903>>>>>>>        Local Integer iRetval
81903>>>>>>>
81903>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81903>>>>>>>        // This error would otherwise be raised when we have an older
81903>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81903>>>>>>>        Send Ignore_error To Error_object_Id 20491
81904>>>>>>>        Get psDriverID To sDriverID
81905>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81906>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81911>>>>>>>        Send Trap_Error To Error_object_Id 20491
81912>>>>>>>        If (Trim(sVersion) = "") Begin
81914>>>>>>>            // Unable to get the revision. return all zeroes.
81914>>>>>>>            Move "0.0.0" To sVersion
81915>>>>>>>        End
81915>>>>>>>>
81915>>>>>>>        Function_Return sVersion
81916>>>>>>>    End_Function //  PSQLRequesterVersion
81917>>>>>>>
81917>>>>>>>    //***
81917>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81917>>>>>>>    //*** Purpose : Returns the version information of the
81917>>>>>>>    //***           Pervasive.SQL Local Engine
81917>>>>>>>
81917>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81919>>>>>>>
81919>>>>>>>        Local String  sDriverID
81919>>>>>>>        Local String  sVersion
81919>>>>>>>        Local String  sVoid
81919>>>>>>>        Local Integer iRetval
81919>>>>>>>
81919>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81919>>>>>>>        // This error would otherwise be raised when we have an older
81919>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81919>>>>>>>        Send Ignore_error To Error_object_Id 20491
81920>>>>>>>        Get psDriverID To sDriverID
81921>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81922>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81927>>>>>>>        Send Trap_Error To Error_object_Id 20491
81928>>>>>>>        If (Trim(sVersion) = "") Begin
81930>>>>>>>            // Unable to get the revision. return all zeroes.
81930>>>>>>>            Move "0.0.0" To sVersion
81931>>>>>>>        End
81931>>>>>>>>
81931>>>>>>>        Function_Return sVersion
81932>>>>>>>    End_Function //  PSQLLocalEngineVersion
81933>>>>>>>
81933>>>>>>>    //***
81933>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81933>>>>>>>    //*** Purpose : Returns the version information of the
81933>>>>>>>    //***           Pervasive.SQL Server Engine
81933>>>>>>>
81933>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81935>>>>>>>
81935>>>>>>>        Local String  sDriverID
81935>>>>>>>        Local String  sVersion
81935>>>>>>>        Local String  sVoid
81935>>>>>>>        Local Integer iRetval
81935>>>>>>>
81935>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81935>>>>>>>        // This error would otherwise be raised when we have an older
81935>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81935>>>>>>>        Send Ignore_error To Error_object_Id 20491
81936>>>>>>>        Get psDriverID To sDriverID
81937>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81938>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81943>>>>>>>        Send Trap_Error To Error_object_Id 20491
81944>>>>>>>        If (Trim(sVersion) = "") Begin
81946>>>>>>>            // Unable to get the revision. return all zeroes.
81946>>>>>>>            Move "0.0.0" To sVersion
81947>>>>>>>        End
81947>>>>>>>>
81947>>>>>>>        Function_Return sVersion
81948>>>>>>>    End_Function //  PSQLServerEngineVersion
81949>>>>>>>
81949>>>>>>>End_Class // cDfbtrdrvHandler
81950>>>>>>>
81950>>>>>
81950>>>>>
81950>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81951>>>>>
81951>>>>>Register_Function phoWorkspace Returns Handle
81951>>>>>Register_Function Help_filename Returns String
81951>>>>>Register_Function GetHelpFile Returns String
81951>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81951>>>>>
81951>>>>>//****************************************************************************
81951>>>>>// $Module type: FUNCTION
81951>>>>>// $Module name: Network_User_Name
81951>>>>>// $Author     : AK/VOO/KCR
81951>>>>>// Created     : 09-24-96 @ 19:17
81951>>>>>//
81951>>>>>// Description
81951>>>>>//    This function reads the current username Of windows and returns that
81951>>>>>//    name or an text unknown user
81951>>>>>//
81951>>>>>// $Rev History
81951>>>>>//  02/22/2012  Ask Windows how long the size of the name should be
81951>>>>>//  07/25/2003  Replaced obsolete code
81951>>>>>//  09/24/1996  Module header created
81951>>>>>//****************************************************************************
81951>>>>>Function Network_User_Name for cDesktop Returns String
81953>>>>>    String sName
81953>>>>>    Integer iRetval iLength
81953>>>>>
81953>>>>>    Move 0 to iLength
81954>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
81955>>>>>    ZeroString iLength to sName
81956>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
81957>>>>>
81957>>>>>    If (iRetval = NO_ERROR) Begin
81959>>>>>        Function_Return (CString (sName))
81960>>>>>    End
81960>>>>>>
81960>>>>>    
81960>>>>>    Function_Return "User Unknown"
81961>>>>>End_Function
81962>>>>>
81962>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81962>>>>>Type MEMORYSTATUS
81962>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81962>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81962>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81962>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81962>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81962>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81962>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81962>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81962>>>>>End_Type // MEMORYSTATUS
81962>>>>>
81962>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81963>>>>>
81963>>>>>Struct tWinMemoryStatusEx
81963>>>>>    UInteger dwLength                
81963>>>>>    UInteger dwMemoryLoad          
81963>>>>>    UBigInt ullTotalPhys           
81963>>>>>    UBigInt ullAvailPhys           
81963>>>>>    UBigInt ullTotalPageFile       
81963>>>>>    UBigInt ullAvailPageFile       
81963>>>>>    UBigInt ullTotalVirtual        
81963>>>>>    UBigInt ullAvailVirtual        
81963>>>>>    UBigInt ullAvailExtendedVirtual
81963>>>>>End_Struct
81963>>>>>
81963>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
81964>>>>>
81964>>>>>Class SysinfoDisplay is a cTextEdit
81965>>>>>    Procedure Construct_Object
81967>>>>>        Forward Send Construct_Object
81969>>>>>
81969>>>>>        Set Location To 6 6
81970>>>>>        Set Size To 110 255
81971>>>>>        Set Read_Only_State To True
81972>>>>>        Set pbWrap to False
81973>>>>>    End_Procedure
81974>>>>>
81974>>>>>    //****************************************************************************
81974>>>>>    // $Module type: PROCEDURE
81974>>>>>    // $Module name: Show_Current_Directory
81974>>>>>    // $Author     : VOO
81974>>>>>    // Created     : 06-10-96 @ 15:24
81974>>>>>    //
81974>>>>>    // Description
81974>>>>>    //    This method will show the name Of the current directory in the system
81974>>>>>    //    information box
81974>>>>>    //
81974>>>>>    // $Rev History
81974>>>>>    //    06-10-96  Module header created
81974>>>>>    //****************************************************************************
81974>>>>>    Procedure Show_Current_Directory
81976>>>>>        String sDir
81976>>>>>
81976>>>>>        Get_Current_Directory To sDir
81977>>>>>
81977>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
81978>>>>>    End_Procedure
81979>>>>>
81979>>>>>    Procedure Show_Windows_Directory
81981>>>>>        String sWindir
81981>>>>>
81981>>>>>        Get_Windows_Directory To sWindir
81982>>>>>
81982>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
81983>>>>>    End_Procedure
81984>>>>>
81984>>>>>    Procedure Show_Current_User
81986>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
81987>>>>>    End_Procedure
81988>>>>>
81988>>>>>    Procedure Show_Number_Format
81990>>>>>        Integer iFormat
81990>>>>>        String sFormatText
81990>>>>>
81990>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
81993>>>>>        Move (Character (iFormat)) To sFormatText
81994>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
81995>>>>>
81995>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
81998>>>>>        Move (Character (iFormat)) to sFormatText
81999>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
82000>>>>>    End_Procedure
82001>>>>>
82001>>>>>    Procedure Show_Filelist_Name
82003>>>>>        String sFilename
82003>>>>>
82003>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
82006>>>>>
82006>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
82007>>>>>        Send AppendTextLn ""
82008>>>>>    End_Procedure
82009>>>>>
82009>>>>>    Procedure Show_Lock_Delay
82011>>>>>        Integer iLockdelay
82011>>>>>
82011>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
82014>>>>>
82014>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
82015>>>>>    End_Procedure
82016>>>>>
82016>>>>>    Procedure Show_Lock_Timeout
82018>>>>>        Integer iLockTimeout
82018>>>>>
82018>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
82021>>>>>
82021>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
82022>>>>>    End_Procedure
82023>>>>>
82023>>>>>    Procedure Show_Screen_Size
82025>>>>>        Integer iYscreensize iXscreensize
82025>>>>>
82025>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
82026>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
82027>>>>>
82027>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
82028>>>>>    End_Procedure
82029>>>>>
82029>>>>>    Procedure Show_Page_Size
82031>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
82032>>>>>    End_procedure
82033>>>>>
82033>>>>>    Procedure Show_Date
82035>>>>>        Date dToday
82035>>>>>
82035>>>>>        Sysdate dToday
82036>>>>>
82036>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
82037>>>>>    End_procedure
82038>>>>>
82038>>>>>    Procedure Show_Date_Format
82040>>>>>        Integer iDateFormat
82040>>>>>        String sDateFormat
82040>>>>>
82040>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
82043>>>>>        Case Begin
82043>>>>>            Case (iDateFormat = DF_DATE_USA)
82045>>>>>                Move C_$USA To sDateFormat
82046>>>>>                Case Break
82047>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
82050>>>>>                Move C_$European To sDateFormat
82051>>>>>                Case Break
82052>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
82055>>>>>                Move C_$Military To sDateFormat
82056>>>>>                Case Break
82057>>>>>            Case Else
82057>>>>>                Move C_$UnknownDateType To sDateFormat
82058>>>>>                Case Break
82059>>>>>        Case End
82059>>>>>
82059>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
82060>>>>>    End_Procedure
82061>>>>>
82061>>>>>    Procedure Show_Systemresources
82063>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82063>>>>>        tWinMemoryStatusEx MemoryStatusInfo
82063>>>>>        Integer iRetval
82063>>>>>
82063>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
82064>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
82065>>>>>        If (iRetval = 0) Begin
82067>>>>>            Move (ShowLastError ()) to iRetval
82068>>>>>        End
82068>>>>>>
82068>>>>>
82068>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
82069>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
82070>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
82071>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
82072>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
82073>>>>>    End_Procedure
82074>>>>>
82074>>>>>    Procedure Show_Registration
82076>>>>>        String sRegName
82076>>>>>        Integer iSN iMaxUsers
82076>>>>>
82076>>>>>        Registration sRegName iSN
82077>>>>>>
82077>>>>>        
82077>>>>>        Get_Licensed_Max_Users to iMaxUsers
82078>>>>>
82078>>>>>        Send AppendTextLn ""
82079>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
82080>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
82081>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
82082>>>>>    End_Procedure
82083>>>>>
82083>>>>>    //****************************************************************************
82083>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
82083>>>>>    // To the workspace object passing the an object and message To send back
82083>>>>>    // To this object. It is expected that the workspace object will send this
82083>>>>>    // message for every line Of information it wants displayed (passing the
82083>>>>>    // information To be displayed
82083>>>>>    //****************************************************************************
82083>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
82083>>>>>
82083>>>>>    Procedure Show_ServicePack
82085>>>>>        String sKey sVersionDescription sVersion 
82085>>>>>        Handle hoRegistry
82085>>>>>        Boolean bExists bOpened
82085>>>>>        
82085>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
82086>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82087>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
82088>>>>>
82088>>>>>        Move C_DFVersionRegistryRoot to sKey
82089>>>>>        Get KeyExists of hoRegistry sKey to bExists
82090>>>>>        If (bExists) Begin
82092>>>>>            Get OpenKey of hoRegistry sKey to bOpened
82093>>>>>            If (bOpened) Begin
82095>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
82096>>>>>                If (bExists) Begin
82098>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
82099>>>>>                End
82099>>>>>>
82099>>>>>                
82099>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
82100>>>>>                If (bExists) Begin
82102>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
82103>>>>>                End                
82103>>>>>>
82103>>>>>                Send CloseKey of hoRegistry
82104>>>>>            End
82104>>>>>>
82104>>>>>        End
82104>>>>>>
82104>>>>>        Send Destroy of hoRegistry
82105>>>>>
82105>>>>>        If (sVersionDescription <> "") Begin
82107>>>>>           Send AppendTextLn (sVersionDescription * "-" * sVersion)
82108>>>>>           Send AppendTextLn ""
82109>>>>>        End
82109>>>>>>
82109>>>>>    End_Procedure
82110>>>>>    
82110>>>>>
82110>>>>>    Procedure Show_WorkspaceInformation
82112>>>>>        Integer hoWorkspace
82112>>>>>
82112>>>>>        If (ghoApplication <> 0) Begin
82114>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
82115>>>>>            If (hoWorkspace <> 0) Begin
82117>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
82118>>>>>                Send AppendTextLn ""
82119>>>>>            End
82119>>>>>>
82119>>>>>        End
82119>>>>>>
82119>>>>>    End_Procedure
82120>>>>>
82120>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
82122>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
82123>>>>>    End_Function
82124>>>>>
82124>>>>>    Procedure Show_Versions
82126>>>>>        Integer iVersion iRevision iBuild
82126>>>>>
82126>>>>>        Version_Information iVersion iRevision iBuild
82128>>>>>
82128>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
82129>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
82130>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
82131>>>>>    End_Procedure
82132>>>>>    
82132>>>>>    Function CKRevisionNumber String sDriverID Returns String
82134>>>>>        Handle hoCLIHandler
82134>>>>>        Handle hoDFBtrDrvHandler
82134>>>>>        String sCKRevision
82134>>>>>
82134>>>>>
82134>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
82136>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
82137>>>>>            Set psDriverID of hoCLIHandler to sDriverID
82138>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
82139>>>>>            Send Destroy of hoCLIHandler
82140>>>>>        End
82140>>>>>>
82140>>>>>        Else Begin
82141>>>>>            If (sDriverID = "DFBTRDRV") Begin
82143>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
82144>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
82145>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
82146>>>>>                Send Destroy of hoDFBtrDrvHandler
82147>>>>>            End
82147>>>>>>
82147>>>>>        End
82147>>>>>>
82147>>>>>        
82147>>>>>        Function_Return sCKRevision
82148>>>>>    End_Function
82149>>>>>    
82149>>>>>    
82149>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
82151>>>>>        
82151>>>>>        If (sDriverID = "DATAFLEX") Begin
82153>>>>>            Function_Return False
82154>>>>>        End
82154>>>>>>
82154>>>>>    
82154>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
82155>>>>>    End_Function    
82156>>>>>
82156>>>>>
82156>>>>>    //***
82156>>>>>    //*** BW
82156>>>>>    //*** Procedure: Show_Drivers
82156>>>>>    //*** Purpose  : Show loaded database drivers
82156>>>>>    //***
82156>>>>>
82156>>>>>    Procedure Show_Drivers
82158>>>>>        String sCurrentDriver sRevNumber
82158>>>>>        String sLoadedDrivers
82158>>>>>        Integer iNumberOfDrivers iCount
82158>>>>>        Boolean bOK
82158>>>>>
82158>>>>>        Move "" To sLoadedDrivers
82159>>>>>        Get_Attribute DF_NUMBER_DRIVERS To iNumberOfDrivers
82162>>>>>        For iCount From 1 To iNumberOfDrivers
82168>>>>>>
82168>>>>>            Get_Attribute DF_DRIVER_NAME Of iCount To sCurrentDriver
82171>>>>>            If (sLoadedDrivers <> "") Begin
82173>>>>>                Move (Append (sLoadedDrivers, ", ")) To sLoadedDrivers
82174>>>>>            End
82174>>>>>>
82174>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
82175>>>>>            If (bOK) Begin
82177>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
82178>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
82179>>>>>            End
82179>>>>>>
82179>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) To sLoadedDrivers
82180>>>>>        Loop
82181>>>>>>
82181>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
82182>>>>>    End_Procedure
82183>>>>>
82183>>>>>    Procedure Show_HelpFile
82185>>>>>        String sHelpFile
82185>>>>>        Integer eHelpType
82185>>>>>
82185>>>>>        If (ghoApplication <> 0) Begin
82187>>>>>            Get peHelpType Of ghoApplication To eHelpType
82188>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
82190>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
82191>>>>>            End
82191>>>>>>
82191>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
82194>>>>>                Get Help_filename Of Help_object_id To sHelpFile
82195>>>>>            End
82195>>>>>>
82195>>>>>            Else Begin
82196>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
82197>>>>>            End
82197>>>>>>
82197>>>>>
82197>>>>>            Send AppendTextLn ""
82198>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
82199>>>>>        End
82199>>>>>>
82199>>>>>    End_Procedure
82200>>>>>
82200>>>>>    Procedure Show_EnterAsTab
82202>>>>>        Boolean bEnterKeyAsTabKey
82202>>>>>        String sText
82202>>>>>
82202>>>>>        If (ghoApplication <> 0) Begin
82204>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
82205>>>>>            If (bEnterKeyAsTabKey) Begin
82207>>>>>                Move "True" To sText
82208>>>>>            End
82208>>>>>>
82208>>>>>            Else Begin
82209>>>>>                Move "False" To sText
82210>>>>>            End
82210>>>>>>
82210>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
82211>>>>>        End
82211>>>>>>
82211>>>>>    End_Procedure
82212>>>>>
82212>>>>>    //****************************************************************************
82212>>>>>    // $Module type: PROCEDURE
82212>>>>>    // $Module name: Add_Focus
82212>>>>>    // $Author     : VOO
82212>>>>>    // Created     : 24-09-96 @ 19:43
82212>>>>>    //
82212>>>>>    // Description
82212>>>>>    //    During activation we will remove the old information and add the newly
82212>>>>>    //    found systeminformation
82212>>>>>    //
82212>>>>>    // $Rev History
82212>>>>>    //    24-09-96  Module header created
82212>>>>>    //****************************************************************************
82212>>>>>    Procedure Add_Focus Integer hoRoot
82214>>>>>        Forward Send Add_Focus hoRoot
82216>>>>>
82216>>>>>        Send Delete_Data
82217>>>>>
82217>>>>>        Set Changed_State To False
82218>>>>>        Set Read_Only_State To True
82219>>>>>
82219>>>>>        Send Show_ServicePack
82220>>>>>        Send Show_Versions   
82221>>>>>        Send Show_Drivers         
82222>>>>>        Send Show_HelpFile
82223>>>>>        Send Show_Current_Directory
82224>>>>>        Send Show_Filelist_Name          
82225>>>>>        If (ghoApplication <> 0) Begin
82227>>>>>            Send Show_WorkSpaceInformation // added To show WS info
82228>>>>>        End
82228>>>>>>
82228>>>>>        Send Show_Current_User 
82229>>>>>        Send Show_Windows_Directory 
82230>>>>>        Send Show_Screen_Size
82231>>>>>        Send Show_Page_Size
82232>>>>>        Send Show_EnterAsTab        
82233>>>>>        Send Show_Number_Format
82234>>>>>        Send Show_Date_Format
82235>>>>>        Send Show_Lock_Delay
82236>>>>>        Send Show_Lock_Timeout
82237>>>>>        Send Show_Date
82238>>>>>        Send Show_Systemresources
82239>>>>>        Send Show_Registration
82240>>>>>        Send Beginning_of_Data
82241>>>>>
82241>>>>>        Set Icon to 'default.ico'
82242>>>>>    End_Procedure
82243>>>>>End_Class
82244>>>>>
82244>>>>>//****************************************************************************
82244>>>>>// $Module type: OBJECT
82244>>>>>// $Module name: Sysinfo_Dialog
82244>>>>>// $Author     : VOO
82244>>>>>// Created     : 24-09-96 @ 18:47
82244>>>>>//
82244>>>>>// Description
82244>>>>>//    This object shows the systeminformation on the screen
82244>>>>>//
82244>>>>>// $Rev History
82244>>>>>//    24-09-96  Module header created
82244>>>>>//****************************************************************************
82244>>>>>Class SysInfoDialog Is A ModalPanel
82245>>>>>    Procedure Construct_Object
82247>>>>>        Forward Send Construct_Object
82249>>>>>
82249>>>>>        Set Label to C_$SystemInformation
82250>>>>>        Set Size to 140 267
82251>>>>>        Set piMinSize to 140 267
82252>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82253>>>>>        Set Border_Style to Border_Thick
82254>>>>>
82254>>>>>        Object oSysinfoDisplay Is A SysInfoDisplay
82256>>>>>            Set peAnchors to anAll
82257>>>>>        End_Object
82258>>>>>
82258>>>>>        Object oCloseButton Is A Button
82260>>>>>            Set Label To C_$Close
82261>>>>>            Set Location To 120 210
82262>>>>>            Set Message Item 0 To (Refproc (Close_Panel))
82263>>>>>            Set Default_State To True
82264>>>>>            Set peAnchors to anBottomRight
82265>>>>>        End_Object
82266>>>>>
82266>>>>>        On_Key kCancel Send Close_Panel
82267>>>>>    End_Procedure
82268>>>>>End_Class
82269>>>>>
82269>>>>>// Purpose:
82269>>>>>//
82269>>>>>// Ken Ross 12/17/96 5:16PM
82269>>>>>//
82269>>>>>Class AboutDialog Is A ModalPanel
82270>>>>>    Procedure Construct_Object
82272>>>>>        String sVdfRootDir
82272>>>>>
82272>>>>>        Forward Send Construct_Object
82274>>>>>
82274>>>>>        Set Label To C_$About
82275>>>>>        Set Size to 89 212
82276>>>>>        Set Locate_Mode To CENTER_ON_SCREEN
82277>>>>>
82277>>>>>        Object oSysInfoDialog Is A SysInfoDialog
82279>>>>>        End_Object
82280>>>>>
82280>>>>>        Object oBox Is A Container3d
82282>>>>>            Set Border_Style To Border_StaticEdge
82283>>>>>            Set Size to 63 202
82284>>>>>            Set Location To 4 5
82285>>>>>
82285>>>>>            Object oAboutGraphic Is A BitmapContainer
82287>>>>>                Set Border_Style To Border_None
82288>>>>>                Set Bitmap_Style To Bitmap_Center
82289>>>>>                Set Size To 48 48
82290>>>>>                Set Location To 7 2
82291>>>>>            End_Object
82292>>>>>
82292>>>>>            Object oProductName Is A TextBox
82294>>>>>                Set Label To C_$ProductName
82295>>>>>                Set Size To 10 45
82296>>>>>                Set Location To 8 53
82297>>>>>            End_Object
82298>>>>>
82298>>>>>            Object oVersion Is A TextBox
82300>>>>>                Set Label To C_$Version
82301>>>>>                Set Size To 10 25
82302>>>>>                Set Location To 21 53
82303>>>>>            End_Object
82304>>>>>
82304>>>>>            Object oCopyright Is A TextBox
82306>>>>>                Set Label To C_$Copyright
82307>>>>>                Set Size To 10 31
82308>>>>>                Set Location To 34 53
82309>>>>>            End_Object
82310>>>>>
82310>>>>>            Object oAuthor Is A TextBox
82312>>>>>                Set Label To C_$Author
82313>>>>>                Set Size To 10 22
82314>>>>>                Set Location To 46 53
82315>>>>>            End_Object
82316>>>>>        End_Object
82317>>>>>
82317>>>>>        Object oOKButton Is A Button
82319>>>>>            On_Item C_$OK Send Close_Panel
82320>>>>>            Set Size To 14 50
82321>>>>>            Set Location To 71 157
82322>>>>>        End_Object
82323>>>>>
82323>>>>>        Object oSysInfoButton Is A Button
82325>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
82326>>>>>            Set Size To 14 50
82327>>>>>            Set Location To 71 101
82328>>>>>        End_Object
82329>>>>>
82329>>>>>        On_Key Kcancel Send KeyAction Of oOKButton
82330>>>>>
82330>>>>>        Set Logo To "DacAbout.bmp"  // square bitmaps Of 42x42 work best
82331>>>>>    End_Procedure
82332>>>>>
82332>>>>>    Procedure Set ProductName String sProductName
82334>>>>>        Set Label Of oProductName To sProductName
82335>>>>>    End_Procedure
82336>>>>>
82336>>>>>    Procedure Set Version String sVersion
82338>>>>>        Set Label Of oVersion To sVersion
82339>>>>>    End_Procedure
82340>>>>>
82340>>>>>    Procedure Set Copyright string sCopyright
82342>>>>>        Set Label Of oCopyright To sCopyright
82343>>>>>    End_Procedure
82344>>>>>
82344>>>>>    Procedure Set Author String sAuthor
82346>>>>>        Set Label Of oAuthor To sAuthor
82347>>>>>    End_Procedure
82348>>>>>
82348>>>>>    Procedure Set Logo string sLogo
82350>>>>>        // square bitmaps Of 42x42 work best
82350>>>>>        Set Bitmap Of oAboutGraphic To sLogo
82351>>>>>    End_Procedure
82352>>>>>
82352>>>>>    Procedure Show_Sysinfo
82354>>>>>        Send Popup_Modal Of oSysinfoDialog
82355>>>>>    End_Procedure
82356>>>>>
82356>>>>>    Procedure End_Construct_Object
82358>>>>>        Handle hoVersionInfo
82358>>>>>        Boolean bIncluded
82358>>>>>        Integer iMajor iMinor iRelease iBuild
82358>>>>>        String sLabel
82358>>>>>
82358>>>>>        Get Label Of oVersion To sLabel
82359>>>>>        If (sLabel = C_$VERSION) Begin
82361>>>>>            // set it To the version info Of the program, if available
82361>>>>>            If (ghoApplication <> 0) Begin
82363>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
82364>>>>>                If (hoVersionInfo <> 0) Begin
82366>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
82367>>>>>                    If (bIncluded) Begin
82369>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
82370>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
82371>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
82372>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
82373>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
82374>>>>>                        Set Version to sLabel
82375>>>>>                    End
82375>>>>>>
82375>>>>>                End
82375>>>>>>
82375>>>>>            End
82375>>>>>>
82375>>>>>        End
82375>>>>>>
82375>>>>>
82375>>>>>        Forward Send End_Construct_Object
82377>>>>>    End_Procedure
82378>>>>>End_Class
82379>>>
82379>>>// *************************************************************************
82379>>>//  Public message. This is the default message. It is expected that you will
82379>>>//   create your own message to override this
82379>>>// *************************************************************************
82379>>>
82379>>>Procedure Activate_About
82382>>>   Send DoAbout "" "" "" "" ""
82383>>>End_Procedure
82384>>>
82384>>>// *************************************************************************
82384>>>//  Public message. It is expected that you will send this message (most
82384>>>//  likely from Activate_About. This creates an about object, activates it
82384>>>//  and destroys it when done. It is not exepected that you will augment this.
82384>>>// *************************************************************************
82384>>>
82384>>>Procedure DoAbout string sTitle string sVersion string sCopyRight string sAuthor string sBitmap
82387>>>        integer hoObj hoMain
82387>>>
82387>>>        // create object
82387>>>        Object About is an AboutDialog
82389>>>            // if no title passed use the label of the main panel
82389>>>            // (if a main panel exists).
82389>>>            if sTitle     eq '' Begin
82391>>>                Get Main_Window of desktop to hoMain
82392>>>                if hoMain Get Label of hoMain to sTitle
82395>>>            end
82395>>>>
82395>>>            set productname to sTitle
82396>>>            set version     to sVersion
82397>>>            set copyright   to sCopyRight
82398>>>            set author      to sAuthor
82399>>>            If sBitmap    ne '' ;               set logo to sBitMap // square bitmaps of 42x42 work best
82402>>>            Move self to hoObj // object Id
82403>>>        End_Object
82404>>>        Send Popup   of hoObj    // popup the about object
82405>>>        Send Destroy of hoObj // when done, it will be destroyed
82406>>>End_procedure
82407>        Use DemoSuggestionForm.vw
Including file: DemoSuggestionForm.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\DemoSuggestionForm.vw)
82407>>>Use Windows.pkg
82407>>>Use DFClient.pkg
82407>>>Use dbSuggestionForm.pkg
Including file: dbSuggestionForm.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbSuggestionForm.pkg)
82407>>>>>Use Dfentry.pkg
82407>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\WinSuggestion.pkg)
82407>>>>>>>// 
82407>>>>>>>
82407>>>>>>>Use Windows.pkg
82407>>>>>>>Use tWinStructs.pkg
82407>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\tSuggestion.pkg)
82407>>>>>>>>>// struct used for suggestion forms, representing an item of data
82407>>>>>>>>>Enum_List 
82407>>>>>>>>>    Define smFind
82407>>>>>>>>>    Define smValidationTable
82407>>>>>>>>>    Define smCustom
82407>>>>>>>>>End_Enum_List
82407>>>>>>>>>
82407>>>>>>>>>Struct tSuggestion
82407>>>>>>>>>    String sRowId
82407>>>>>>>>>    String[] aValues
82407>>>>>>>>>End_Struct
82407>>>>>>>>>
82407>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cTimer.pkg)
82407>>>>>>>>>// cTimer class
82407>>>>>>>>>//
82407>>>>>>>>>// This supercedes the DFTimer class. 
82407>>>>>>>>>// It is simpler and more flexible
82407>>>>>>>>>
82407>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\Dftimer.pkg)
82407>>>>>>>>>>>//************************************************************************
82407>>>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
82407>>>>>>>>>>>//
82407>>>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
82407>>>>>>>>>>>// All rights reserved.
82407>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//************************************************************************
82407>>>>>>>>>>>//  Description:
82407>>>>>>>>>>>//      This package contains all components needed to implement timers
82407>>>>>>>>>>>//      in a DataFlex 4 program.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
82407>>>>>>>>>>>//************************************************************************
82407>>>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
82407>>>>>>>>>>>//                handle before trying to set or kill a timer.
82407>>>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
82407>>>>>>>>>>>//                handle before trying to kill a timer.
82407>>>>>>>>>>>//                The windows handle might not exist anymore when the
82407>>>>>>>>>>>//                program is being exited using Exit_Application.
82407>>>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
82407>>>>>>>>>>>//                a bug where set Timeout started inactive timers.
82407>>>>>>>>>>>//                Added code to force timer object to desktop
82407>>>>>>>>>>>//************************************************************************
82407>>>>>>>>>>>// CLASS DFTimer
82407>>>>>>>>>>>//
82407>>>>>>>>>>>// Usage:
82407>>>>>>>>>>>//    Object MyTimer is a DFTimer
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
82407>>>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
82407>>>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
82407>>>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
82407>>>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
82407>>>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//        // Augment when no Timer_Message
82407>>>>>>>>>>>//        Procedure OnTimer
82407>>>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
82407>>>>>>>>>>>//        End_Procedure
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    End_Object
82407>>>>>>>>>>>//
82407>>>>>>>>>>>// DESCRIPTION
82407>>>>>>>>>>>//      Objects of this class can be used to trigger an event after a
82407>>>>>>>>>>>//      certain amount of time has passed. You can specify this time
82407>>>>>>>>>>>//      by setting the Timeout property of the object. This timeout
82407>>>>>>>>>>>//      is in miliseconds.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
82407>>>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
82407>>>>>>>>>>>//      you want the timer to do. By default this OnTimer event
82407>>>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
82407>>>>>>>>>>>//      been specified.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//      By default, you have to activate a timer by setting its
82407>>>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
82407>>>>>>>>>>>//      inside a user-interface object, it can also be activated
82407>>>>>>>>>>>//      automatically when this user-interface object is being
82407>>>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
82407>>>>>>>>>>>//      which is the default setting. In such a case, the timer will
82407>>>>>>>>>>>//      also automatically being stopped when the user-interface
82407>>>>>>>>>>>//      object is taken of the screen. This depends on the
82407>>>>>>>>>>>//      Auto_Stop_Timer state to happen.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//      When you need to set a new timeout value, you can do so
82407>>>>>>>>>>>//      even when the timer is active. It will adjust the timeout
82407>>>>>>>>>>>//      immediately.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
82407>>>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
82407>>>>>>>>>>>//      it might put your program on hold when other programs are very
82407>>>>>>>>>>>//      busy. In such a case, you will only receive one timer event
82407>>>>>>>>>>>//      after the process stopped. There is no way, other than
82407>>>>>>>>>>>//      calculating it yourself, to determine how many time has passed
82407>>>>>>>>>>>//      or how many timer event should have happened since the last
82407>>>>>>>>>>>//      timer event or timer activation.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>// PUBLIC INTERFACE
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    PROPERTIES
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
82407>>>>>>>>>>>//                     automatically when the object will be (virtually)
82407>>>>>>>>>>>//                     paged on the screen.
82407>>>>>>>>>>>//                     Example: When a timer object has been placed
82407>>>>>>>>>>>//                     inside a view, then the timer will be activated
82407>>>>>>>>>>>//                     when the view is activated.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
82407>>>>>>>>>>>//                     automatically when the object will be (virtually)
82407>>>>>>>>>>>//                     taken off the screen.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
82407>>>>>>>>>>>//                     timeout value must be set in miliseconds.
82407>>>>>>>>>>>//                     This property may be set even when the timer is
82407>>>>>>>>>>>//                     active. The new timeout value will be applied
82407>>>>>>>>>>>//                     immediately.
82407>>>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
82407>>>>>>>>>>>//                     depends on Windows to deliver the message to our
82407>>>>>>>>>>>//                     application.
82407>>>>>>>>>>>//                     Default 1000.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Timer_Active_State
82407>>>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
82407>>>>>>>>>>>//                     deactivate the timer.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
82407>>>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
82407>>>>>>>>>>>//                     this message will be send to the object itself
82407>>>>>>>>>>>//                     unless a Timer_Object as been specified.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
82407>>>>>>>>>>>//                     to receive the Timer_Message whenever a timer
82407>>>>>>>>>>>//                     event occurs. This value has no meaning when
82407>>>>>>>>>>>//                     no Timer_Message has been set.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    METHODS
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    OnTimer          This event will happen whenever the specified
82407>>>>>>>>>>>//                     amount of time has passed and the timer is
82407>>>>>>>>>>>//                     active. By default it sends the message in
82407>>>>>>>>>>>//                     the Timer_Message property to the object in
82407>>>>>>>>>>>//                     the Timer_Object when these have been specified.
82407>>>>>>>>>>>//                     When you don't need this, you can just override
82407>>>>>>>>>>>//                     the OnTimer event.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>// PUBLIC INTERFACE
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
82407>>>>>>>>>>>//                     it becomes active as part or a user-interface
82407>>>>>>>>>>>//                     object.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
82407>>>>>>>>>>>//                     it is deactivated as part or a user-interface
82407>>>>>>>>>>>//                     object.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
82407>>>>>>>>>>>//
82407>>>>>>>>>>>Use LanguageText.pkg
82407>>>>>>>>>>>Use Windows.pkg
82407>>>>>>>>>>>Use WinUser.pkg
82407>>>>>>>>>>>
82407>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
82408>>>>>>>>>>>
82408>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
82409>>>>>>>>>>>
82409>>>>>>>>>>>// This global integer holds the ID of the object
82409>>>>>>>>>>>// that manages all timers.
82409>>>>>>>>>>>Integer giTimerManager
82409>>>>>>>>>>>
82409>>>>>>>>>>>// This class is used to store the object IDs
82409>>>>>>>>>>>// of the active timer objects. It augments
82409>>>>>>>>>>>// the Destroy_Object procedure to notify
82409>>>>>>>>>>>// the DFTimerManager to kill all its active
82409>>>>>>>>>>>// timers.
82409>>>>>>>>>>>// NOTE: This class looks very much like the
82409>>>>>>>>>>>// Set class. I didn't want to use Set because
82409>>>>>>>>>>>// Remove_Element shifts items which I don't
82409>>>>>>>>>>>// want to happen because item numbers are used
82409>>>>>>>>>>>// as timerIDs.
82409>>>>>>>>>>>
82409>>>>>>>>>>>Class TimersArray is an Array
82410>>>>>>>>>>>
82410>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
82412>>>>>>>>>>>        Integer iMax
82412>>>>>>>>>>>        Integer iItem
82412>>>>>>>>>>>        Integer iValue
82412>>>>>>>>>>>        Get Item_count to iMax
82413>>>>>>>>>>>        Decrement iMax
82414>>>>>>>>>>>        For iItem from 1 to iMax
82420>>>>>>>>>>>>
82420>>>>>>>>>>>            Get Integer_Value item iItem to iValue
82421>>>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
82424>>>>>>>>>>>        Loop
82425>>>>>>>>>>>>
82425>>>>>>>>>>>        Function_Return -1
82426>>>>>>>>>>>    End_Function
82427>>>>>>>>>>>
82427>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
82429>>>>>>>>>>>        Integer iItem
82429>>>>>>>>>>>        Get Find_Object iObj to iItem
82430>>>>>>>>>>>        If iItem LT 0 Begin
82432>>>>>>>>>>>            Get Find_Object 0 to iItem
82433>>>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
82436>>>>>>>>>>>        End
82436>>>>>>>>>>>>
82436>>>>>>>>>>>        Set Array_Value item iItem to iObj
82437>>>>>>>>>>>        Procedure_Return iItem
82438>>>>>>>>>>>    End_Procedure
82439>>>>>>>>>>>
82439>>>>>>>>>>>    Procedure Remove_Object Integer iObj
82441>>>>>>>>>>>        Integer iItem
82441>>>>>>>>>>>        Get Find_Object iObj to iItem
82442>>>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
82445>>>>>>>>>>>    End_Procedure
82446>>>>>>>>>>>
82446>>>>>>>>>>>    Procedure Destroy_Object
82448>>>>>>>>>>>        Delegate Send Kill_All_Timers
82450>>>>>>>>>>>        Forward Send Destroy_Object
82452>>>>>>>>>>>    End_Procedure
82453>>>>>>>>>>>
82453>>>>>>>>>>>End_Class // TimersArray
82454>>>>>>>>>>>
82454>>>>>>>>>>>// This class is the actual timer manager
82454>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
82454>>>>>>>>>>>// has been send. This message needs two arguments. The first
82454>>>>>>>>>>>// is the objectID of the object to receive the timer event,
82454>>>>>>>>>>>// and the second is state. The object which ID has been passed,
82454>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
82454>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
82454>>>>>>>>>>>// timer event occurs.
82454>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
82454>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
82454>>>>>>>>>>>// is the itemnumber of the object in the array.
82454>>>>>>>>>>>//
82454>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
82455>>>>>>>>>>>
82455>>>>>>>>>>>    Procedure Construct_Object
82457>>>>>>>>>>>
82457>>>>>>>>>>>        Forward Send Construct_Object
82459>>>>>>>>>>>
82459>>>>>>>>>>>        Set Visible_State to FALSE
82460>>>>>>>>>>>
82460>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
82461>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
82462>>>>>>>>>>>
82462>>>>>>>>>>>        Object TimersArray is a TimersArray
82464>>>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
82465>>>>>>>>>>>        End_Object
82466>>>>>>>>>>>
82466>>>>>>>>>>>        Move self to giTimerManager
82467>>>>>>>>>>>
82467>>>>>>>>>>>    End_Procedure
82468>>>>>>>>>>>
82468>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
82470>>>>>>>>>>>        Integer iTimerID
82470>>>>>>>>>>>        Integer iTimeout
82470>>>>>>>>>>>        Integer iResult
82470>>>>>>>>>>>        Integer iSet
82470>>>>>>>>>>>        Dword   nResult
82470>>>>>>>>>>>        Handle  hWnd
82470>>>>>>>>>>>
82470>>>>>>>>>>>        // Get the handle of this object
82470>>>>>>>>>>>        Get Window_Handle to hWnd
82471>>>>>>>>>>>        If (Not(hWnd)) Begin
82473>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82474>>>>>>>>>>>>
82474>>>>>>>>>>>            Procedure_Return
82475>>>>>>>>>>>        End
82475>>>>>>>>>>>>
82475>>>>>>>>>>>
82475>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
82475>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82478>>>>>>>>>>>
82478>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82479>>>>>>>>>>>
82479>>>>>>>>>>>        If (iSet) Begin
82481>>>>>>>>>>>
82481>>>>>>>>>>>            // Let's create or modify a timer
82481>>>>>>>>>>>            If iState Begin
82483>>>>>>>>>>>
82483>>>>>>>>>>>                // Get the exising to new TimerID
82483>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
82484>>>>>>>>>>>
82484>>>>>>>>>>>                // Set/Modify the timer
82484>>>>>>>>>>>                Get Timeout of iObj to iTimeout
82485>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
82486>>>>>>>>>>>                If Not iResult Begin
82488>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
82489>>>>>>>>>>>>
82489>>>>>>>>>>>                    Procedure_Return
82490>>>>>>>>>>>                End
82490>>>>>>>>>>>>
82490>>>>>>>>>>>
82490>>>>>>>>>>>            End
82490>>>>>>>>>>>>
82490>>>>>>>>>>>
82490>>>>>>>>>>>            // Let's kill an existing timer
82490>>>>>>>>>>>            Else Begin
82491>>>>>>>>>>>
82491>>>>>>>>>>>                // Look up the object in the set
82491>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
82492>>>>>>>>>>>
82492>>>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
82495>>>>>>>>>>>
82495>>>>>>>>>>>                // Kill the timer
82495>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
82496>>>>>>>>>>>                If Not iResult Begin
82498>>>>>>>>>>>                    Move (GetLastError()) to nResult
82499>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
82500>>>>>>>>>>>>
82500>>>>>>>>>>>                    Procedure_Return
82501>>>>>>>>>>>                End
82501>>>>>>>>>>>>
82501>>>>>>>>>>>
82501>>>>>>>>>>>                // Remove the objectID
82501>>>>>>>>>>>                Send Remove_Object to iSet iObj
82502>>>>>>>>>>>            End
82502>>>>>>>>>>>>
82502>>>>>>>>>>>        End
82502>>>>>>>>>>>>
82502>>>>>>>>>>>    End_Procedure
82503>>>>>>>>>>>
82503>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
82505>>>>>>>>>>>        Integer iResult
82505>>>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
82506>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
82507>>>>>>>>>>>    End_Function
82508>>>>>>>>>>>
82508>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
82508>>>>>>>>>>>    Procedure Kill_All_Timers
82510>>>>>>>>>>>        Integer iMax
82510>>>>>>>>>>>        Integer iSet
82510>>>>>>>>>>>        Integer iItem
82510>>>>>>>>>>>        Integer iObj
82510>>>>>>>>>>>        Integer iResult
82510>>>>>>>>>>>        Handle  hWnd
82510>>>>>>>>>>>
82510>>>>>>>>>>>        // Get the handle of this object
82510>>>>>>>>>>>        Get Window_Handle to hWnd
82511>>>>>>>>>>>        If (Not(hWnd)) Begin
82513>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
82514>>>>>>>>>>>>
82514>>>>>>>>>>>            Procedure_Return
82515>>>>>>>>>>>        End
82515>>>>>>>>>>>>
82515>>>>>>>>>>>
82515>>>>>>>>>>>        // If the window handle is no longer valid, we
82515>>>>>>>>>>>        // leave this procedure. This can happen when the
82515>>>>>>>>>>>        // program is begin aborted using Exit_Application
82515>>>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
82518>>>>>>>>>>>
82518>>>>>>>>>>>        // Scan the set and kill all known timers
82518>>>>>>>>>>>        Move (TimersArray(self)) to iSet
82519>>>>>>>>>>>        If (iSet) Begin
82521>>>>>>>>>>>            Get Item_Count of iSet to iMax
82522>>>>>>>>>>>            Decrement iMax
82523>>>>>>>>>>>            For iItem From 1 to iMax
82529>>>>>>>>>>>>
82529>>>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
82530>>>>>>>>>>>                If iObj Begin
82532>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
82533>>>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
82534>>>>>>>>>>>                End
82534>>>>>>>>>>>>
82534>>>>>>>>>>>            Loop
82535>>>>>>>>>>>>
82535>>>>>>>>>>>        End
82535>>>>>>>>>>>>
82535>>>>>>>>>>>
82535>>>>>>>>>>>    End_Procedure
82536>>>>>>>>>>>
82536>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
82538>>>>>>>>>>>        Integer iObj
82538>>>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
82539>>>>>>>>>>>        If Not iObj Begin
82541>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
82542>>>>>>>>>>>>
82542>>>>>>>>>>>            Procedure_Return
82543>>>>>>>>>>>        End
82543>>>>>>>>>>>>
82543>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
82544>>>>>>>>>>>    End_Procedure
82545>>>>>>>>>>>
82545>>>>>>>>>>>    Procedure Destroy_Object
82547>>>>>>>>>>>        Send Kill_All_Timers
82548>>>>>>>>>>>        Forward Send Destroy_Object
82550>>>>>>>>>>>        Move 0 to giTimerManager
82551>>>>>>>>>>>    End_Procedure
82552>>>>>>>>>>>
82552>>>>>>>>>>>End_Class // DFTimerManger
82553>>>>>>>>>>>
82553>>>>>>>>>>>
82553>>>>>>>>>>>
82553>>>>>>>>>>>
82553>>>>>>>>>>>// This class acts as a container for the
82553>>>>>>>>>>>// timer manager object. This is needed because
82553>>>>>>>>>>>// A DFTimerManager object created directly at the
82553>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
82553>>>>>>>>>>>// need to create a Windoows timer. By placing
82553>>>>>>>>>>>// this non-visual container around the timer
82553>>>>>>>>>>>// manager, it does get a Window_Handle.
82553>>>>>>>>>>>// The procedure End_Construct_Object has been
82553>>>>>>>>>>>// augmented to create a window and also
82553>>>>>>>>>>>// automatically page all children, which will
82553>>>>>>>>>>>// be the timer manager.
82553>>>>>>>>>>>//
82553>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
82554>>>>>>>>>>>
82554>>>>>>>>>>>    Procedure Construct_Object
82556>>>>>>>>>>>        Forward Send Construct_Object
82558>>>>>>>>>>>        Set Visible_State to FALSE
82559>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
82561>>>>>>>>>>>        End_Object
82562>>>>>>>>>>>    End_Procedure
82563>>>>>>>>>>>
82563>>>>>>>>>>>    Procedure End_Construct_Object
82565>>>>>>>>>>>        Forward Send End_Construct_Object
82567>>>>>>>>>>>        Send Page_Object TRUE
82568>>>>>>>>>>>        Broadcast Send Page_Object TRUE
82570>>>>>>>>>>>    End_Procedure
82571>>>>>>>>>>>
82571>>>>>>>>>>>End_Class
82572>>>>>>>>>>>
82572>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
82572>>>>>>>>>>>
82572>>>>>>>>>>>
82572>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
82572>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
82572>>>>>>>>>>>Class DFTimer is a Textbox
82573>>>>>>>>>>>
82573>>>>>>>>>>>    Procedure Construct_Object
82575>>>>>>>>>>>        Forward Send Construct_Object
82577>>>>>>>>>>>
82577>>>>>>>>>>>        // Make sure this object never appears
82577>>>>>>>>>>>        Set Visible_State to FALSE
82578>>>>>>>>>>>
82578>>>>>>>>>>>        Property Integer Private.Timeout    1000
82579>>>>>>>>>>>
82579>>>>>>>>>>>        Property Integer Timer_Message      0
82580>>>>>>>>>>>        Property Integer Timer_Object       0
82581>>>>>>>>>>>        Property Integer Auto_Start_State   True
82582>>>>>>>>>>>        Property Integer Auto_Stop_State    True
82583>>>>>>>>>>>    End_Procedure
82584>>>>>>>>>>>
82584>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
82586>>>>>>>>>>>        Integer iObj
82586>>>>>>>>>>>        Move self to iObj
82587>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
82590>>>>>>>>>>>    End_Procedure
82591>>>>>>>>>>>
82591>>>>>>>>>>>    Function Timer_Active_State Returns Integer
82593>>>>>>>>>>>        Integer iState
82593>>>>>>>>>>>        Integer iObj
82593>>>>>>>>>>>        Move self to iObj
82594>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
82597>>>>>>>>>>>        Function_Return iState
82598>>>>>>>>>>>    End_Function
82599>>>>>>>>>>>
82599>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
82601>>>>>>>>>>>        Integer iActive
82601>>>>>>>>>>>        Set Private.Timeout to iTimeout
82602>>>>>>>>>>>        Get Timer_Active_State to iActive
82603>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
82606>>>>>>>>>>>    End_Procedure
82607>>>>>>>>>>>
82607>>>>>>>>>>>    Function Timeout Returns Integer
82609>>>>>>>>>>>        Integer iTimeout
82609>>>>>>>>>>>        Get Private.Timeout to iTimeout
82610>>>>>>>>>>>        Function_Return iTimeout
82611>>>>>>>>>>>    End_Function
82612>>>>>>>>>>>
82612>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
82614>>>>>>>>>>>        Integer iMsg
82614>>>>>>>>>>>        Integer iObj
82614>>>>>>>>>>>        Get Timer_Message to iMsg
82615>>>>>>>>>>>        If (iMsg) Begin
82617>>>>>>>>>>>            Get Timer_Object  to iObj
82618>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
82621>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
82623>>>>>>>>>>>        End
82623>>>>>>>>>>>>
82623>>>>>>>>>>>    End_Procedure
82624>>>>>>>>>>>
82624>>>>>>>>>>>    // Augmented to Auto_Start a timer
82624>>>>>>>>>>>    //
82624>>>>>>>>>>>    Procedure Page_Object Integer iState
82626>>>>>>>>>>>        Forward Send Page_Object iState
82628>>>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
82631>>>>>>>>>>>    End_Procedure
82632>>>>>>>>>>>
82632>>>>>>>>>>>    // Augmented to Auto_Stop a timer
82632>>>>>>>>>>>    //
82632>>>>>>>>>>>    Procedure Page_Delete
82634>>>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
82637>>>>>>>>>>>        Forward Send Page_Delete
82639>>>>>>>>>>>    End_Procedure
82640>>>>>>>>>>>
82640>>>>>>>>>>>    // Augmented to stop the timer
82640>>>>>>>>>>>    //
82640>>>>>>>>>>>    Procedure Destroy_Object
82642>>>>>>>>>>>        Set Timer_Active_State to FALSE
82643>>>>>>>>>>>        Forward Send Destroy_Object
82645>>>>>>>>>>>    End_Procedure
82646>>>>>>>>>>>
82646>>>>>>>>>>>End_Class // DFTimer
82647>>>>>>>>>>>
82647>>>>>>>>>>>//
82647>>>>>>>>>>>// This was moved into a method so it can be reliable created
82647>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
82647>>>>>>>>>>>//
82647>>>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
82649>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
82649>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
82651>>>>>>>>>>>    End_Object
82652>>>>>>>>>>>End_Procedure
82653>>>>>>>>>>>
82653>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
82654>>>>>>>>>>>
82654>>>>>>>>>
82654>>>>>>>>>Class cTimer is a cObject
82655>>>>>>>>>
82655>>>>>>>>>    Procedure Construct_Object
82657>>>>>>>>>        Forward Send Construct_Object
82659>>>>>>>>>        Property Integer piPrivate_Timeout 1000
82660>>>>>>>>>    End_Procedure
82661>>>>>>>>>
82661>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
82663>>>>>>>>>        If giTimerManager Begin
82665>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
82666>>>>>>>>>        End
82666>>>>>>>>>>
82666>>>>>>>>>    End_Procedure
82667>>>>>>>>>
82667>>>>>>>>>    Function pbEnabled Returns Boolean
82669>>>>>>>>>        Boolean bEnabled
82669>>>>>>>>>        If giTimerManager Begin
82671>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
82672>>>>>>>>>        End
82672>>>>>>>>>>
82672>>>>>>>>>        Function_Return bEnabled
82673>>>>>>>>>    End_Function
82674>>>>>>>>>
82674>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
82676>>>>>>>>>        Boolean bEnabled
82676>>>>>>>>>        Set piPrivate_Timeout to iTimeout
82677>>>>>>>>>        Get pbEnabled to bEnabled
82678>>>>>>>>>        If bEnabled Begin
82680>>>>>>>>>            Set pbEnabled to True
82681>>>>>>>>>        End
82681>>>>>>>>>>
82681>>>>>>>>>    End_Procedure
82682>>>>>>>>>
82682>>>>>>>>>    Function piTimeout Returns Integer
82684>>>>>>>>>        Integer iTimeout
82684>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82685>>>>>>>>>        Function_Return iTimeout
82686>>>>>>>>>    End_Function
82687>>>>>>>>>
82687>>>>>>>>>    Procedure OnTimer
82689>>>>>>>>>    End_Procedure
82690>>>>>>>>>    
82690>>>>>>>>>    // this is needed by the timer manager 
82690>>>>>>>>>    Function Timeout Returns Integer
82692>>>>>>>>>        Integer iTimeout
82692>>>>>>>>>        Get piPrivate_Timeout to iTimeout
82693>>>>>>>>>        Function_Return iTimeout
82694>>>>>>>>>    End_Function
82695>>>>>>>>>
82695>>>>>>>>>    Procedure Destroy_Object
82697>>>>>>>>>        Set pbEnabled to False
82698>>>>>>>>>        Forward Send Destroy_Object
82700>>>>>>>>>    End_Procedure
82701>>>>>>>>>
82701>>>>>>>>>End_Class
82702>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cRichEdit.pkg)
82702>>>>>>>>>use Windows.pkg
82702>>>>>>>>>Use cEdit_Mixin.pkg
82702>>>>>>>>>
82702>>>>>>>>>// DFO: cRichEdit.Dfo
82702>>>>>>>>>// DFC: cRichEdit.Dfc
82702>>>>>>>>>
82702>>>>>>>>>// constants used for RichEdit Properties
82702>>>>>>>>>// peAlignment 
82702>>>>>>>>>Enum_List 
82702>>>>>>>>>    Define alLeft   for 1 
82702>>>>>>>>>    Define alRight  for 2 
82702>>>>>>>>>    Define alCenter for 3 
82702>>>>>>>>>End_Enum_List 
82702>>>>>>>>>
82702>>>>>>>>>// peBullets 
82702>>>>>>>>>Enum_List 
82702>>>>>>>>>    Define buNone 
82702>>>>>>>>>    Define buBullets 
82702>>>>>>>>>    Define buArabicNumbers 
82702>>>>>>>>>    Define buLowerLetters 
82702>>>>>>>>>    Define buUpperLetters 
82702>>>>>>>>>    Define buLowerRomans 
82702>>>>>>>>>    Define buUpperRomans 
82702>>>>>>>>>End_Enum_List 
82702>>>>>>>>>
82702>>>>>>>>>// peBulletStyle 
82702>>>>>>>>>Enum_List 
82702>>>>>>>>>    Define busRightParen   for 0 
82702>>>>>>>>>    Define busEncloseParen for 256 
82702>>>>>>>>>    Define busPeriod       for 512 
82702>>>>>>>>>    Define busNumberOnly   for 768 
82702>>>>>>>>>    Define busNoDisplay    for 1024 
82702>>>>>>>>>End_Enum_List
82702>>>>>>>>>    
82702>>>>>>>>>// peLineSpacingType
82702>>>>>>>>>Enum_List 
82702>>>>>>>>>    Define lstSingle
82702>>>>>>>>>    Define lstSingleAndOneHalf
82702>>>>>>>>>    Define lstDouble
82702>>>>>>>>>End_Enum_List
82702>>>>>>>>>
82702>>>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82703>>>>>>>>>
82703>>>>>>>>>    Procedure Construct_Object
82705>>>>>>>>>        Forward Send Construct_Object
82707>>>>>>>>>        Send Define_cEdit_Mixin
82708>>>>>>>>>
82708>>>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82709>>>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82710>>>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82711>>>>>>>>>
82711>>>>>>>>>    End_Procedure // Construct_Object
82712>>>>>>>>>
82712>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
82713>>>>>>>>>    
82713>>>>>>>>>    Procedure ToggleBold
82715>>>>>>>>>        Set pbBold to (not(pbBold(self))) 
82716>>>>>>>>>    end_procedure
82717>>>>>>>>>    
82717>>>>>>>>>    Procedure ToggleItalics
82719>>>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82720>>>>>>>>>    end_procedure
82721>>>>>>>>>    
82721>>>>>>>>>    Procedure ToggleUnderline
82723>>>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82724>>>>>>>>>    end_procedure
82725>>>>>>>>>
82725>>>>>>>>>End_Class
82726>>>>>>>>>
82726>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\sql.pkg)
82726>>>>>>>>>//*****************************************************************************
82726>>>>>>>>>//*** SQL.pkg                                                               ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** Author: Ben Weijers                                                   ***
82726>>>>>>>>>//***         Data Access Wordwide                                          ***
82726>>>>>>>>>//***         14 February 2000                                              ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** Purpose:                                                              ***
82726>>>>>>>>>//***       Embedded SQL classes for use with Data Access Worldwide CLI     ***
82726>>>>>>>>>//***       Connectivty Kits.                                               ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** Last update:                                                          ***
82726>>>>>>>>>//***       February 2014. Current CLI Connectivity Kit 6.0.0.28            ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** !! Please Note !!                                                     ***
82726>>>>>>>>>//***       -This version of sql.pkg will only work with CLI Connectivity   ***
82726>>>>>>>>>//***        Kits 6.0.0.28 or later.                                        ***
82726>>>>>>>>>//***       -This version of sql.pkg will no longer function with DataFlex  ***
82726>>>>>>>>>//***        character mode (DataFlex 3.2). To use embedded SQL with        ***
82726>>>>>>>>>//**         DataFlex character mode, use sqlold.pkg.                       ***
82726>>>>>>>>>//***       -This version of sql.pkg no longer contains the embedded SQL    ***
82726>>>>>>>>>//***        command interface. The command interface is still available    ***
82726>>>>>>>>>//***        in sqlold.pkg                                                  ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** Changes:                                                              ***
82726>>>>>>>>>//***       February 2014. CLI Connectivity Kit 6.0.0.28                    ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//***       Several performances improvements to speed up SQLColumnValue    ***
82726>>>>>>>>>//***       and SQLGetData                                                  ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//***       New functions:                                                  ***
82726>>>>>>>>>//***           Function SQLFetchRowValues Returns String[]                 ***
82726>>>>>>>>>//***               Fetches a row and returns all columns in an array.      ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//***           Function SQLFetchResultsetValues Returns String[][]         ***
82726>>>>>>>>>//***               Fetches all rows of a result set and returns the        ***
82726>>>>>>>>>//***               result set as a 2-dimensial array.                      ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*****************************************************************************
82726>>>>>>>>>
82726>>>>>>>>>Use CLI.pkg
82726>>>>>>>>>
82726>>>>>>>>>//*** Global storage for results
82726>>>>>>>>>Integer SQLResult
82726>>>>>>>>>
82726>>>>>>>>>//*** Embedded SQL function constants
82726>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
82726>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
82726>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
82726>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
82726>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
82726>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
82726>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
82726>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
82726>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
82726>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
82726>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
82726>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
82726>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
82726>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
82726>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
82726>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
82726>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
82726>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
82726>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
82726>>>>>>>>>Define FUNC_SQLCALL                For 1000019
82726>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
82726>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
82726>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
82726>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
82726>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
82726>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
82726>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
82726>>>>>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
82726>>>>>>>>>
82726>>>>>>>>>//*** Embedded SQL statement attribute constants
82726>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
82726>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
82726>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
82726>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
82726>>>>>>>>>
82726>>>>>>>>>//*** Embedded SQL column attribute constants
82726>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
82726>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
82726>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
82726>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
82726>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
82726>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
82726>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
82726>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
82726>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
82726>>>>>>>>>
82726>>>>>>>>>
82726>>>>>>>>>
82726>>>>>>>>>//*****************************************************************************
82726>>>>>>>>>//*** Class  : cSQLStatement                                                ***
82726>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
82726>>>>>>>>>//***                                                                       ***
82726>>>>>>>>>//*** Description:                                                          ***
82726>>>>>>>>>//***   An object is created for each statement. These will be children     ***
82726>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
82726>>>>>>>>>//***   of these.                                                           ***
82726>>>>>>>>>//*****************************************************************************
82726>>>>>>>>>
82726>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
82726>>>>>>>>>Integer giLastSQLhdbc
82726>>>>>>>>>Integer giLastSQLhstmt
82726>>>>>>>>>
82726>>>>>>>>>Move -1 to giLastSQLhdbc
82727>>>>>>>>>Move -1 to giLastSQLhstmt
82728>>>>>>>>>
82728>>>>>>>>>Struct tSQLColumn
82728>>>>>>>>>    Integer iSQLType
82728>>>>>>>>>    Integer iSQLSize
82728>>>>>>>>>    Integer iSQLPrecision
82728>>>>>>>>>    Integer iVariableDataType
82728>>>>>>>>>End_Struct
82728>>>>>>>>>
82728>>>>>>>>>Class cSQLStatement is a cObject
82729>>>>>>>>>
82729>>>>>>>>>    Procedure Construct_object 
82731>>>>>>>>>        Forward Send Construct_object 
82733>>>>>>>>>
82733>>>>>>>>>        Property Handle  phCLIStatementHandle   0
82734>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
82735>>>>>>>>>        Property String  psDriverID             ""
82736>>>>>>>>>        
82736>>>>>>>>>        Property Integer piLastColumn      0
82737>>>>>>>>>        Property Integer piLastArgument    0
82738>>>>>>>>>        Property Integer piBindFile        0
82739>>>>>>>>>        Property Integer piColumnCount     0
82740>>>>>>>>>
82740>>>>>>>>>        // Allocated buffer for SQLColumnValue. 
82740>>>>>>>>>        // Allocated size is size of the largest (not variable length) column
82740>>>>>>>>>        Property String  psMaxColValue     ""
82741>>>>>>>>>
82741>>>>>>>>>        // True if there is at least 1 column with a variable length data type                 
82741>>>>>>>>>        Property Integer piHasVariableDataType  0
82742>>>>>>>>>
82742>>>>>>>>>        // Max size of buffer for variable length data. Default 16000        
82742>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000  
82743>>>>>>>>>
82743>>>>>>>>>        // Allocated buffer for SQLGetData. 
82743>>>>>>>>>        Property String  psVariableBuffer  ""
82744>>>>>>>>>
82744>>>>>>>>>        // Allocated size of psVariableBuffer
82744>>>>>>>>>        Property Integer piVariableBufferLength 0
82745>>>>>>>>>
82745>>>>>>>>>        // Stores column properties of a result set.
82745>>>>>>>>>        Property tSQLColumn[] paSQLColumns
82746>>>>>>>>>        
82746>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
82746>>>>>>>>>        //               0    = Fetch returned no data.
82746>>>>>>>>>        //               <> 0 = Row fetched
82746>>>>>>>>>        Property Integer piFetchResult     0
82747>>>>>>>>>
82747>>>>>>>>>
82747>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
82748>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
82749>>>>>>>>>
82749>>>>>>>>>    End_Procedure 
82750>>>>>>>>>
82750>>>>>>>>>    //***
82750>>>>>>>>>    //*** Procedure: StoreStatementInfo
82750>>>>>>>>>    //*** Purpose  : Store basic information about the statement.
82750>>>>>>>>>    //***
82750>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
82752>>>>>>>>>        
82752>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
82753>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
82754>>>>>>>>>        Set psDriverID             to sDrvrId
82755>>>>>>>>>        
82755>>>>>>>>>    End_Procedure 
82756>>>>>>>>>
82756>>>>>>>>>
82756>>>>>>>>>    //***
82756>>>>>>>>>    //*** Procedure: DestroySQLStatement
82756>>>>>>>>>    //*** Purpose  : Destroy the cSQLStatement object
82756>>>>>>>>>    //***
82756>>>>>>>>>    Procedure DestroySQLStatement
82758>>>>>>>>>        Send Destroy
82759>>>>>>>>>    End_Procedure 
82760>>>>>>>>>
82760>>>>>>>>>    //***
82760>>>>>>>>>    //*** Procedure: HandleError
82760>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
82760>>>>>>>>>    //***
82760>>>>>>>>>
82760>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
82762>>>>>>>>>        Integer iErrHandle
82762>>>>>>>>>        Integer iErrNum
82762>>>>>>>>>        String  sLocationInfo
82762>>>>>>>>>
82762>>>>>>>>>        //*** Get the DataFlex statement identifier
82762>>>>>>>>>        Move Self To iErrHandle
82763>>>>>>>>>
82763>>>>>>>>>        //*** Determine error number
82763>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
82766>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
82770>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
82774>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
82776>>>>>>>>>
82776>>>>>>>>>        //*** Create location ifnormation
82776>>>>>>>>>        Move "[" To sLocationInfo
82777>>>>>>>>>        If (sOriginMsg <> "") Begin
82779>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82780>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82781>>>>>>>>>        End
82781>>>>>>>>>>
82781>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82782>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82783>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82784>>>>>>>>>
82784>>>>>>>>>        //*** Generate the error
82784>>>>>>>>>        Error iErrNum sLocationInfo
82785>>>>>>>>>>
82785>>>>>>>>>    End_Procedure
82786>>>>>>>>>
82786>>>>>>>>>
82786>>>>>>>>>
82786>>>>>>>>>    //***
82786>>>>>>>>>    //*** Procedure: StmtError
82786>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
82786>>>>>>>>>    //***
82786>>>>>>>>>
82786>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
82788>>>>>>>>>        Integer iErrHandle
82788>>>>>>>>>        String  sLocationInfo
82788>>>>>>>>>
82788>>>>>>>>>        //*** Get the DataFlex statement identifier
82788>>>>>>>>>        Move Self to iErrHandle
82789>>>>>>>>>
82789>>>>>>>>>        //*** Create location information
82789>>>>>>>>>        Move "[" To sLocationInfo
82790>>>>>>>>>        If (sOriginMsg <> "") Begin
82792>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
82793>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
82794>>>>>>>>>        End
82794>>>>>>>>>>
82794>>>>>>>>>        If (sErrtext <> "") Begin
82796>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
82797>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
82798>>>>>>>>>        End
82798>>>>>>>>>>
82798>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
82799>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
82800>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
82801>>>>>>>>>
82801>>>>>>>>>        //*** Generate the error
82801>>>>>>>>>        Error iErrNum sLocationInfo
82802>>>>>>>>>>
82802>>>>>>>>>    End_Procedure 
82803>>>>>>>>>
82803>>>>>>>>>
82803>>>>>>>>>
82803>>>>>>>>>    //***
82803>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
82803>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
82803>>>>>>>>>    //***
82803>>>>>>>>>
82803>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
82805>>>>>>>>>        Integer bReport
82805>>>>>>>>>
82805>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
82808>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
82811>>>>>>>>>    End_Procedure 
82812>>>>>>>>>
82812>>>>>>>>>
82812>>>>>>>>>
82812>>>>>>>>>    //***
82812>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
82812>>>>>>>>>    //*** Purpose : Check if a column number is legal
82812>>>>>>>>>    //***
82812>>>>>>>>>
82812>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
82814>>>>>>>>>        Integer bLegal
82814>>>>>>>>>        Integer iNumColumns
82814>>>>>>>>>
82814>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
82815>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
82818>>>>>>>>>        Else ;            Move DFFALSE To bLegal
82820>>>>>>>>>
82820>>>>>>>>>        Function_Return bLegal
82821>>>>>>>>>    End_Function 
82822>>>>>>>>>
82822>>>>>>>>>
82822>>>>>>>>>
82822>>>>>>>>>    //***
82822>>>>>>>>>    //*** Procedure: SQLClose
82822>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
82822>>>>>>>>>    //***
82822>>>>>>>>>
82822>>>>>>>>>    Procedure SQLClose
82824>>>>>>>>>        Integer ihdbc
82824>>>>>>>>>        Integer ihstmt
82824>>>>>>>>>        Integer iVoid
82824>>>>>>>>>        String  sDrvrId
82824>>>>>>>>>        String  sEmpty
82824>>>>>>>>>
82824>>>>>>>>>        //*** Initialize
82824>>>>>>>>>        Move "" To sEmpty
82825>>>>>>>>>
82825>>>>>>>>>        //*** Get the cli handles
82825>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82826>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82827>>>>>>>>>        Get psDriverId            to sDrvrId
82828>>>>>>>>>
82828>>>>>>>>>        //*** Free the CLI handle
82828>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82830>>>>>>>>>            //*** Call the driver function to close
82830>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82835>>>>>>>>>
82835>>>>>>>>>            Move -1 to giLastSQLhstmt
82836>>>>>>>>>            //*** Free the DataFlex handle
82836>>>>>>>>>            Send DestroySQLStatement
82837>>>>>>>>>        End
82837>>>>>>>>>>
82837>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
82839>>>>>>>>>    End_Procedure
82840>>>>>>>>>
82840>>>>>>>>>
82840>>>>>>>>>
82840>>>>>>>>>    //***
82840>>>>>>>>>    //*** Procedure: SQLPrepare
82840>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
82840>>>>>>>>>    //***
82840>>>>>>>>>
82840>>>>>>>>>    Procedure SQLPrepare String sStatement
82842>>>>>>>>>        Integer ihdbc
82842>>>>>>>>>        Integer ihstmt
82842>>>>>>>>>        Integer iVoid
82842>>>>>>>>>        String  sDrvrId
82842>>>>>>>>>
82842>>>>>>>>>        //*** Get the cli handles
82842>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82843>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82844>>>>>>>>>        Get psDriverId            to sDrvrId
82845>>>>>>>>>
82845>>>>>>>>>        //*** Prepare
82845>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82847>>>>>>>>>            //*** Call the driver function to prepare
82847>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82852>>>>>>>>>        End
82852>>>>>>>>>>
82852>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
82854>>>>>>>>>    End_Procedure
82855>>>>>>>>>
82855>>>>>>>>>    Procedure SQLGetStatementAttributes
82857>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
82857>>>>>>>>>        String sMaxValue
82857>>>>>>>>>        tSQLColumn[] aSQLColumns
82857>>>>>>>>>        tSQLColumn[] aSQLColumns
82858>>>>>>>>>        
82858>>>>>>>>>        Integer iSqlType
82858>>>>>>>>>        Integer iSQLSize
82858>>>>>>>>>        Integer iSQLprecision
82858>>>>>>>>>        Integer iVariableDataType
82858>>>>>>>>>        
82858>>>>>>>>>        String  sDrvrId
82858>>>>>>>>>
82858>>>>>>>>>        Integer iHasVariableDataType
82858>>>>>>>>>
82858>>>>>>>>>        Move 0 to iHasVariableDataType
82859>>>>>>>>>
82859>>>>>>>>>
82859>>>>>>>>>        //*** Get the cli handles
82859>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82860>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82861>>>>>>>>>        Get psDriverId            to sDrvrId
82862>>>>>>>>>
82862>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
82863>>>>>>>>>        
82863>>>>>>>>>        Set piColumnCount to iNumColumns
82864>>>>>>>>>        
82864>>>>>>>>>        // Fill columns array
82864>>>>>>>>>        For iCol from 1 to iNumColumns
82870>>>>>>>>>>
82870>>>>>>>>>            Move 0 to iVariableDataType
82871>>>>>>>>>            
82871>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
82872>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
82873>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
82874>>>>>>>>>            
82874>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
82876>>>>>>>>>                 // text type 
82876>>>>>>>>>                Move 1 to iVariableDataType
82877>>>>>>>>>            End
82877>>>>>>>>>>
82877>>>>>>>>>            Else Begin
82878>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
82880>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0                   
82880>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                         ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
82882>>>>>>>>>                            
82882>>>>>>>>>                        Move 1 to iVariableDataType     
82883>>>>>>>>>                    End
82883>>>>>>>>>>
82883>>>>>>>>>                End
82883>>>>>>>>>>
82883>>>>>>>>>            End
82883>>>>>>>>>>
82883>>>>>>>>>
82883>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType            
82884>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
82885>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
82886>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
82887>>>>>>>>>            
82887>>>>>>>>>            If (not(iVariableDataType)) Begin
82889>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
82891>>>>>>>>>                    Move iSQLSize to iMaxSize
82892>>>>>>>>>                End
82892>>>>>>>>>>
82892>>>>>>>>>            End
82892>>>>>>>>>>
82892>>>>>>>>>            Else Begin
82893>>>>>>>>>                Move 1 to iHasVariableDataType
82894>>>>>>>>>            End
82894>>>>>>>>>>
82894>>>>>>>>>            
82894>>>>>>>>>        Loop
82895>>>>>>>>>>
82895>>>>>>>>>        
82895>>>>>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
82896>>>>>>>>>        Set psMaxColValue to sMaxValue
82897>>>>>>>>>        
82897>>>>>>>>>        Set paSQLColumns   to aSQLColumns        
82898>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
82899>>>>>>>>>        
82899>>>>>>>>>    End_Procedure
82900>>>>>>>>>
82900>>>>>>>>>    //***
82900>>>>>>>>>    //*** Procedure: SQLExecute
82900>>>>>>>>>    //*** Purpose  : Execute a prepared statement
82900>>>>>>>>>    //***
82900>>>>>>>>>
82900>>>>>>>>>    Procedure SQLExecute
82902>>>>>>>>>        Integer ihdbc
82902>>>>>>>>>        Integer ihstmt
82902>>>>>>>>>        Integer iVoid
82902>>>>>>>>>        String  sDrvrId
82902>>>>>>>>>        String  sEmpty
82902>>>>>>>>>
82902>>>>>>>>>        //*** Initialize
82902>>>>>>>>>        Move "" To sEmpty
82903>>>>>>>>>
82903>>>>>>>>>        //*** Get the cli handles
82903>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82904>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82905>>>>>>>>>        Get psDriverId            to sDrvrId
82906>>>>>>>>>
82906>>>>>>>>>        //*** Execute
82906>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82908>>>>>>>>>            //*** Call the driver function to execute
82908>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
82913>>>>>>>>>            Send SQLGetStatementAttributes
82914>>>>>>>>>        End
82914>>>>>>>>>>
82914>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
82916>>>>>>>>>    End_Procedure
82917>>>>>>>>>
82917>>>>>>>>>
82917>>>>>>>>>
82917>>>>>>>>>    //***
82917>>>>>>>>>    //*** Procedure: SQLExecDirect
82917>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
82917>>>>>>>>>    //***
82917>>>>>>>>>
82917>>>>>>>>>    Procedure SQLExecDirect String sStatement
82919>>>>>>>>>        Integer ihdbc
82919>>>>>>>>>        Integer ihstmt
82919>>>>>>>>>        Integer iVoid
82919>>>>>>>>>        String  sDrvrId
82919>>>>>>>>>
82919>>>>>>>>>        //*** Get the cli handles
82919>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82920>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82921>>>>>>>>>        Get psDriverId            to sDrvrId
82922>>>>>>>>>
82922>>>>>>>>>        //*** ExecDirect
82922>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
82924>>>>>>>>>            //*** Call the driver function to execdirect
82924>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Self ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
82929>>>>>>>>>            Send SQLGetStatementAttributes
82930>>>>>>>>>        End
82930>>>>>>>>>>
82930>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
82932>>>>>>>>>    End_Procedure
82933>>>>>>>>>
82933>>>>>>>>>
82933>>>>>>>>>
82933>>>>>>>>>    //***
82933>>>>>>>>>    //*** Procedure: SQLFetch
82933>>>>>>>>>    //*** Purpose  : Fetch the next row
82933>>>>>>>>>    //*** Returns  : 0   = No more data
82933>>>>>>>>>    //***            <>0 = Success
82933>>>>>>>>>    //***
82933>>>>>>>>>    Function SQLFetch Returns Integer
82935>>>>>>>>>        Integer ihdbc
82935>>>>>>>>>        Integer ihstmt
82935>>>>>>>>>        Integer iResult
82935>>>>>>>>>        String  sDrvrId
82935>>>>>>>>>        String  sEmpty
82935>>>>>>>>>
82935>>>>>>>>>        //*** Initialize
82935>>>>>>>>>        Move "" To sEmpty
82936>>>>>>>>>        Move 0  To iResult
82937>>>>>>>>>
82937>>>>>>>>>        //*** Get the cli handles
82937>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82938>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82939>>>>>>>>>        Get psDriverId            to sDrvrId
82940>>>>>>>>>
82940>>>>>>>>>        //*** Fetch
82940>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82942>>>>>>>>>            Indicate Err False
82943>>>>>>>>>
82943>>>>>>>>>            //*** Call the driver function to fetch
82943>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
82948>>>>>>>>>
82948>>>>>>>>>            //*** If something went wrong, adjust the result
82948>>>>>>>>>            If (Err) Move 0 to iResult
82951>>>>>>>>>
82951>>>>>>>>>            Set piLastcolumn To 0
82952>>>>>>>>>        End
82952>>>>>>>>>>
82952>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
82954>>>>>>>>>
82954>>>>>>>>>        Function_return iResult
82955>>>>>>>>>    End_Function
82956>>>>>>>>>
82956>>>>>>>>>
82956>>>>>>>>>    //***
82956>>>>>>>>>    //*** Procedure: SQLFetchRowValues
82956>>>>>>>>>    //*** Purpose  : Fetch the next row and return an array with all column values
82956>>>>>>>>>    //*** Returns  : Array of strings with all column values
82956>>>>>>>>>    //***            Sets piFetchResult property 
82956>>>>>>>>>    //***               0    = No more data
82956>>>>>>>>>    //***               <> 0 = Success
82956>>>>>>>>>    //***
82956>>>>>>>>>    Function SQLFetchRowValues Returns String[] 
82958>>>>>>>>>      
82958>>>>>>>>>        String[] asValues
82959>>>>>>>>>
82959>>>>>>>>>        tSQLColumn[] aSQLColumns        
82959>>>>>>>>>        tSQLColumn[] aSQLColumns        
82960>>>>>>>>>        
82960>>>>>>>>>        Integer ihdbc
82960>>>>>>>>>        Integer ihstmt
82960>>>>>>>>>        Integer iResult iVoid
82960>>>>>>>>>        Integer iColCount iCol
82960>>>>>>>>>        String  sDrvrId
82960>>>>>>>>>        String  sEmpty 
82960>>>>>>>>>        String  sResult
82960>>>>>>>>>        String  sVariableResult
82960>>>>>>>>>        Integer iHasVariableDataType
82960>>>>>>>>>        Integer iLen
82960>>>>>>>>>        Integer iVariableBufferLength
82960>>>>>>>>>
82960>>>>>>>>>        //*** Initialize
82960>>>>>>>>>        Move "" to sEmpty
82961>>>>>>>>>        Move 0  to iResult
82962>>>>>>>>>
82962>>>>>>>>>        //*** Get the cli handles
82962>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
82963>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
82964>>>>>>>>>        Get psDriverId            to sDrvrId
82965>>>>>>>>>        
82965>>>>>>>>>        Get paSQLColumns to aSQLColumns
82966>>>>>>>>>        Get piColumnCount to iColCount
82967>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
82968>>>>>>>>>        
82968>>>>>>>>>        If (iHasVariableDataType) Begin
82970>>>>>>>>>            
82970>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
82971>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
82972>>>>>>>>>            
82972>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
82974>>>>>>>>>                //*** Allocate
82974>>>>>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
82975>>>>>>>>>               
82975>>>>>>>>>                Set piVariableBufferLength to iLen
82976>>>>>>>>>                Set psVariableBuffer       to sVariableResult
82977>>>>>>>>>                
82977>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength                
82978>>>>>>>>>            End
82978>>>>>>>>>>
82978>>>>>>>>>        End
82978>>>>>>>>>>
82978>>>>>>>>>
82978>>>>>>>>>        //*** Fetch
82978>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
82980>>>>>>>>>            Move (False) to Err
82981>>>>>>>>>
82981>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
82981>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
82981>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
82981>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
82983>>>>>>>>>                //*** Setup function arguments
82983>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
82988>>>>>>>>>                Move ihstmt to giLastSQLhstmt
82989>>>>>>>>>                Move ihdbc to giLastSQLhdbc
82990>>>>>>>>>            End
82990>>>>>>>>>>
82990>>>>>>>>>
82990>>>>>>>>>            //*** Call the driver function to fetch
82990>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
82995>>>>>>>>>
82995>>>>>>>>>            //*** If something went wrong, adjust the result
82995>>>>>>>>>            If (Err) Move 0 to iResult
82998>>>>>>>>>            
82998>>>>>>>>>            If (iResult) Begin
83000>>>>>>>>>                For iCol from 1 to iColCount
83006>>>>>>>>>>
83006>>>>>>>>>                    
83006>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83008>>>>>>>>>                        Get psMaxColValue to sResult
83009>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
83014>>>>>>>>>
83014>>>>>>>>>                        Move sResult to asValues[iCol - 1]
83015>>>>>>>>>                    End
83015>>>>>>>>>>
83015>>>>>>>>>                    Else Begin
83016>>>>>>>>>                        Get psVariableBuffer       to sVariableResult
83017>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sVariableResult iCol iVariableBufferLength ;                                    Result iVoid
83022>>>>>>>>>                                    
83022>>>>>>>>>                        Move sVariableResult to asValues[iCol - 1]
83023>>>>>>>>>                    End
83023>>>>>>>>>>
83023>>>>>>>>>                    
83023>>>>>>>>>                Loop
83024>>>>>>>>>>
83024>>>>>>>>>            End
83024>>>>>>>>>>
83024>>>>>>>>>        End
83024>>>>>>>>>>
83024>>>>>>>>>        Else Begin    
83025>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
83026>>>>>>>>>        End
83026>>>>>>>>>>
83026>>>>>>>>>
83026>>>>>>>>>        Set piFetchResult to iResult
83027>>>>>>>>>
83027>>>>>>>>>        Function_Return asValues
83028>>>>>>>>>        
83028>>>>>>>>>    End_Function 
83029>>>>>>>>>
83029>>>>>>>>>    //***
83029>>>>>>>>>    //*** Procedure: SQLFetchResultsetValues
83029>>>>>>>>>    //*** Purpose  : Fetch a complete result set. 
83029>>>>>>>>>    //*** Returns  : 2-dimensional array of strings with result set
83029>>>>>>>>>    //***            Sets piFetchResult property 
83029>>>>>>>>>    //***               0    = No more data
83029>>>>>>>>>    //***               <> 0 = Success
83029>>>>>>>>>    //***
83029>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][] 
83031>>>>>>>>>        
83031>>>>>>>>>        String[][] asValues 
83032>>>>>>>>>        
83032>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
83032>>>>>>>>>        String sDrvrId sEmpty sResult sMax
83032>>>>>>>>>
83032>>>>>>>>>        tSQLColumn[] aSQLColumns        
83032>>>>>>>>>        tSQLColumn[] aSQLColumns        
83033>>>>>>>>>        String  sVariableResult
83033>>>>>>>>>        Integer iHasVariableDataType
83033>>>>>>>>>        Integer iLen
83033>>>>>>>>>        Integer iVariableBufferLength
83033>>>>>>>>>
83033>>>>>>>>>        //*** Initialize
83033>>>>>>>>>        Move "" to sEmpty
83034>>>>>>>>>        Move 0  to iResult
83035>>>>>>>>>
83035>>>>>>>>>        //*** Get the cli handles
83035>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83036>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83037>>>>>>>>>        Get psDriverId            to sDrvrId
83038>>>>>>>>>
83038>>>>>>>>>        //*** Fetch
83038>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83040>>>>>>>>>            Indicate Err False
83041>>>>>>>>>            
83041>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83041>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
83041>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
83041>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83043>>>>>>>>>                //*** Setup function arguments
83043>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
83048>>>>>>>>>                Move ihstmt to giLastSQLhstmt
83049>>>>>>>>>                Move ihdbc to giLastSQLhdbc
83050>>>>>>>>>            End
83050>>>>>>>>>>
83050>>>>>>>>>
83050>>>>>>>>>
83050>>>>>>>>>            Get paSQLColumns to aSQLColumns
83051>>>>>>>>>            Get piColumnCount to iColCount
83052>>>>>>>>>            Get piHasVariableDataType to iHasVariableDataType
83053>>>>>>>>>            If (iHasVariableDataType) Begin
83055>>>>>>>>>                Get piVariableBufferLength      to iVariableBufferLength
83056>>>>>>>>>                Get piMaxVariableBufferLength   to iLen
83057>>>>>>>>>                If (iLen > iVariableBufferLength) Begin
83059>>>>>>>>>                    //*** Allocate
83059>>>>>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
83060>>>>>>>>>                   
83060>>>>>>>>>                    Set piVariableBufferLength to iLen
83061>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
83062>>>>>>>>>                    
83062>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength                
83063>>>>>>>>>                End
83063>>>>>>>>>>
83063>>>>>>>>>                Else Begin
83064>>>>>>>>>                   Set psVariableBuffer       to sVariableResult
83065>>>>>>>>>                End
83065>>>>>>>>>>
83065>>>>>>>>>            End
83065>>>>>>>>>>
83065>>>>>>>>>
83065>>>>>>>>>            Get psMaxColValue to sMax
83066>>>>>>>>>
83066>>>>>>>>>            //*** Call the driver function to fetch
83066>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83071>>>>>>>>>            If (Err) Move 0 to iResult
83074>>>>>>>>>
83074>>>>>>>>>            While (iResult <> 0)
83078>>>>>>>>>
83078>>>>>>>>>                For iCol from 1 to (iColCount)
83084>>>>>>>>>>
83084>>>>>>>>>                    
83084>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
83086>>>>>>>>>                        Move sMax to sResult
83087>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                    Callback 0 ;                                    Passing sResult sEmpty iCol ;                                    Result iVoid
83092>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83093>>>>>>>>>                    End
83093>>>>>>>>>>
83093>>>>>>>>>                    Else Begin
83094>>>>>>>>>                        //Variable data    
83094>>>>>>>>>                        Move sVariableResult to sResult
83095>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                    Callback 0 ;                                    Passing sResult iCol iVariableBufferLength ;                                    Result iVoid
83100>>>>>>>>>                                    
83100>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
83101>>>>>>>>>                    End
83101>>>>>>>>>>
83101>>>>>>>>>                Loop
83102>>>>>>>>>>
83102>>>>>>>>>
83102>>>>>>>>>                Increment iRow
83103>>>>>>>>>
83103>>>>>>>>>                //*** Call the driver function to fetch
83103>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
83108>>>>>>>>>                If (Err) Move 0 to iResult
83111>>>>>>>>>
83111>>>>>>>>>            Loop
83112>>>>>>>>>>
83112>>>>>>>>>
83112>>>>>>>>>        End
83112>>>>>>>>>>
83112>>>>>>>>>        Else Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
83114>>>>>>>>>
83114>>>>>>>>>        Set piFetchResult to iResult
83115>>>>>>>>>
83115>>>>>>>>>        Function_Return asValues
83116>>>>>>>>>    End_Function 
83117>>>>>>>>>
83117>>>>>>>>>
83117>>>>>>>>>
83117>>>>>>>>>    //***
83117>>>>>>>>>    //*** Function: SQLNextColumn
83117>>>>>>>>>    //*** Purpose : Get the next column
83117>>>>>>>>>    //***
83117>>>>>>>>>
83117>>>>>>>>>    Function SQLNextColumn Returns String
83119>>>>>>>>>        Integer iCol
83119>>>>>>>>>        String  sResult
83119>>>>>>>>>
83119>>>>>>>>>        Get piLastColumn To iCol
83120>>>>>>>>>        Increment iCol
83121>>>>>>>>>        Get SQLColumnValue iCol To sResult
83122>>>>>>>>>        Set piLastColumn To iCol
83123>>>>>>>>>
83123>>>>>>>>>        Function_return sResult
83124>>>>>>>>>    End_Function 
83125>>>>>>>>>
83125>>>>>>>>>
83125>>>>>>>>>    //***
83125>>>>>>>>>    //*** Function: SQLColumnType
83125>>>>>>>>>    //*** Purpose : Returns the native type of a column
83125>>>>>>>>>    //***
83125>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
83127>>>>>>>>>        Integer ihdbc
83127>>>>>>>>>        Integer ihstmt
83127>>>>>>>>>        String  sDrvrId
83127>>>>>>>>>        Integer iSQLType
83127>>>>>>>>>        Integer iColumns
83127>>>>>>>>>        
83127>>>>>>>>>        tSQLColumn[] aSQLColumns
83127>>>>>>>>>        tSQLColumn[] aSQLColumns
83128>>>>>>>>>        
83128>>>>>>>>>        //*** Get the cli handles
83128>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83129>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83130>>>>>>>>>        Get psDriverId            to sDrvrId
83131>>>>>>>>>
83131>>>>>>>>>        //*** Get the value
83131>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83133>>>>>>>>>        
83133>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83134>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83135>>>>>>>>>            
83135>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83137>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
83138>>>>>>>>>            End
83138>>>>>>>>>>
83138>>>>>>>>>            Else Begin
83139>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"        
83140>>>>>>>>>            End
83140>>>>>>>>>>
83140>>>>>>>>>        End
83140>>>>>>>>>>
83140>>>>>>>>>        Else Begin
83141>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
83142>>>>>>>>>        End
83142>>>>>>>>>>
83142>>>>>>>>>
83142>>>>>>>>>        Function_Return iSQLType
83143>>>>>>>>>    End_Function 
83144>>>>>>>>>
83144>>>>>>>>>    //***
83144>>>>>>>>>    //*** Function: SQLColumnSize
83144>>>>>>>>>    //*** Purpose : Returns the size (max length) of a column
83144>>>>>>>>>    //***
83144>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
83146>>>>>>>>>        Integer ihdbc
83146>>>>>>>>>        Integer ihstmt
83146>>>>>>>>>        String  sDrvrId
83146>>>>>>>>>        Integer iSQLSize
83146>>>>>>>>>        Integer iColumns
83146>>>>>>>>>        
83146>>>>>>>>>        tSQLColumn[] aSQLColumns
83146>>>>>>>>>        tSQLColumn[] aSQLColumns
83147>>>>>>>>>        
83147>>>>>>>>>        //*** Get the cli handles
83147>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83148>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83149>>>>>>>>>        Get psDriverId            to sDrvrId
83150>>>>>>>>>
83150>>>>>>>>>        //*** Get the value
83150>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83152>>>>>>>>>        
83152>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83153>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83154>>>>>>>>>            
83154>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83156>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
83157>>>>>>>>>            End
83157>>>>>>>>>>
83157>>>>>>>>>            Else Begin
83158>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"        
83159>>>>>>>>>            End
83159>>>>>>>>>>
83159>>>>>>>>>        End
83159>>>>>>>>>>
83159>>>>>>>>>        Else Begin
83160>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
83161>>>>>>>>>        End
83161>>>>>>>>>>
83161>>>>>>>>>
83161>>>>>>>>>        Function_Return iSQLSize
83162>>>>>>>>>    End_Function 
83163>>>>>>>>>
83163>>>>>>>>>    //***
83163>>>>>>>>>    //*** Function: SQLColumnVariableDatatype
83163>>>>>>>>>    //*** Purpose : Returns 1 for variable length datatypes. 
83163>>>>>>>>>    //***           For example SQL Server varchar(max) or text type
83163>>>>>>>>>    //***           The data of variable length datatype columns should be retrieved with SQLGetData 
83163>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
83165>>>>>>>>>        Integer ihdbc
83165>>>>>>>>>        Integer ihstmt
83165>>>>>>>>>        String  sDrvrId
83165>>>>>>>>>        Integer iVariableDataType
83165>>>>>>>>>        Integer iColumns
83165>>>>>>>>>        
83165>>>>>>>>>        tSQLColumn[] aSQLColumns
83165>>>>>>>>>        tSQLColumn[] aSQLColumns
83166>>>>>>>>>        
83166>>>>>>>>>        //*** Get the cli handles
83166>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83167>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83168>>>>>>>>>        Get psDriverId            to sDrvrId
83169>>>>>>>>>
83169>>>>>>>>>        //*** Get the value
83169>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83171>>>>>>>>>        
83171>>>>>>>>>            Get paSQLColumns   to aSQLColumns        
83172>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
83173>>>>>>>>>            
83173>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
83175>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
83176>>>>>>>>>            End
83176>>>>>>>>>>
83176>>>>>>>>>            Else Begin
83177>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"        
83178>>>>>>>>>            End
83178>>>>>>>>>>
83178>>>>>>>>>        End
83178>>>>>>>>>>
83178>>>>>>>>>        Else Begin
83179>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
83180>>>>>>>>>        End
83180>>>>>>>>>>
83180>>>>>>>>>
83180>>>>>>>>>        Function_Return iVariableDataType
83181>>>>>>>>>    End_Function 
83182>>>>>>>>>
83182>>>>>>>>>
83182>>>>>>>>>
83182>>>>>>>>>
83182>>>>>>>>>    //***
83182>>>>>>>>>    //*** Function: SQLColumnValue
83182>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
83182>>>>>>>>>    //***           statement.
83182>>>>>>>>>    //***
83182>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83184>>>>>>>>>        Integer ihdbc
83184>>>>>>>>>        Integer ihstmt
83184>>>>>>>>>        String  sDrvrId
83184>>>>>>>>>        String  sResult
83184>>>>>>>>>
83184>>>>>>>>>        Integer iVoid
83184>>>>>>>>>        Integer iColSize
83184>>>>>>>>>        Integer iColPrecision
83184>>>>>>>>>        String  sEmpty
83184>>>>>>>>>        Integer bLegalColumn
83184>>>>>>>>>
83184>>>>>>>>>        //*** Initialize
83184>>>>>>>>>        Move "" To sResult
83185>>>>>>>>>
83185>>>>>>>>>        //*** Get the cli handles
83185>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83186>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83187>>>>>>>>>        Get psDriverId            to sDrvrId
83188>>>>>>>>>
83188>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83188>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
83188>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
83188>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83190>>>>>>>>>            //*** Setup function arguments
83190>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
83195>>>>>>>>>            Move ihstmt to giLastSQLhstmt
83196>>>>>>>>>            Move ihdbc to giLastSQLhdbc
83197>>>>>>>>>        End
83197>>>>>>>>>>
83197>>>>>>>>>
83197>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83199>>>>>>>>>            Get psMaxColValue to sResult
83200>>>>>>>>>            //*** Call the driver function to get the value
83200>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                        Callback 0 ;                        Passing sResult sEmpty iCol ;                        Result iVoid
83205>>>>>>>>>        End
83205>>>>>>>>>>
83205>>>>>>>>>        Else Begin
83206>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
83207>>>>>>>>>        End
83207>>>>>>>>>>
83207>>>>>>>>>
83207>>>>>>>>>        Function_Return sResult
83208>>>>>>>>>        
83208>>>>>>>>>    End_Function
83209>>>>>>>>>
83209>>>>>>>>>
83209>>>>>>>>>
83209>>>>>>>>>    //***
83209>>>>>>>>>    //*** Procedure: SQLBindFile
83209>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
83209>>>>>>>>>    //***
83209>>>>>>>>>
83209>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83211>>>>>>>>>        Integer ihdbc
83211>>>>>>>>>        Integer ihstmt
83211>>>>>>>>>        Integer iVoid
83211>>>>>>>>>        String  sDrvrId
83211>>>>>>>>>        String  sFileType
83211>>>>>>>>>        Integer bIsOpen
83211>>>>>>>>>
83211>>>>>>>>>        //*** Get the cli handles
83211>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83212>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83213>>>>>>>>>        Get psDriverId            to sDrvrId
83214>>>>>>>>>
83214>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
83214>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
83214>>>>>>>>>        If (iFileNum = 0) Begin
83216>>>>>>>>>            Get piBindFile To iFileNum
83217>>>>>>>>>            If (iFileNum = 0) Begin
83219>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
83219>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
83220>>>>>>>>>
83220>>>>>>>>>                Move 0 to SQLResult
83221>>>>>>>>>                Procedure_Return
83222>>>>>>>>>            End
83222>>>>>>>>>>
83222>>>>>>>>>        End
83222>>>>>>>>>>
83222>>>>>>>>>
83222>>>>>>>>>        //*** Bind the file
83222>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83224>>>>>>>>>            //*** Chek if the file is open
83224>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83227>>>>>>>>>            If (bIsOpen) Begin
83229>>>>>>>>>                //*** Check if the file has the correct type
83229>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83232>>>>>>>>>                If (sFileType = sDrvrId) Begin
83234>>>>>>>>>                    //*** Call the driver function to add a file to a statement
83234>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Self ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
83239>>>>>>>>>                End
83239>>>>>>>>>>
83239>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83241>>>>>>>>>            End
83241>>>>>>>>>>
83241>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
83243>>>>>>>>>        End
83243>>>>>>>>>>
83243>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
83245>>>>>>>>>    End_Procedure 
83246>>>>>>>>>
83246>>>>>>>>>
83246>>>>>>>>>
83246>>>>>>>>>    //*************************************************************************
83246>>>>>>>>>    //*** Function: SQLGetData                                              ***
83246>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
83246>>>>>>>>>    //*************************************************************************
83246>>>>>>>>>
83246>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83248>>>>>>>>>        Integer ihdbc
83248>>>>>>>>>        Integer ihstmt
83248>>>>>>>>>        Integer iVoid
83248>>>>>>>>>        Integer iColSize
83248>>>>>>>>>        Integer iResult
83248>>>>>>>>>        String  sDrvrId
83248>>>>>>>>>        String  sResult
83248>>>>>>>>>        String  sEmpty
83248>>>>>>>>>        Integer bLegalColumn
83248>>>>>>>>>        
83248>>>>>>>>>        Integer iVariableBufferLength
83248>>>>>>>>>
83248>>>>>>>>>        //*** Initialize
83248>>>>>>>>>        Move "" To sEmpty
83249>>>>>>>>>        Move 0 To iResult
83250>>>>>>>>>
83250>>>>>>>>>        //*** Get the cli handles
83250>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83251>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83252>>>>>>>>>        Get psDriverId            to sDrvrId
83253>>>>>>>>>
83253>>>>>>>>>        //*** Get the data
83253>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
83255>>>>>>>>>            //*** Check if the column exists
83255>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
83257>>>>>>>>>                If (iLen = 0) Begin
83259>>>>>>>>>                    Get SQLColumnValue iCol to sResult
83260>>>>>>>>>                End
83260>>>>>>>>>>
83260>>>>>>>>>                Else Begin
83261>>>>>>>>>                    // Add 1 for string terminator
83261>>>>>>>>>                    Move (iLen + 1) to iLen
83262>>>>>>>>>
83262>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
83263>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
83265>>>>>>>>>                        //*** Allocate
83265>>>>>>>>>                        Move (Repeat(' ', iLen)) to sResult
83266>>>>>>>>>                       
83266>>>>>>>>>                        Set piVariableBufferLength to iLen
83267>>>>>>>>>                        Set psVariableBuffer       to sResult
83268>>>>>>>>>                    End
83268>>>>>>>>>>
83268>>>>>>>>>                    Else Begin
83269>>>>>>>>>                        Get psVariableBuffer       to sResult
83270>>>>>>>>>                    End
83270>>>>>>>>>>
83270>>>>>>>>>
83270>>>>>>>>>
83270>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use 
83270>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
83270>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
83270>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
83272>>>>>>>>>                        //*** Setup function arguments
83272>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                    Callback 0 ;                                    Passing ihdbc iCol ihstmt ;                                    Result iVoid
83277>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
83278>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
83279>>>>>>>>>                    End
83279>>>>>>>>>>
83279>>>>>>>>>
83279>>>>>>>>>                    Indicate Err False
83280>>>>>>>>>                    //*** Call the driver function to get the data
83280>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Self ;                                Passing sResult iCol iLen ;                                Result iResult
83285>>>>>>>>>
83285>>>>>>>>>                    //*** If something went wrong, adjust the result
83285>>>>>>>>>                    If (Err) Begin
83287>>>>>>>>>                        Move 0 to iResult
83288>>>>>>>>>                    End
83288>>>>>>>>>>
83288>>>>>>>>>                End
83288>>>>>>>>>>
83288>>>>>>>>>            End
83288>>>>>>>>>>
83288>>>>>>>>>            Else Begin
83289>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
83290>>>>>>>>>            End
83290>>>>>>>>>>
83290>>>>>>>>>        End
83290>>>>>>>>>>
83290>>>>>>>>>        Else Begin
83291>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
83292>>>>>>>>>        End
83292>>>>>>>>>>
83292>>>>>>>>>
83292>>>>>>>>>        //*** Fill global result
83292>>>>>>>>>        Move iResult To SQLResult
83293>>>>>>>>>
83293>>>>>>>>>        Function_Return sResult
83294>>>>>>>>>    End_Function 
83295>>>>>>>>>
83295>>>>>>>>>
83295>>>>>>>>>
83295>>>>>>>>>    //***
83295>>>>>>>>>    //*** Function: SQLColumnMap
83295>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
83295>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
83295>>>>>>>>>    //***           that case
83295>>>>>>>>>    //***
83295>>>>>>>>>
83295>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83297>>>>>>>>>        Integer ihdbc
83297>>>>>>>>>        Integer ihstmt
83297>>>>>>>>>        Integer iNumColumns
83297>>>>>>>>>        Integer iColCount
83297>>>>>>>>>        Integer iColNum
83297>>>>>>>>>        String  sDrvrId
83297>>>>>>>>>        String  sCurColName
83297>>>>>>>>>
83297>>>>>>>>>        //*** Get the cli handles
83297>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83298>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83299>>>>>>>>>        Get psDriverId            to sDrvrId
83300>>>>>>>>>
83300>>>>>>>>>        //*** Get the number by looping through the column names
83300>>>>>>>>>        Move 0 To iColNum
83301>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
83302>>>>>>>>>        For iColCount From 1 To iNumColumns
83308>>>>>>>>>>
83308>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
83309>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
83312>>>>>>>>>
83312>>>>>>>>>            If (iColNum) ;                Break
83315>>>>>>>>>        Loop
83316>>>>>>>>>>
83316>>>>>>>>>
83316>>>>>>>>>        Function_return iColNum
83317>>>>>>>>>    End_Function 
83318>>>>>>>>>
83318>>>>>>>>>
83318>>>>>>>>>
83318>>>>>>>>>    //***
83318>>>>>>>>>    //*** Function: SQLStmtAttribute
83318>>>>>>>>>    //*** Purpose : Get a statement attribute
83318>>>>>>>>>    //***
83318>>>>>>>>>
83318>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83320>>>>>>>>>        Integer ihdbc
83320>>>>>>>>>        Integer ihstmt
83320>>>>>>>>>        String  sResult
83320>>>>>>>>>        String  sDrvrId
83320>>>>>>>>>
83320>>>>>>>>>        //*** Initialize
83320>>>>>>>>>        Move "" To sResult
83321>>>>>>>>>
83321>>>>>>>>>        //*** Get the cli handles
83321>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83322>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83323>>>>>>>>>        Get psDriverId            to sDrvrId
83324>>>>>>>>>
83324>>>>>>>>>        //*** Get the attribute
83324>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
83327>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
83329>>>>>>>>>
83329>>>>>>>>>        Function_Return sResult
83330>>>>>>>>>    End_Function 
83331>>>>>>>>>
83331>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83333>>>>>>>>>        String  sResult
83333>>>>>>>>>        Integer iLen
83333>>>>>>>>>        Integer bLegalAttrib
83333>>>>>>>>>
83333>>>>>>>>>        //*** Initialize
83333>>>>>>>>>        Move ""     To sResult
83334>>>>>>>>>
83334>>>>>>>>>        //*** Get the attribute
83334>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83336>>>>>>>>>            Case Begin
83336>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83338>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83341>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83344>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83347>>>>>>>>>                    Move DFTRUE To bLegalAttrib
83348>>>>>>>>>                    Break
83349>>>>>>>>>
83349>>>>>>>>>                Case Else
83349>>>>>>>>>                    Move DFFALSE To bLegalAttrib
83350>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
83351>>>>>>>>>            Case End
83351>>>>>>>>>
83351>>>>>>>>>            If (bLegalAttrib) Begin
83353>>>>>>>>>                //*** Setup function arguments
83353>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Self ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
83358>>>>>>>>>            End
83358>>>>>>>>>>
83358>>>>>>>>>        End
83358>>>>>>>>>>
83358>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
83360>>>>>>>>>
83360>>>>>>>>>        Function_Return sResult
83361>>>>>>>>>    End_Function 
83362>>>>>>>>>
83362>>>>>>>>>
83362>>>>>>>>>
83362>>>>>>>>>    //***
83362>>>>>>>>>    //*** Function: SQLColAttribute
83362>>>>>>>>>    //*** Purpose : Get a column's attribute
83362>>>>>>>>>    //***
83362>>>>>>>>>
83362>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83364>>>>>>>>>        Integer ihdbc
83364>>>>>>>>>        Integer ihstmt
83364>>>>>>>>>        String  sResult
83364>>>>>>>>>        String  sDrvrId
83364>>>>>>>>>
83364>>>>>>>>>        //*** Initialize
83364>>>>>>>>>        Move "" To sResult
83365>>>>>>>>>
83365>>>>>>>>>        //*** Get the cli handles
83365>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83366>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83367>>>>>>>>>        Get psDriverId            to sDrvrId
83368>>>>>>>>>
83368>>>>>>>>>        //*** Get the attribute
83368>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
83371>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
83373>>>>>>>>>
83373>>>>>>>>>        Function_Return sResult
83374>>>>>>>>>    End_Function 
83375>>>>>>>>>
83375>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
83377>>>>>>>>>        String  sResult
83377>>>>>>>>>        String  sEmpty
83377>>>>>>>>>        Integer bIsStringAttribute
83377>>>>>>>>>        Integer iLen
83377>>>>>>>>>        Integer iVoid
83377>>>>>>>>>        Integer bLegalAttrib
83377>>>>>>>>>        Integer bLegalColumn
83377>>>>>>>>>
83377>>>>>>>>>        //*** Initialize
83377>>>>>>>>>        Move "" To sResult
83378>>>>>>>>>        Move "" To sEmpty
83379>>>>>>>>>        MOve 0  To iLen
83380>>>>>>>>>
83380>>>>>>>>>        //*** Get the attribute
83380>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83382>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
83383>>>>>>>>>            If (bLegalColumn) Begin
83385>>>>>>>>>                //*** Determine the atributes type
83385>>>>>>>>>                Case Begin
83385>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
83387>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
83390>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
83393>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
83396>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
83399>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
83402>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
83403>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83404>>>>>>>>>                        Break
83405>>>>>>>>>
83405>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
83408>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83411>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
83414>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
83415>>>>>>>>>                        Move DFTRUE To bLegalAttrib
83416>>>>>>>>>                        Break
83417>>>>>>>>>
83417>>>>>>>>>                    Case Else
83417>>>>>>>>>                        Move DFFALSE To bLegalAttrib
83418>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
83419>>>>>>>>>                Case End
83419>>>>>>>>>
83419>>>>>>>>>                If (bLegalAttrib) Begin
83421>>>>>>>>>                    //*** Setup function arguments
83421>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Self ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
83426>>>>>>>>>
83426>>>>>>>>>                    If (bIsStringAttribute) Begin
83428>>>>>>>>>                        //*** Call the driver function to get the data length
83428>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
83433>>>>>>>>>
83433>>>>>>>>>                        If (iLen) Begin
83435>>>>>>>>>                            //*** Allocate
83435>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
83436>>>>>>>>>
83436>>>>>>>>>                            //*** Call the driver function to get the name
83436>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Self ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
83441>>>>>>>>>                        End
83441>>>>>>>>>>
83441>>>>>>>>>                    End
83441>>>>>>>>>>
83441>>>>>>>>>                    Else Begin
83442>>>>>>>>>                        //*** get the attribute
83442>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Self ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
83447>>>>>>>>>                    End
83447>>>>>>>>>>
83447>>>>>>>>>                End
83447>>>>>>>>>>
83447>>>>>>>>>            End
83447>>>>>>>>>>
83447>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
83449>>>>>>>>>        End
83449>>>>>>>>>>
83449>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
83451>>>>>>>>>
83451>>>>>>>>>        Function_Return sResult
83452>>>>>>>>>    End_Function 
83453>>>>>>>>>
83453>>>>>>>>>
83453>>>>>>>>>
83453>>>>>>>>>    //***
83453>>>>>>>>>    //*** Procedure: SQLSetProcedureName
83453>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
83453>>>>>>>>>    //***
83453>>>>>>>>>
83453>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
83455>>>>>>>>>        Integer ihdbc
83455>>>>>>>>>        Integer ihstmt
83455>>>>>>>>>        String  sDrvrId
83455>>>>>>>>>        Integer iVoid
83455>>>>>>>>>        String  sSchema
83455>>>>>>>>>        String  sEmpty
83455>>>>>>>>>
83455>>>>>>>>>        //*** Initialize
83455>>>>>>>>>        Move "" To sEmpty
83456>>>>>>>>>
83456>>>>>>>>>        //*** Get the cli handles
83456>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83457>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83458>>>>>>>>>        Get psDriverId            to sDrvrId
83459>>>>>>>>>
83459>>>>>>>>>        //*** Call the procedure
83459>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83461>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
83464>>>>>>>>>            Else ;                Move "" To sSchema
83466>>>>>>>>>
83466>>>>>>>>>            If (sSchema <> "") Begin
83468>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Self ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
83473>>>>>>>>>            End
83473>>>>>>>>>>
83473>>>>>>>>>
83473>>>>>>>>>            //*** Call the procedure
83473>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Self ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
83478>>>>>>>>>
83478>>>>>>>>>            Set piLastArgument To 0
83479>>>>>>>>>        End
83479>>>>>>>>>>
83479>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
83481>>>>>>>>>    End_Procedure 
83482>>>>>>>>>
83482>>>>>>>>>
83482>>>>>>>>>
83482>>>>>>>>>    //***
83482>>>>>>>>>    //*** Function: SQLSetNextArgument
83482>>>>>>>>>    //*** Purpose : Pass the next argument
83482>>>>>>>>>    //***
83482>>>>>>>>>
83482>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
83484>>>>>>>>>        Integer iArgnum
83484>>>>>>>>>
83484>>>>>>>>>        Get piLastArgument To iArgnum
83485>>>>>>>>>        Increment iArgnum
83486>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
83487>>>>>>>>>        Set piLastArgument To iArgnum
83488>>>>>>>>>    End_Procedure 
83489>>>>>>>>>
83489>>>>>>>>>
83489>>>>>>>>>
83489>>>>>>>>>    //***
83489>>>>>>>>>    //*** Procedure: SQLSetArgument
83489>>>>>>>>>    //*** Purpose  : Set the next argument
83489>>>>>>>>>    //***
83489>>>>>>>>>
83489>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
83491>>>>>>>>>        Integer ihdbc
83491>>>>>>>>>        Integer ihstmt
83491>>>>>>>>>        String  sDrvrId
83491>>>>>>>>>        Integer iVoid
83491>>>>>>>>>        String  sEmpty
83491>>>>>>>>>
83491>>>>>>>>>        //*** Initialize
83491>>>>>>>>>        Move "" To sEmpty
83492>>>>>>>>>
83492>>>>>>>>>        //*** Get the cli handles
83492>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83493>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83494>>>>>>>>>        Get psDriverId            to sDrvrId
83495>>>>>>>>>
83495>>>>>>>>>        //*** Call the procedure
83495>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83497>>>>>>>>>            //*** Pass the information
83497>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83502>>>>>>>>>
83502>>>>>>>>>            //*** Pass the argument
83502>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Self ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
83507>>>>>>>>>        End
83507>>>>>>>>>>
83507>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
83509>>>>>>>>>    End_Procedure
83510>>>>>>>>>
83510>>>>>>>>>
83510>>>>>>>>>
83510>>>>>>>>>    //***
83510>>>>>>>>>    //*** Procedure: SQLCall
83510>>>>>>>>>    //*** Purpose  : Call a stored procedure
83510>>>>>>>>>    //***
83510>>>>>>>>>
83510>>>>>>>>>    Procedure SQLCall
83512>>>>>>>>>        Integer ihdbc
83512>>>>>>>>>        Integer ihstmt
83512>>>>>>>>>        String  sDrvrId
83512>>>>>>>>>        Integer iVoid
83512>>>>>>>>>        String  sEmpty
83512>>>>>>>>>
83512>>>>>>>>>        //*** Initialize
83512>>>>>>>>>        Move "" To sEmpty
83513>>>>>>>>>
83513>>>>>>>>>        //*** Get the cli handles
83513>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83514>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83515>>>>>>>>>        Get psDriverId            to sDrvrId
83516>>>>>>>>>
83516>>>>>>>>>        //*** Call the procedure
83516>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83518>>>>>>>>>            //*** Call the procedure
83518>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
83523>>>>>>>>>                        
83523>>>>>>>>>            Send SQLGetStatementAttributes
83524>>>>>>>>>            Set piLastArgument To 0
83525>>>>>>>>>        End
83525>>>>>>>>>>
83525>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
83527>>>>>>>>>    End_Procedure 
83528>>>>>>>>>
83528>>>>>>>>>
83528>>>>>>>>>
83528>>>>>>>>>    //***
83528>>>>>>>>>    //*** Function: SQLGetNextArgument
83528>>>>>>>>>    //*** Purpose : Get the next argument
83528>>>>>>>>>    //***
83528>>>>>>>>>
83528>>>>>>>>>    Function SQLGetNextArgument Returns String
83530>>>>>>>>>        Integer iArgnum
83530>>>>>>>>>        String  sResult
83530>>>>>>>>>
83530>>>>>>>>>        Get piLastArgument To iArgnum
83531>>>>>>>>>        Increment iArgnum
83532>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
83533>>>>>>>>>        Set piLastArgument To iArgnum
83534>>>>>>>>>
83534>>>>>>>>>        Function_return sResult
83535>>>>>>>>>    End_Function 
83536>>>>>>>>>
83536>>>>>>>>>
83536>>>>>>>>>
83536>>>>>>>>>    //***
83536>>>>>>>>>    //*** Function: SQLGetArgument
83536>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
83536>>>>>>>>>    //***
83536>>>>>>>>>
83536>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
83538>>>>>>>>>        Integer ihdbc
83538>>>>>>>>>        Integer ihstmt
83538>>>>>>>>>        String  sDrvrId
83538>>>>>>>>>        Integer iVoid
83538>>>>>>>>>        String  sEmpty
83538>>>>>>>>>        String  sArgument
83538>>>>>>>>>        Integer iLen
83538>>>>>>>>>
83538>>>>>>>>>        //*** Initialize
83538>>>>>>>>>        Move "" To sEmpty
83539>>>>>>>>>        Move "" To sArgument
83540>>>>>>>>>
83540>>>>>>>>>        //*** Get the cli handles
83540>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83541>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83542>>>>>>>>>        Get psDriverId            to sDrvrId
83543>>>>>>>>>
83543>>>>>>>>>        //*** Call the procedure
83543>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83545>>>>>>>>>            //*** Pass the information
83545>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
83550>>>>>>>>>
83550>>>>>>>>>            //*** Get the length
83550>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
83555>>>>>>>>>
83555>>>>>>>>>            If (iLen) Begin
83557>>>>>>>>>                //*** Allocate
83557>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
83558>>>>>>>>>
83558>>>>>>>>>                //*** Pass the argument
83558>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Self ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
83563>>>>>>>>>            End
83563>>>>>>>>>>
83563>>>>>>>>>        End
83563>>>>>>>>>>
83563>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
83565>>>>>>>>>
83565>>>>>>>>>        Function_Return sArgument
83566>>>>>>>>>    End_Function 
83567>>>>>>>>>
83567>>>>>>>>>
83567>>>>>>>>>
83567>>>>>>>>>    //***
83567>>>>>>>>>    //*** Function: SQLReturnValue
83567>>>>>>>>>    //*** Purpose : Get the return value of a stored function
83567>>>>>>>>>    //***
83567>>>>>>>>>
83567>>>>>>>>>    Function SQLReturnValue Returns String
83569>>>>>>>>>        Integer ihdbc
83569>>>>>>>>>        Integer ihstmt
83569>>>>>>>>>        String  sDrvrId
83569>>>>>>>>>        Integer iVoid
83569>>>>>>>>>        String  sEmpty
83569>>>>>>>>>        String  sRetval
83569>>>>>>>>>        Integer iLen
83569>>>>>>>>>
83569>>>>>>>>>        //*** Initialize
83569>>>>>>>>>        Move "" To sEmpty
83570>>>>>>>>>        Move "" To sRetval
83571>>>>>>>>>
83571>>>>>>>>>        //*** Get the cli handles
83571>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83572>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83573>>>>>>>>>        Get psDriverId            to sDrvrId
83574>>>>>>>>>
83574>>>>>>>>>        //*** Call the procedure
83574>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83576>>>>>>>>>            //*** Get the length
83576>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
83581>>>>>>>>>
83581>>>>>>>>>            If (iLen) Begin
83583>>>>>>>>>                //*** Allocate
83583>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
83584>>>>>>>>>
83584>>>>>>>>>                //*** Pass the argument
83584>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Self ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
83589>>>>>>>>>            End
83589>>>>>>>>>>
83589>>>>>>>>>        End
83589>>>>>>>>>>
83589>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
83591>>>>>>>>>
83591>>>>>>>>>        Function_Return sRetval
83592>>>>>>>>>    End_Function 
83593>>>>>>>>>
83593>>>>>>>>>
83593>>>>>>>>>
83593>>>>>>>>>    //***
83593>>>>>>>>>    //*** Function: SQLNextResultSet
83593>>>>>>>>>    //*** Purpose : Switch to the next set
83593>>>>>>>>>    //*** Returns : 0   = No more result sets
83593>>>>>>>>>    //***           <>0 = Switched to next set
83593>>>>>>>>>    //***
83593>>>>>>>>>
83593>>>>>>>>>    Function SQLNextResultSet Returns Integer
83595>>>>>>>>>        Integer ihdbc
83595>>>>>>>>>        Integer ihstmt
83595>>>>>>>>>        String  sDrvrId
83595>>>>>>>>>        Integer iResult
83595>>>>>>>>>        String  sEmpty
83595>>>>>>>>>
83595>>>>>>>>>        //*** Initialize
83595>>>>>>>>>        Move "" To sEmpty
83596>>>>>>>>>        Move 0  To iResult
83597>>>>>>>>>
83597>>>>>>>>>        //*** Get the cli handles
83597>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83598>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83599>>>>>>>>>        Get psDriverId            to sDrvrId
83600>>>>>>>>>
83600>>>>>>>>>        //*** Call the procedure
83600>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83602>>>>>>>>>            //*** Get the length
83602>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Self ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
83607>>>>>>>>>                        
83607>>>>>>>>>            Send SQLGetStatementAttributes
83608>>>>>>>>>            Set piLastArgument to 0
83609>>>>>>>>>        End
83609>>>>>>>>>>
83609>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
83611>>>>>>>>>
83611>>>>>>>>>        Function_Return iResult
83612>>>>>>>>>    End_Function
83613>>>>>>>>>
83613>>>>>>>>>
83613>>>>>>>>>
83613>>>>>>>>>    //***
83613>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
83613>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
83613>>>>>>>>>    //***            fetch on the statement
83613>>>>>>>>>    //***
83613>>>>>>>>>
83613>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
83615>>>>>>>>>        Integer ihdbc
83615>>>>>>>>>        Integer ihstmt
83615>>>>>>>>>        String  sDrvrId
83615>>>>>>>>>        Integer iResult
83615>>>>>>>>>        Integer bIsOpen
83615>>>>>>>>>        Integer iVoid
83615>>>>>>>>>        String  sFileType
83615>>>>>>>>>
83615>>>>>>>>>        //*** Check if file is open
83615>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83618>>>>>>>>>        If (bIsOpen) Begin
83620>>>>>>>>>            //*** Get the cli handles
83620>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
83621>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
83622>>>>>>>>>            Get psDriverId            to sDrvrId
83623>>>>>>>>>
83623>>>>>>>>>            //*** Call the procedure
83623>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83625>>>>>>>>>                //*** Check if the file has the correct type
83625>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
83628>>>>>>>>>                If (sFileType = sDrvrId) Begin
83630>>>>>>>>>                    //*** Setup the buffer
83630>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Self ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
83635>>>>>>>>>                End
83635>>>>>>>>>>
83635>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
83637>>>>>>>>>            End
83637>>>>>>>>>>
83637>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
83639>>>>>>>>>        End
83639>>>>>>>>>>
83639>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
83641>>>>>>>>>    End_Procedure 
83642>>>>>>>>>
83642>>>>>>>>>
83642>>>>>>>>>
83642>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
83644>>>>>>>>>        Integer ihdbc
83644>>>>>>>>>        Integer ihstmt
83644>>>>>>>>>        String  sDrvrId
83644>>>>>>>>>        String  sMessage
83644>>>>>>>>>        Integer iVoid
83644>>>>>>>>>
83644>>>>>>>>>        //*** Initialize
83644>>>>>>>>>        Move "" To sMessage
83645>>>>>>>>>
83645>>>>>>>>>        //*** Get the cli handles
83645>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
83646>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83647>>>>>>>>>        Get psDriverId            to sDrvrId
83648>>>>>>>>>
83648>>>>>>>>>        //*** Call the procedure
83648>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
83650>>>>>>>>>            //*** Setup function arguments
83650>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
83655>>>>>>>>>
83655>>>>>>>>>            Move (Repeat(' ', 1024)) To sMessage
83656>>>>>>>>>            //*** Get the length
83656>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Self ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
83661>>>>>>>>>        End
83661>>>>>>>>>>
83661>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
83663>>>>>>>>>
83663>>>>>>>>>        Function_Return sMessage
83664>>>>>>>>>    End_Function 
83665>>>>>>>>>
83665>>>>>>>>>
83665>>>>>>>>>
83665>>>>>>>>>    //***
83665>>>>>>>>>    //*** Function: RemoveComponentIdentifier
83665>>>>>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
83665>>>>>>>>>    //***
83665>>>>>>>>>
83665>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
83667>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
83671>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
83672>>>>>>>>>        End
83673>>>>>>>>>>
83673>>>>>>>>>
83673>>>>>>>>>        Function_Return sDiagMessage
83674>>>>>>>>>    End_Function
83675>>>>>>>>>
83675>>>>>>>>>
83675>>>>>>>>>
83675>>>>>>>>>    //***
83675>>>>>>>>>    //*** Function: DFDateToSQLDate
83675>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
83675>>>>>>>>>    //***
83675>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
83677>>>>>>>>>        
83677>>>>>>>>>        Integer iType
83677>>>>>>>>>        String  sSQLDate
83677>>>>>>>>>        Integer iOrgDateFmt
83677>>>>>>>>>        Integer iOrgDateSep
83677>>>>>>>>>
83677>>>>>>>>>        String sDriverId
83677>>>>>>>>>        String sDummyZeroDate
83677>>>>>>>>>        String sDummyZeroDateMssqlDatetime
83677>>>>>>>>>
83677>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
83677>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83680>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83683>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83686>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83689>>>>>>>>>
83689>>>>>>>>>        //*** We only need to convert if the date is 0
83689>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
83691>>>>>>>>>
83691>>>>>>>>>            If (num_arguments < 2) Begin
83693>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
83694>>>>>>>>>            End
83694>>>>>>>>>>
83694>>>>>>>>>            Else Begin
83695>>>>>>>>>                Move iSQLType to iType
83696>>>>>>>>>            End
83696>>>>>>>>>>
83696>>>>>>>>>
83696>>>>>>>>>            
83696>>>>>>>>>            Get psDriverID to sDriverId
83697>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
83698>>>>>>>>>                
83698>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
83700>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83701>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
83702>>>>>>>>>            End
83702>>>>>>>>>>
83702>>>>>>>>>            Else Begin
83703>>>>>>>>>                Move sDummyZeroDate to sSQLDate
83704>>>>>>>>>            End
83704>>>>>>>>>>
83704>>>>>>>>>            
83704>>>>>>>>>            //CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE to sSQLDate
83704>>>>>>>>>        End
83704>>>>>>>>>>
83704>>>>>>>>>        Else Begin
83705>>>>>>>>>            Move dDFDate to sSQLDate
83706>>>>>>>>>        End
83706>>>>>>>>>>
83706>>>>>>>>>
83706>>>>>>>>>        //*** Change date format back to original
83706>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83709>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83712>>>>>>>>>
83712>>>>>>>>>        Function_Return sSQLDate
83713>>>>>>>>>    End_Function 
83714>>>>>>>>>
83714>>>>>>>>>
83714>>>>>>>>>    //***
83714>>>>>>>>>    //*** Function: SQLDateToDFDate
83714>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
83714>>>>>>>>>    //***
83714>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
83716>>>>>>>>>        
83716>>>>>>>>>        Integer iType
83716>>>>>>>>>        Date    dDFDate
83716>>>>>>>>>        Integer iOrgDateFmt
83716>>>>>>>>>        Integer iOrgDateSep
83716>>>>>>>>>        
83716>>>>>>>>>        String  sDriverId
83716>>>>>>>>>        String  sDummyZeroDate
83716>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
83716>>>>>>>>>        
83716>>>>>>>>>        Get psDriverID to sDriverId
83717>>>>>>>>>        
83717>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
83718>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83719>>>>>>>>>        
83719>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83722>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83725>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83728>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83731>>>>>>>>>        
83731>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate 
83732>>>>>>>>>
83732>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;             ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
83734>>>>>>>>>            Move 0 to dDFDate
83735>>>>>>>>>        End
83735>>>>>>>>>>
83735>>>>>>>>>        Else Begin
83736>>>>>>>>>            Move sSQLDate to dDFDate
83737>>>>>>>>>        End
83737>>>>>>>>>>
83737>>>>>>>>>
83737>>>>>>>>>        //*** Change date format back to original
83737>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83740>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83743>>>>>>>>>
83743>>>>>>>>>        Function_Return dDFDate
83744>>>>>>>>>    End_Function 
83745>>>>>>>>>
83745>>>>>>>>>End_Class 
83746>>>>>>>>>
83746>>>>>>>>>
83746>>>>>>>>>//*****************************************************************************
83746>>>>>>>>>//*** Class  : cSQLConnection                                               ***
83746>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
83746>>>>>>>>>//***                                                                       ***
83746>>>>>>>>>//*** Description:                                                          ***
83746>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
83746>>>>>>>>>//***   It will contain child statement objects                             ***
83746>>>>>>>>>//*****************************************************************************
83746>>>>>>>>>
83746>>>>>>>>>Class cSQLConnection is a cObject
83747>>>>>>>>>
83747>>>>>>>>>    Procedure Construct_object 
83749>>>>>>>>>        Forward Send Construct_object 
83751>>>>>>>>>
83751>>>>>>>>>        Property Integer phCLIConnectionHandle       0
83752>>>>>>>>>        
83752>>>>>>>>>        Property String  psDriverID        ""
83753>>>>>>>>>        Property Integer piBindFile        0
83754>>>>>>>>>        
83754>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
83755>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'        
83756>>>>>>>>>
83756>>>>>>>>>    End_Procedure
83757>>>>>>>>>
83757>>>>>>>>>
83757>>>>>>>>>
83757>>>>>>>>>    //***
83757>>>>>>>>>    //*** Procedure: StoreConnectionInfo
83757>>>>>>>>>    //*** Purpose  : Store basic information about the connection
83757>>>>>>>>>    //***
83757>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId 
83759>>>>>>>>>        
83759>>>>>>>>>        String sDummyZeroDate
83759>>>>>>>>>        
83759>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
83760>>>>>>>>>        Set psDriverID            to sDrvrId
83761>>>>>>>>>        
83761>>>>>>>>>        Case Begin
83761>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
83763>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83764>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
83765>>>>>>>>>                Break
83766>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
83769>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
83770>>>>>>>>>                Break
83771>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
83774>>>>>>>>>                CLI_Get_Driver_Attribute sDrvrId DRVR_DUMMY_ZERO_DATE_VALUE to sDummyZeroDate
83781>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
83782>>>>>>>>>                Break
83783>>>>>>>>>        Case End
83783>>>>>>>>>        
83783>>>>>>>>>    End_Procedure 
83784>>>>>>>>>
83784>>>>>>>>>
83784>>>>>>>>>    //***
83784>>>>>>>>>    //*** Procedure: DestroySQLConnection
83784>>>>>>>>>    //*** Purpose : Destroy the SQLConnection object
83784>>>>>>>>>    //***
83784>>>>>>>>>    Procedure DestroySQLConnection
83786>>>>>>>>>        Send Destroy
83787>>>>>>>>>    End_Procedure 
83788>>>>>>>>>
83788>>>>>>>>>
83788>>>>>>>>>    //***
83788>>>>>>>>>    //*** Function: SQLConnect
83788>>>>>>>>>    //*** Purpose : Connect to a database server
83788>>>>>>>>>    //*** Returns : 1 Succesfully connected
83788>>>>>>>>>    //***           0 Not connected
83788>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
83790>>>>>>>>>        Integer ihdbc
83790>>>>>>>>>        String  sEmpty
83790>>>>>>>>>
83790>>>>>>>>>        //*** Initialize
83790>>>>>>>>>        Move "" To sEmpty
83791>>>>>>>>>        Move 0  To ihdbc
83792>>>>>>>>>
83792>>>>>>>>>        Indicate Err False
83793>>>>>>>>>
83793>>>>>>>>>        //*** Call the driver function to connect
83793>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback Self ;                    Passing sConnect sEmpty Self ;                    Result ihdbc
83798>>>>>>>>>
83798>>>>>>>>>        //*** If there was an error, make result invalid
83798>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
83801>>>>>>>>>
83801>>>>>>>>>        //*** Check result and store it
83801>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
83804>>>>>>>>>
83804>>>>>>>>>        //*** Return success status
83804>>>>>>>>>        Function_Return (ihdbc <> 0)
83805>>>>>>>>>    End_Function 
83806>>>>>>>>>
83806>>>>>>>>>
83806>>>>>>>>>
83806>>>>>>>>>    //***
83806>>>>>>>>>    //*** Function: SQLFileConnect
83806>>>>>>>>>    //*** Purpose : Use a connection of an already open file
83806>>>>>>>>>    //***
83806>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83808>>>>>>>>>        Integer ihdbc
83808>>>>>>>>>        Integer bIsOpen
83808>>>>>>>>>        String  sDrvrId
83808>>>>>>>>>        String  sEmpty
83808>>>>>>>>>
83808>>>>>>>>>        //*** Initialize
83808>>>>>>>>>        Move "" To sEmpty
83809>>>>>>>>>        Move 0  To ihdbc
83810>>>>>>>>>
83810>>>>>>>>>        //*** Check if file is open
83810>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
83813>>>>>>>>>        If (bIsOpen) Begin
83815>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
83815>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
83816>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83819>>>>>>>>>
83819>>>>>>>>>            Indicate Err False
83820>>>>>>>>>
83820>>>>>>>>>            //*** Call the driver function to connect
83820>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
83825>>>>>>>>>
83825>>>>>>>>>            //*** If there was an error, make result invalid
83825>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
83828>>>>>>>>>
83828>>>>>>>>>            //*** Check result and store it
83828>>>>>>>>>            If (ihdbc <> 0) Begin
83830>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
83830>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
83833>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
83834>>>>>>>>>
83834>>>>>>>>>                //*** Set filenum so it can be used for fetching
83834>>>>>>>>>                Set piBindFile To iFileNum
83835>>>>>>>>>            End
83835>>>>>>>>>>
83835>>>>>>>>>        End
83835>>>>>>>>>>
83835>>>>>>>>>
83835>>>>>>>>>        //*** Return success status
83835>>>>>>>>>        Function_Return (ihdbc <> 0)
83836>>>>>>>>>    End_Function
83837>>>>>>>>>
83837>>>>>>>>>
83837>>>>>>>>>
83837>>>>>>>>>    //***
83837>>>>>>>>>    //*** Procedure: SQLDisconnect
83837>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
83837>>>>>>>>>    //***            resources
83837>>>>>>>>>    //***
83837>>>>>>>>>    Procedure SQLDisconnect
83839>>>>>>>>>        Integer ihdbc
83839>>>>>>>>>        Integer iVoid
83839>>>>>>>>>        String  sDrvrId
83839>>>>>>>>>        String  sEmpty
83839>>>>>>>>>
83839>>>>>>>>>        //*** Initialize
83839>>>>>>>>>        Move "" To sEmpty
83840>>>>>>>>>
83840>>>>>>>>>        //*** Get the cli handle
83840>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83841>>>>>>>>>        Get psDriverId To sDrvrId
83842>>>>>>>>>
83842>>>>>>>>>        //*** Free the CLI handle
83842>>>>>>>>>        If (ihdbc <> 0) Begin
83844>>>>>>>>>            //*** Call the driver function to disconnect
83844>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Self ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
83849>>>>>>>>>
83849>>>>>>>>>            Move -1 to giLastSQLhdbc
83850>>>>>>>>>
83850>>>>>>>>>            //*** Free the DataFlex handle
83850>>>>>>>>>            Send DestroySQLConnection
83851>>>>>>>>>        End
83851>>>>>>>>>>
83851>>>>>>>>>    End_Procedure 
83852>>>>>>>>>
83852>>>>>>>>>
83852>>>>>>>>>
83852>>>>>>>>>    //***
83852>>>>>>>>>    //*** Function: CreateSQLStatement
83852>>>>>>>>>    //*** Purpose : Create a cSQLStatement object
83852>>>>>>>>>    //***
83852>>>>>>>>>    Function CreateSQLStatement Returns Handle
83854>>>>>>>>>        
83854>>>>>>>>>        Handle hoSQLStatement
83854>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
83855>>>>>>>>>        
83855>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
83855>>>>>>>>>        //*** statement object. The default is set when you open a file with a
83855>>>>>>>>>        //*** SetFileConnection command.
83855>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
83856>>>>>>>>>        
83856>>>>>>>>>        Function_Return hoSQLStatement
83857>>>>>>>>>    End_Function 
83858>>>>>>>>>
83858>>>>>>>>>
83858>>>>>>>>>    //***
83858>>>>>>>>>    //*** Function: SQLOpen
83858>>>>>>>>>    //*** Prupose : Open a statement for use
83858>>>>>>>>>    //***
83858>>>>>>>>>    Function SQLOpen Returns Handle
83860>>>>>>>>>        Handle  hoSQLStatement
83860>>>>>>>>>        Integer ihdbc
83860>>>>>>>>>        Integer ihstmt
83860>>>>>>>>>        Integer iVoid
83860>>>>>>>>>        String  sDrvrId
83860>>>>>>>>>        String  sEmpty
83860>>>>>>>>>        String  sDummyZeroDate
83860>>>>>>>>>        String  sDummyZeroDateMssqlDatetime 
83860>>>>>>>>>
83860>>>>>>>>>        //*** Initialize
83860>>>>>>>>>        Move "" To sEmpty
83861>>>>>>>>>
83861>>>>>>>>>        //*** Get the cli handle to the connection
83861>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
83862>>>>>>>>>        Get psDriverId  To sDrvrId
83863>>>>>>>>>
83863>>>>>>>>>        //*** Allocate a new handle and populate it
83863>>>>>>>>>        If (ihdbc <> 0) Begin
83865>>>>>>>>>            //**** Create a new cSQLStatement object
83865>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
83866>>>>>>>>>
83866>>>>>>>>>            //*** Call the driver function to allocate a cli statement handle
83866>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Self ;                        Passing hoSQLStatement sEmpty ihdbc ;                        Result ihstmt
83871>>>>>>>>>
83871>>>>>>>>>            //*** If unsuccessful destroy hoSQLStatement
83871>>>>>>>>>            If (ihstmt = 0) Begin
83873>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
83874>>>>>>>>>                Move 0 to hoSQLStatement
83875>>>>>>>>>            End
83875>>>>>>>>>>
83875>>>>>>>>>            Else Begin
83876>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
83877>>>>>>>>>
83877>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
83877>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
83878>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
83879>>>>>>>>>                
83879>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
83880>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
83881>>>>>>>>>                
83881>>>>>>>>>            End
83881>>>>>>>>>>
83881>>>>>>>>>        End
83881>>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>        Function_Return hoSQLStatement
83882>>>>>>>>>    End_Function 
83883>>>>>>>>>
83883>>>>>>>>>End_Class 
83884>>>>>>>>>
83884>>>>>>>>>
83884>>>>>>>>>
83884>>>>>>>>>//*****************************************************************************
83884>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
83884>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
83884>>>>>>>>>//***                                                                       ***
83884>>>>>>>>>//*** Description:                                                          ***
83884>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
83884>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
83884>>>>>>>>>//***   connection. To allow this we have placed our own handle logic on    ***
83884>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
83884>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
83884>>>>>>>>>//*****************************************************************************
83884>>>>>>>>>
83884>>>>>>>>>Class cSQLHandleManager is a cObject
83885>>>>>>>>>
83885>>>>>>>>>    Procedure Construct_object 
83887>>>>>>>>>        Forward Send Construct_object 
83889>>>>>>>>>
83889>>>>>>>>>        Property String  psDefaultDriver      ""
83890>>>>>>>>>        Property String  psDefaultConnection  ""
83891>>>>>>>>>
83891>>>>>>>>>    End_Procedure 
83892>>>>>>>>>
83892>>>>>>>>>    //***
83892>>>>>>>>>    //*** Function: CreateSQLConnection
83892>>>>>>>>>    //*** Purpose : Create a cSQLConnection object
83892>>>>>>>>>    //***
83892>>>>>>>>>    Function CreateSQLConnection Returns Handle
83894>>>>>>>>>        Handle hoSQLConnection
83894>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
83895>>>>>>>>>        Function_Return hoSQLConnection
83896>>>>>>>>>    End_Function 
83897>>>>>>>>>
83897>>>>>>>>>
83897>>>>>>>>>    //***
83897>>>>>>>>>    //*** Procedure: SQLSetConnect
83897>>>>>>>>>    //*** Purpose  : Store default connection information
83897>>>>>>>>>    //***
83897>>>>>>>>>
83897>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
83899>>>>>>>>>        Set psDefaultDriver      To sDriver
83900>>>>>>>>>        Set psDefaultConnection  To sConnect
83901>>>>>>>>>    End_Procedure 
83902>>>>>>>>>
83902>>>>>>>>>
83902>>>>>>>>>
83902>>>>>>>>>    //***
83902>>>>>>>>>    //*** Function: SQLConnect
83902>>>>>>>>>    //*** Purpose : Make a connection to an embedded SQL server
83902>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
83902>>>>>>>>>    //***
83902>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
83904>>>>>>>>>        Handle hoSQLConnection
83904>>>>>>>>>        Integer bOK
83904>>>>>>>>>
83904>>>>>>>>>        //*** Check arguments
83904>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
83906>>>>>>>>>            Get psDefaultDriver      To sDrvrId
83907>>>>>>>>>            Get psDefaultConnection  To sConnect
83908>>>>>>>>>        End
83908>>>>>>>>>>
83908>>>>>>>>>
83908>>>>>>>>>        //*** Create a cSQLConnection object
83908>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83909>>>>>>>>>        //*** Connect to the database 
83909>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
83910>>>>>>>>>
83910>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83910>>>>>>>>>        If (not(bOK)) Begin
83912>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83913>>>>>>>>>            Move 0 to hoSQLConnection
83914>>>>>>>>>        End
83914>>>>>>>>>>
83914>>>>>>>>>
83914>>>>>>>>>        Function_Return hoSQLConnection
83915>>>>>>>>>    End_Function 
83916>>>>>>>>>
83916>>>>>>>>>
83916>>>>>>>>>
83916>>>>>>>>>    //***
83916>>>>>>>>>    //*** Function: SQLFileConnect
83916>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded SQL.
83916>>>>>>>>>    //***           The connection is identified by the number of a file
83916>>>>>>>>>    //***           that is open for that connection.
83916>>>>>>>>>    //***
83916>>>>>>>>>
83916>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
83918>>>>>>>>>        Handle hoSQLConnection
83918>>>>>>>>>        Integer bOK
83918>>>>>>>>>
83918>>>>>>>>>        //*** Create a cSQLConnection object
83918>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
83919>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum To bOK
83920>>>>>>>>>
83920>>>>>>>>>        //*** If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
83920>>>>>>>>>        If (not(bOK)) Begin
83922>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
83923>>>>>>>>>            Move 0 to hoSQLConnection
83924>>>>>>>>>        End
83924>>>>>>>>>>
83924>>>>>>>>>
83924>>>>>>>>>        Function_Return hoSQLConnection
83925>>>>>>>>>    End_Function 
83926>>>>>>>>>
83926>>>>>>>>>End_Class 
83927>>>>>>>>>
83927>>>>>>>
83927>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
83927>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
83927>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
83927>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
83927>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
83927>>>>>>>Define     WH_MOUSE for 7
83927>>>>>>>Define     WH_KEYBOARD for 2
83927>>>>>>>
83927>>>>>>>
83927>>>>>>>// suggestion lists use a global timer and a global suggestion list
83927>>>>>>>Global_Variable Handle ghoSuggestionList 
83927>>>>>>>Move 0 to ghoSuggestionList
83928>>>>>>>
83928>>>>>>>Global_Variable Handle ghoSuggestionTimer
83928>>>>>>>Move 0 to ghoSuggestionTimer
83929>>>>>>>
83929>>>>>>>// this will get created the first time it is needed. 
83929>>>>>>>Class cSuggestionTimer is a cTimer
83930>>>>>>>
83930>>>>>>>    Procedure Construct_Object
83932>>>>>>>        Forward Send Construct_Object
83934>>>>>>>        Property Handle phoTimerOwner 0
83935>>>>>>>        Set piTimeout to 50
83936>>>>>>>    End_Procedure
83937>>>>>>>  
83937>>>>>>>    Procedure OnTimer 
83939>>>>>>>        Handle hoOwner
83939>>>>>>>        Get phoTimerOwner to hoOwner
83940>>>>>>>        // do this in case progam close destroys owner before timer
83940>>>>>>>        Get Object_Id of hoOwner to hoOwner
83941>>>>>>>        If hoOwner Begin
83943>>>>>>>            Send OnSuggestionTimer to hoOwner
83944>>>>>>>        End
83944>>>>>>>>
83944>>>>>>>        Else Begin
83945>>>>>>>            // something wrong, shut off timer
83945>>>>>>>            Set pbEnabled to False   
83946>>>>>>>        End                                
83946>>>>>>>>
83946>>>>>>>    End_Procedure
83947>>>>>>>    
83947>>>>>>>End_Class
83948>>>>>>>
83948>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
83949>>>>>>>    
83949>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
83949>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83951>>>>>>>        tWinMouseHookStruct MouseHook
83951>>>>>>>        tWinMouseHookStruct MouseHook
83951>>>>>>>        Integer ivoid hObj
83951>>>>>>>        Handle hoOwner hoParent
83951>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
83953>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
83954>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
83955>>>>>>>            Get Parent to hoParent
83956>>>>>>>            Get phoOwner of hoParent to hoOwner
83957>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
83959>>>>>>>                Send DisableWindowsHook
83960>>>>>>>                Send DeActivateSuggestionList of hoOwner
83961>>>>>>>            End
83961>>>>>>>>
83961>>>>>>>        End
83961>>>>>>>>
83961>>>>>>>    End_Function
83962>>>>>>>
83962>>>>>>>    Procedure End_Construct_Object
83964>>>>>>>        Boolean bOk
83964>>>>>>>        Forward Send End_Construct_Object
83966>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk 
83967>>>>>>>    End_Procedure
83968>>>>>>>
83968>>>>>>>End_Class
83969>>>>>>>
83969>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
83970>>>>>>>    
83970>>>>>>>    // If menu key, close suggestionlist
83970>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
83972>>>>>>>        Handle hoOwner
83972>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
83974>>>>>>>            Delegate Get phoOwner to hoOwner
83976>>>>>>>            Send DisableWindowsHook
83977>>>>>>>            Send DeActivateSuggestionList of hoOwner
83978>>>>>>>        End
83978>>>>>>>>
83978>>>>>>>    End_Function
83979>>>>>>>    
83979>>>>>>>    Procedure End_Construct_Object
83981>>>>>>>        Boolean bOk
83981>>>>>>>        Forward Send End_Construct_Object
83983>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk  
83984>>>>>>>    End_Procedure
83985>>>>>>>
83985>>>>>>>End_Class
83986>>>>>>>
83986>>>>>>>Class cSuggestionList is a cRichEdit
83987>>>>>>>    
83987>>>>>>>    Procedure Construct_Object
83989>>>>>>>        Handle hoObj
83989>>>>>>>        Forward Send Construct_Object
83991>>>>>>>        Property Handle phoOwner
83992>>>>>>>        Set Focus_Mode to NonFocusable
83993>>>>>>>        Set Attach_Parent_State to True
83994>>>>>>>        Set pbWrap to False
83995>>>>>>>        If (ghoSuggestionList) Begin
83997>>>>>>>            Send Destroy of ghoSuggestionList
83998>>>>>>>        End
83998>>>>>>>>
83998>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
83999>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
84000>>>>>>>    End_Procedure
84001>>>>>>>    
84001>>>>>>>    Procedure Destroy_Object
84003>>>>>>>        Forward Send Destroy_Object
84005>>>>>>>        Move 0 to ghoSuggestionList
84006>>>>>>>    End_Procedure
84007>>>>>>>    
84007>>>>>>>    Procedure DeactivateList
84009>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
84010>>>>>>>        Send Deactivate
84011>>>>>>>        Send Destroy
84012>>>>>>>    End_Procedure
84013>>>>>>>    
84013>>>>>>>    Procedure InitList Handle hoForm
84015>>>>>>>        Integer iSize iLoc iLoc2
84015>>>>>>>        Get GuiSize of hoForm to iSize
84016>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
84017>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
84018>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
84020>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
84021>>>>>>>        Set Visible_State to False
84022>>>>>>>    End_Procedure
84023>>>>>>>    
84023>>>>>>>    // scroll up one line
84023>>>>>>>    Procedure ScrollUp
84025>>>>>>>        Integer iLine
84025>>>>>>>        Get SelectedRow to iLine
84026>>>>>>>        If (iLine) Begin
84028>>>>>>>            Send SelectRow (iLine-1)
84029>>>>>>>        End
84029>>>>>>>>
84029>>>>>>>    End_Procedure
84030>>>>>>>    
84030>>>>>>>    // scroll down one line
84030>>>>>>>    Procedure ScrollDown
84032>>>>>>>        Integer iLine iLines
84032>>>>>>>        Get Line_Count to iLines
84033>>>>>>>        Get SelectedRow to iLine
84034>>>>>>>        // there can be an extra line at the end
84034>>>>>>>        If (iLine<iLines-1) Begin
84036>>>>>>>            Send SelectRow (iLine+1)
84037>>>>>>>        End
84037>>>>>>>>
84037>>>>>>>    End_Procedure
84038>>>>>>>    
84038>>>>>>>    // sets the current line to iLine and highlights it
84038>>>>>>>    Procedure SelectRow Integer iLine
84040>>>>>>>        Integer iPos iLen
84040>>>>>>>        Get FirstCharInLinePos iLine to iPos
84041>>>>>>>        Get LineLength iLine to iLen
84042>>>>>>>        Send SetSel iPos (iPos+iLen)
84043>>>>>>>    End_Procedure
84044>>>>>>>    
84044>>>>>>>    // get the current selected Line
84044>>>>>>>    Function SelectedRow Returns Integer
84046>>>>>>>        Integer iLine
84046>>>>>>>        Get LineFromChar -1 to iLine
84047>>>>>>>        Function_Return iLine
84048>>>>>>>    End_Function
84049>>>>>>>
84049>>>>>>>    // select the current row 
84049>>>>>>>    Procedure Mouse_Up Integer hCell Integer iPos
84051>>>>>>>        Handle hoObj
84051>>>>>>>        Get phoOwner to hoObj
84052>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
84053>>>>>>>        Send SelectSuggestion of hoObj
84054>>>>>>>    End_Procedure // Mouse_Up
84055>>>>>>>      
84055>>>>>>>End_Class
84056>>>>>>>
84056>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
84056>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
84056>>>>>>>Class cSuggestion_mixin is a Mixin
84057>>>>>>>    
84057>>>>>>>    Procedure Define_cSuggestion_mixin
84059>>>>>>>        
84059>>>>>>>        Property Integer peSuggestionMode smFind
84060>>>>>>>        Property Boolean pbFullText False
84061>>>>>>>        Property Boolean pbCaseSensitive False
84062>>>>>>>        Property Integer piMaxResults 15
84063>>>>>>>        Property Integer piStartAtChar 2
84064>>>>>>>        Property Boolean pbFullWidth True
84065>>>>>>>        Property Integer piFindIndex 0
84066>>>>>>>        Property Boolean pbFindOnSelect True
84067>>>>>>>        Property Integer piPopupTimeout 50
84068>>>>>>>        
84068>>>>>>>        Property tSuggestion[] pSearchResults
84069>>>>>>>
84069>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
84070>>>>>>>        
84070>>>>>>>    End_Procedure
84071>>>>>>>    
84071>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
84071>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
84071>>>>>>>    // if private
84071>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
84073>>>>>>>        Integer i iCols iPos
84073>>>>>>>        String sValue
84073>>>>>>>        Integer eSuggestionMode
84073>>>>>>>        Boolean bFullText
84073>>>>>>>        
84073>>>>>>>        Get peSuggestionMode to eSuggestionMode
84074>>>>>>>        Get pbFullText to bFullText
84075>>>>>>>        
84075>>>>>>>        Move SuggestionData.aValues[0] to sValue
84076>>>>>>>        If (not(bFullText)) Begin
84078>>>>>>>            Set pbBold of ghoSuggestionList to True
84079>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch))) 
84080>>>>>>>            Set pbBold of ghoSuggestionList to False
84081>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1)) 
84082>>>>>>>        End
84082>>>>>>>>
84082>>>>>>>        Else Begin
84083>>>>>>>            Set pbBold of ghoSuggestionList to False
84084>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
84085>>>>>>>            If (iPos) Begin
84087>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1)) 
84088>>>>>>>                Set pbBold of ghoSuggestionList to True
84089>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos)) 
84090>>>>>>>                Set pbBold of ghoSuggestionList to False
84091>>>>>>>            End
84091>>>>>>>>
84091>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch))) 
84092>>>>>>>        End
84092>>>>>>>>
84092>>>>>>>        
84092>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
84092>>>>>>>        // matched and we display all other values (usually just one) to the
84092>>>>>>>        // right of it. 
84092>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
84093>>>>>>>        If (iCols>1) Begin
84095>>>>>>>            Move "" to sValue
84096>>>>>>>            For i from 1 to (iCols-1)
84102>>>>>>>>
84102>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
84103>>>>>>>            Loop
84104>>>>>>>>
84104>>>>>>>            Send AppendText of ghoSuggestionList sValue
84105>>>>>>>        End
84105>>>>>>>>
84105>>>>>>>    End_Procedure
84106>>>>>>>    
84106>>>>>>>    // used to catch a set_field_value_Error
84106>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
84108>>>>>>>    End_Procedure
84109>>>>>>>    
84109>>>>>>>    // does a Set_Field_Value with error testing around it.
84109>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
84111>>>>>>>        Handle hoOldError
84111>>>>>>>        Boolean bErr
84111>>>>>>>        Move Error_Object_Id to hoOldError
84112>>>>>>>        Move Self to Error_Object_Id
84113>>>>>>>        Move False to Err 
84114>>>>>>>        Set_Field_Value iFile iField to sValue
84117>>>>>>>        Move Err to bErr
84118>>>>>>>        Move hoOldError to Error_Object_Id
84119>>>>>>>        Function_Return bErr        
84120>>>>>>>    End_Function
84121>>>>>>>
84121>>>>>>>
84121>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
84123>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
84123>>>>>>>        Handle hoServer
84123>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
84123>>>>>>>        String sVal sLowSearch
84123>>>>>>>        RowID riTest
84123>>>>>>>        
84123>>>>>>>        Get Server to hoServer
84124>>>>>>>        Get Data_File  to iFile
84125>>>>>>>        Get Data_Field to iField       
84126>>>>>>>        
84126>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84128>>>>>>>            Get piFindIndex to iIndex
84129>>>>>>>            Get piMaxResults to iMax
84130>>>>>>>            Get pbCaseSensitive to bCase
84131>>>>>>>            
84131>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
84134>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
84137>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
84140>>>>>>>            
84140>>>>>>>            Move (iLength - iDec) to iLength
84141>>>>>>>            
84141>>>>>>>            If (iIndex <= 0) Begin
84143>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84146>>>>>>>            End
84146>>>>>>>>
84146>>>>>>>            
84146>>>>>>>            
84146>>>>>>>            
84146>>>>>>>            If (iIndex > 0) Begin
84148>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
84149>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84150>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
84151>>>>>>>                                
84151>>>>>>>                Move True to bContinue
84152>>>>>>>                Move (Length(sSearch)) to iLen
84153>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
84154>>>>>>>                Move 0 to iRow
84155>>>>>>>                
84155>>>>>>>                //  Find first record
84155>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84156>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
84157>>>>>>>                If bInvalid Begin
84159>>>>>>>                    Move False to bContinue
84160>>>>>>>                End
84160>>>>>>>>
84160>>>>>>>                
84160>>>>>>>                If (bContinue) Begin
84162>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
84163>>>>>>>                End
84163>>>>>>>>
84163>>>>>>>                
84163>>>>>>>                While (Found and bContinue)
84167>>>>>>>                    Get_Field_Value iFile iField to sVal
84170>>>>>>>                    
84170>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
84172>>>>>>>
84172>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84173>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84174>>>>>>>                        Increment iRow
84175>>>>>>>                        
84175>>>>>>>                        Move (iRow < iMax) to bContinue
84176>>>>>>>                       
84176>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex  
84177>>>>>>>                    End
84177>>>>>>>>
84177>>>>>>>                    Else Begin
84178>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
84180>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
84180>>>>>>>                            
84180>>>>>>>                            Move (GetRowID(iFile)) to riTest
84181>>>>>>>                            
84181>>>>>>>                            Move (sSearch * 10) to sSearch
84182>>>>>>>                            
84182>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
84183>>>>>>>                            If bInvalid Begin
84185>>>>>>>                                Move False to bContinue
84186>>>>>>>                            End
84186>>>>>>>>
84186>>>>>>>                            Else Begin
84187>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
84188>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
84189>>>>>>>                            End 
84189>>>>>>>>
84189>>>>>>>                        End
84189>>>>>>>>
84189>>>>>>>                        Else Begin
84190>>>>>>>                            Move False to bContinue
84191>>>>>>>                        End
84191>>>>>>>>
84191>>>>>>>                    End
84191>>>>>>>>
84191>>>>>>>                    
84191>>>>>>>                Loop
84192>>>>>>>>
84192>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
84193>>>>>>>            End
84193>>>>>>>>
84193>>>>>>>        End
84193>>>>>>>>
84193>>>>>>>    End_Procedure
84194>>>>>>>    
84194>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
84196>>>>>>>        Integer iFile iField iIndex iRow iMax
84196>>>>>>>        Handle hoServer
84196>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
84196>>>>>>>        String sVal sLowSearch
84196>>>>>>>        
84196>>>>>>>        Get Server to hoServer
84197>>>>>>>        Get Data_File  to iFile
84198>>>>>>>        Get Data_Field to iField       
84199>>>>>>>        
84199>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84201>>>>>>>            Get piMaxResults to iMax
84202>>>>>>>            Get pbCaseSensitive to bCase
84203>>>>>>>            
84203>>>>>>>            Get piFindIndex to iIndex
84204>>>>>>>            If (iIndex <= 0) Begin
84206>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84209>>>>>>>            End
84209>>>>>>>>
84209>>>>>>>            
84209>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84210>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84211>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84212>>>>>>>            
84212>>>>>>>            
84212>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
84213>>>>>>>            Move True to bContinue
84214>>>>>>>            Move 0 to iRow
84215>>>>>>>                
84215>>>>>>>            //  Find first record
84215>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84216>>>>>>>            
84216>>>>>>>            While (Found and (iRow < iMax))
84220>>>>>>>                Get_Field_Value iFile iField to sVal
84223>>>>>>>                
84223>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
84225>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84226>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84227>>>>>>>                    Increment iRow
84228>>>>>>>                End
84228>>>>>>>>
84228>>>>>>>                
84228>>>>>>>                Send Request_Read of hoServer GT iFile iIndex 
84229>>>>>>>            Loop
84230>>>>>>>>
84230>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84231>>>>>>>        End
84231>>>>>>>>
84231>>>>>>>    End_Procedure
84232>>>>>>>    
84232>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
84234>>>>>>>        Integer iFile iField iIndex iRow iMax
84234>>>>>>>        Handle hoServer
84234>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
84234>>>>>>>        String sVal sOrigFilter sFilter sFile sField
84234>>>>>>>        
84234>>>>>>>        Get Server to hoServer
84235>>>>>>>        Get Data_File  to iFile
84236>>>>>>>        Get Data_Field to iField       
84237>>>>>>>        
84237>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84239>>>>>>>            
84239>>>>>>>            // make sure we send DD messages to owner DDO
84239>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
84240>>>>>>>            If (hoServer=0) Begin
84242>>>>>>>                Procedure_Return
84243>>>>>>>            End
84243>>>>>>>>
84243>>>>>>>            
84243>>>>>>>            Get piMaxResults to iMax
84244>>>>>>>            Get piFindIndex to iIndex
84245>>>>>>>            If (iIndex <= 0) Begin
84247>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
84250>>>>>>>            End
84250>>>>>>>>
84250>>>>>>>            
84250>>>>>>>            //  Determine current filter settings
84250>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
84251>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
84252>>>>>>>            
84252>>>>>>>            // generate the Like filter string
84252>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
84253>>>>>>>            // If filtering was active append this to what's there
84253>>>>>>>            If (bOrigActive) Begin
84255>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
84256>>>>>>>            End
84256>>>>>>>>
84256>>>>>>>            
84256>>>>>>>            //  Set filter
84256>>>>>>>            Set psSQLFilter of hoServer to sFilter
84257>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
84258>>>>>>>            
84258>>>>>>>            
84258>>>>>>>            // this will optimize No_relate. If your DF constraint does not
84258>>>>>>>            // need a post-relate test, we will disabled relates for this
84258>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
84259>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
84260>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
84261>>>>>>>
84261>>>>>>>            //  Find records
84261>>>>>>>            Move True to bContinue
84262>>>>>>>            Move 0 to iRow
84263>>>>>>>            
84263>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
84264>>>>>>>            
84264>>>>>>>            While (bContinue)
84268>>>>>>>                Get_Field_Value iFile iField to sVal
84271>>>>>>>                
84271>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
84273>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
84274>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
84275>>>>>>>                    Increment iRow
84276>>>>>>>                    
84276>>>>>>>                    Move (iRow < iMax) to bContinue
84277>>>>>>>                   
84277>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex 
84278>>>>>>>                End
84278>>>>>>>>
84278>>>>>>>                Else Begin
84279>>>>>>>                    Move False to bContinue
84280>>>>>>>                End
84280>>>>>>>>
84280>>>>>>>                
84280>>>>>>>            Loop
84281>>>>>>>>
84281>>>>>>>            
84281>>>>>>>            //  Restore filters
84281>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
84282>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
84283>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
84284>>>>>>>        End
84284>>>>>>>>
84284>>>>>>>    End_Procedure
84285>>>>>>>    
84285>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
84287>>>>>>>        Handle hoServer hoTable
84287>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
84287>>>>>>>        Variant[][] aData
84288>>>>>>>        Boolean bCaseSensitive bContinue
84288>>>>>>>        String sDescr sVal
84288>>>>>>>        
84288>>>>>>>        Get Server to hoServer
84289>>>>>>>        Get Data_File  to iFile
84290>>>>>>>        Get Data_Field to iField       
84291>>>>>>>        
84291>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84293>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
84294>>>>>>>            If (hoTable <> 0) Begin
84296>>>>>>>                Get tabledata of hoTable to aData
84297>>>>>>>        
84297>>>>>>>                Get piMaxResults to iMax
84298>>>>>>>                Get pbCaseSensitive to bCaseSensitive  
84299>>>>>>>            
84299>>>>>>>                If (not(bCaseSensitive)) Begin
84301>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
84302>>>>>>>                End
84302>>>>>>>>
84302>>>>>>>                
84302>>>>>>>                
84302>>>>>>>                Move (SizeOfArray(aData)) to iCount
84303>>>>>>>                Move 0 to iRow
84304>>>>>>>                Move (Length(sSearch)) to iLen
84305>>>>>>>                Move True to bContinue
84306>>>>>>>                
84306>>>>>>>            
84306>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
84310>>>>>>>                    If (not(bCaseSensitive)) Begin
84312>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
84313>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
84314>>>>>>>                    End
84314>>>>>>>>
84314>>>>>>>                    Else Begin
84315>>>>>>>                        Move aData[iRow][0] to sVal
84316>>>>>>>                        Move aData[iRow][1] to sDescr
84317>>>>>>>                    End
84317>>>>>>>>
84317>>>>>>>                    
84317>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
84319>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
84320>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
84321>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
84322>>>>>>>                        Increment iFound
84323>>>>>>>                    End
84323>>>>>>>>
84323>>>>>>>                    Else Begin
84324>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
84325>>>>>>>                    End
84325>>>>>>>>
84325>>>>>>>                    
84325>>>>>>>                    Increment iRow
84326>>>>>>>                Loop
84327>>>>>>>>
84327>>>>>>>            End
84327>>>>>>>>
84327>>>>>>>        End
84327>>>>>>>>
84327>>>>>>>         
84327>>>>>>>    End_Procedure
84328>>>>>>>    
84328>>>>>>>    
84328>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84330>>>>>>>        Integer iMode iFile
84330>>>>>>>        Boolean bFullText bResult bSupportsSQL
84330>>>>>>>        Handle hoServer
84330>>>>>>>        
84330>>>>>>>        Get Server to hoServer
84331>>>>>>>        Get Data_File  to iFile
84332>>>>>>>        
84332>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84334>>>>>>>            
84334>>>>>>>            Get peSuggestionMode to iMode
84335>>>>>>>            Get pbFullText to bFullText
84336>>>>>>>            
84336>>>>>>>            If (iMode = smFind) Begin
84338>>>>>>>                If (not(bFullText)) Begin
84340>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
84341>>>>>>>                End
84341>>>>>>>>
84341>>>>>>>                Else Begin
84342>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
84343>>>>>>>                    If (bSupportsSQL) Begin
84345>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
84346>>>>>>>                    End
84346>>>>>>>>
84346>>>>>>>                    Else Begin
84347>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
84348>>>>>>>                    End
84348>>>>>>>>
84348>>>>>>>                End
84348>>>>>>>>
84348>>>>>>>            End
84348>>>>>>>>
84348>>>>>>>            Else If (iMode = smValidationTable) Begin
84351>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
84352>>>>>>>            End
84352>>>>>>>>
84352>>>>>>>        End
84352>>>>>>>>
84352>>>>>>>    End_Procedure
84353>>>>>>>    
84353>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84355>>>>>>>        Handle hoServer
84355>>>>>>>        Integer iFile iField iMode
84355>>>>>>>        Boolean bFind
84355>>>>>>>        RowID rRowId
84355>>>>>>>        
84355>>>>>>>        Get Server to hoServer
84356>>>>>>>        Get Data_File  to iFile
84357>>>>>>>        Get Data_Field to iField       
84358>>>>>>>        
84358>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
84360>>>>>>>            Get peSuggestionMode to iMode
84361>>>>>>>            
84361>>>>>>>            If (iMode = smFind) Begin
84363>>>>>>>                Get pbFindOnSelect to bFind
84364>>>>>>>                If (bFind) Begin
84366>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId    
84367>>>>>>>                    
84367>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
84369>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
84370>>>>>>>                    End
84370>>>>>>>>
84370>>>>>>>                End
84370>>>>>>>>
84370>>>>>>>                Else Begin
84371>>>>>>>                    Set Value to Suggestion.aValues[0]
84372>>>>>>>                    Set Item_Changed_State to True
84373>>>>>>>                End
84373>>>>>>>>
84373>>>>>>>            End
84373>>>>>>>>
84373>>>>>>>            Else If (imode = smValidationTable) Begin
84376>>>>>>>                Set Value to Suggestion.sRowId
84377>>>>>>>                Set Item_Changed_State to True
84378>>>>>>>            End
84378>>>>>>>>
84378>>>>>>>            
84378>>>>>>>        End
84378>>>>>>>>
84378>>>>>>>    End_Procedure
84379>>>>>>>    
84379>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
84379>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
84381>>>>>>>        Integer iStartAtChar
84381>>>>>>>        Get piStartAtChar to iStartAtChar
84382>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
84383>>>>>>>    End_Function
84384>>>>>>>    
84384>>>>>>>    
84384>>>>>>>End_Class
84385>>>>>>>
84385>>>>>>>
84385>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in 
84385>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
84385>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
84385>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
84385>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
84385>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
84385>>>>>>>// is in the parent
84385>>>>>>> 
84385>>>>>>>Class cSuggestionControl_mixin is a Mixin
84386>>>>>>>    
84386>>>>>>>    Procedure Define_cSuggestionControl_mixin
84388>>>>>>>        
84388>>>>>>>        Property Integer piTimeOutTicks 0
84389>>>>>>>        
84389>>>>>>>        On_Key kEnter Send SelectSuggestion
84390>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
84391>>>>>>>        On_Key Key_Up_Arrow Send Up
84392>>>>>>>        On_Key Key_Down_Arrow Send Down
84393>>>>>>>
84393>>>>>>>    End_Procedure
84394>>>>>>>
84394>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
84396>>>>>>>        Integer i  iX iMax iY
84396>>>>>>>        String sTxt
84396>>>>>>>        Boolean bFullWidth
84396>>>>>>>        For i from 0 to (iLines-1)
84402>>>>>>>>
84402>>>>>>>            Get Line of ghoSuggestionList i to sTxt
84403>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
84404>>>>>>>            Move (Low(iX) max iMax) to iMax
84405>>>>>>>            Move (Hi(iX)) to iY
84406>>>>>>>        Loop
84407>>>>>>>>
84407>>>>>>>        Move (iMax + 20) to imax
84408>>>>>>>        Get pbFullWidth to bFullWidth
84409>>>>>>>        If bFullWidth Begin
84411>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
84412>>>>>>>        End
84412>>>>>>>>
84412>>>>>>>        If (iLines) Begin
84414>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
84415>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
84416>>>>>>>        End
84416>>>>>>>>
84416>>>>>>>        Else Begin
84417>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
84418>>>>>>>        End
84418>>>>>>>>
84418>>>>>>>    End_Procedure
84419>>>>>>>    
84419>>>>>>>    // show all suggestions
84419>>>>>>>    Procedure ShowSuggestions
84421>>>>>>>        tSuggestion[] aResults
84421>>>>>>>        tSuggestion[] aResults
84422>>>>>>>        Integer i iLines
84422>>>>>>>        String sSearch 
84422>>>>>>>        Get pSearchResults to aResults
84423>>>>>>>        Get Value to sSearch
84424>>>>>>>        Send Delete_Data of ghoSuggestionList
84425>>>>>>>        Move (SizeOfArray(aResults)) to iLines
84426>>>>>>>        For i from 0 to (iLines-1)
84432>>>>>>>>
84432>>>>>>>            Send ShowSuggestion aResults[i] sSearch
84433>>>>>>>            If ((iLines-1)<>i) Begin
84435>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
84436>>>>>>>            End
84436>>>>>>>>
84436>>>>>>>        Loop
84437>>>>>>>>
84437>>>>>>>        Send AdjustSuggestionListSize iLines
84438>>>>>>>    End_Procedure
84439>>>>>>>
84439>>>>>>>    Procedure FindSuggestions 
84441>>>>>>>        String sSearch
84441>>>>>>>        tSuggestion[] aResults
84441>>>>>>>        tSuggestion[] aResults
84442>>>>>>>        String[] aParams
84443>>>>>>>        Get Value to sSearch
84444>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
84445>>>>>>>        Set pSearchResults to aResults
84446>>>>>>>        // if an error was raised, the suggestion list will be gone
84446>>>>>>>        If (ghoSuggestionList) Begin
84448>>>>>>>            Send ShowSuggestions
84449>>>>>>>        End
84449>>>>>>>>
84449>>>>>>>    End_Procedure
84450>>>>>>>
84450>>>>>>>    Procedure SelectSuggestion 
84452>>>>>>>        String sSearch
84452>>>>>>>        tSuggestion[] aData
84452>>>>>>>        tSuggestion[] aData
84453>>>>>>>        Integer iSelRow
84453>>>>>>>        If ghoSuggestionList Begin
84455>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
84456>>>>>>>            Get Value to sSearch
84457>>>>>>>            Get pSearchResults to aData        
84458>>>>>>>            Send DeActivateSuggestionList
84459>>>>>>>            Send CancelEditIfGrid
84460>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
84462>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow] 
84463>>>>>>>            End
84463>>>>>>>>
84463>>>>>>>        End
84463>>>>>>>>
84463>>>>>>>        Else Begin
84464>>>>>>>            Send Default_Action
84465>>>>>>>        End
84465>>>>>>>>
84465>>>>>>>    End_Procedure
84466>>>>>>>    
84466>>>>>>>    Procedure CancelEditIfGrid
84468>>>>>>>        // do nothing with forms, remember
84468>>>>>>>        // to replace or augment with grid to
84468>>>>>>>        // cancel the edit control
84468>>>>>>>    End_Procedure
84469>>>>>>>
84469>>>>>>>    
84469>>>>>>>    Function ParentForSuggestion Returns Handle
84471>>>>>>>        Handle hoMain hoMainPanel
84471>>>>>>>
84471>>>>>>>        // we must have an application object and a main panel object
84471>>>>>>>        If ghoApplication Begin
84473>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84474>>>>>>>        End
84474>>>>>>>>
84474>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
84476>>>>>>>            Function_Return 0
84477>>>>>>>        End
84477>>>>>>>>
84477>>>>>>>
84477>>>>>>>        Move Self to hoMain
84478>>>>>>>        Repeat
84478>>>>>>>>
84478>>>>>>>            Get Parent of hoMain to hoMain
84479>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
84481>>>>>>>
84481>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
84482>>>>>>>        
84482>>>>>>>    End_Function
84483>>>>>>>    
84483>>>>>>>    Procedure ActivateSuggestionList
84485>>>>>>>        Handle hoView hcSuggest
84485>>>>>>>        Get ParentForSuggestion to hoView
84486>>>>>>>        If hoView Begin
84488>>>>>>>            Get phcSuggestionListClass to hcSuggest
84489>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
84490>>>>>>>            Send InitList of ghoSuggestionList Self
84491>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
84492>>>>>>>            Set phoOwner of ghoSuggestionList to Self
84493>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
84494>>>>>>>        End
84494>>>>>>>>
84494>>>>>>>    End_Procedure
84495>>>>>>>    
84495>>>>>>>    Procedure DeActivateSuggestionList
84497>>>>>>>        If ghoSuggestionList Begin
84499>>>>>>>            Send DeactivateList of ghoSuggestionList
84500>>>>>>>        End
84500>>>>>>>>
84500>>>>>>>    End_Procedure
84501>>>>>>>    
84501>>>>>>>    // augment to kill suggest list if focus is not moving to it  
84501>>>>>>>    // customized for grid
84501>>>>>>>    Procedure OnKillFocus
84503>>>>>>>        // note focus has already changed here
84503>>>>>>>        If (ghoSuggestionList) Begin
84505>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
84507>>>>>>>                Send DeActivateSuggestionList
84508>>>>>>>                Forward Send OnKillFocus
84510>>>>>>>            End
84510>>>>>>>>
84510>>>>>>>            Else Begin
84511>>>>>>>                // giving focus to the suggestion list here
84511>>>>>>>            End
84511>>>>>>>>
84511>>>>>>>        End
84511>>>>>>>>
84511>>>>>>>        Else Begin
84512>>>>>>>            Forward Send OnKillFocus
84514>>>>>>>        End
84514>>>>>>>>
84514>>>>>>>    End_Procedure
84515>>>>>>>    
84515>>>>>>>    Procedure Up
84517>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84519>>>>>>>           Send ScrollUp of ghoSuggestionList
84520>>>>>>>        End
84520>>>>>>>>
84520>>>>>>>    End_Procedure
84521>>>>>>>
84521>>>>>>>    Procedure Down
84523>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
84525>>>>>>>           Send ScrollDown of ghoSuggestionList
84526>>>>>>>        End
84526>>>>>>>>
84526>>>>>>>    End_Procedure
84527>>>>>>>    
84527>>>>>>>
84527>>>>>>>    Procedure Key Integer iKey
84529>>>>>>>        Integer iEndTicks
84529>>>>>>>        
84529>>>>>>>        If (Focus(Desktop) <> Self) Begin
84531>>>>>>>          Forward Send Key iKey
84533>>>>>>>          Procedure_Return
84534>>>>>>>        End
84534>>>>>>>>
84534>>>>>>>        
84534>>>>>>>        Send DeActivateSuggestionList
84535>>>>>>>        Move (GetTickCount()) to iEndTicks
84536>>>>>>>        // record the time of key press
84536>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
84538>>>>>>>         
84538>>>>>>>            If (ghoSuggestionTimer=0) Begin
84540>>>>>>>               Send CreateSuggestionTimer
84541>>>>>>>            End
84541>>>>>>>>
84541>>>>>>>         
84541>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
84542>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
84543>>>>>>>        End
84543>>>>>>>>
84543>>>>>>>        Set piTimeOutTicks to iEndTicks
84544>>>>>>>        
84544>>>>>>>        Forward Send Key iKey
84546>>>>>>>    End_Procedure
84547>>>>>>>    
84547>>>>>>>    Procedure CreateSuggestionTimer
84549>>>>>>>        Handle hoMainPanel
84549>>>>>>>        // we must have an application object and a main panel object
84549>>>>>>>        If ghoApplication Begin
84551>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
84552>>>>>>>        End
84552>>>>>>>>
84552>>>>>>>        If (hoMainPanel=0) Begin
84554>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
84555>>>>>>>>
84555>>>>>>>            Procedure_Return
84556>>>>>>>        End
84556>>>>>>>>
84556>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
84557>>>>>>>    End_Procedure
84558>>>>>>>  
84558>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
84558>>>>>>>    Procedure OnSuggestionTimer
84560>>>>>>>        Boolean bDoIt
84560>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
84560>>>>>>>        String sValue
84560>>>>>>>        
84560>>>>>>>        If (Focus(Desktop) <> Self) Begin
84562>>>>>>>            // focus out of whack. Stop the timer
84562>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
84563>>>>>>>            Send DeActivateSuggestionList   
84564>>>>>>>            Procedure_Return
84565>>>>>>>        End                                
84565>>>>>>>>
84565>>>>>>>
84565>>>>>>>        Get piTimeOutTicks to iStartTicks
84566>>>>>>>        If (iStartTicks <> 0) Begin           
84568>>>>>>>            Move (GetTickCount()) to iEndTicks 
84569>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
84570>>>>>>>            // If tick count rolled over
84570>>>>>>>            If (iTicks < 0) Begin
84572>>>>>>>                Move (-iTicks) to iTicks 
84573>>>>>>>            End
84573>>>>>>>>
84573>>>>>>>        End
84573>>>>>>>>
84573>>>>>>>        Get piPopupTimeout to iTimeOut
84574>>>>>>>        If (iTicks >= iTimeOut) Begin
84576>>>>>>>            // If time delay has been met, launch autocomplete
84576>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
84577>>>>>>>            Get Value to sValue
84578>>>>>>>            Get Item_Changed_State 0 to iChanged
84579>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
84580>>>>>>>            If bDoIt Begin
84582>>>>>>>                Send ActivateSuggestionList
84583>>>>>>>                Send FindSuggestions
84584>>>>>>>                Set Visible_State of ghoSuggestionList to True
84585>>>>>>>            End
84585>>>>>>>>
84585>>>>>>>            Set piTimeOutTicks to 0
84586>>>>>>>        End
84586>>>>>>>>
84586>>>>>>>    End_Procedure
84587>>>>>>>
84587>>>>>>>End_Class
84588>>>>>>>
84588>>>>>
84588>>>>>Class DbSuggestionForm is a dbForm
84589>>>>>    
84589>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84590>>>>>    Import_Class_Protocol cSuggestion_mixin
84591>>>>>    
84591>>>>>    Procedure Construct_Object
84593>>>>>        Forward Send Construct_Object
84595>>>>>        Send Define_cSuggestionControl_mixin
84596>>>>>        Send Define_cSuggestion_mixin    
84597>>>>>    End_Procedure
84598>>>>>    
84598>>>>>End_Class
84599>>>>>
84599>>>Use cDbCJGridColumnSuggestion.pkg
Including file: cDbCJGridColumnSuggestion.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cDbCJGridColumnSuggestion.pkg)
84599>>>>>Use WinSuggestion.pkg
84599>>>>>Use cDbCJGridColumn.pkg
84599>>>>>Use cDbCJGridColumnEdit.pkg
84599>>>>>
84599>>>>>// This is the edit control that gets embedded in cDbCJGridColumnSuggestion object.
84599>>>>>
84599>>>>>Class cDbCJGridColumnSuggestionEdit is a cDbCJGridColumnEdit
84600>>>>>
84600>>>>>    Import_Class_Protocol cSuggestionControl_mixin
84601>>>>>
84601>>>>>    Procedure Construct_Object
84603>>>>>        Forward Send Construct_Object
84605>>>>>        Send Define_cSuggestionControl_mixin
84606>>>>>    End_Procedure
84607>>>>>    
84607>>>>>    // Called when closing a suggestion form. With grids we must also make sure that the
84607>>>>>    // edit is canceled. 
84607>>>>>    Procedure CancelEditIfGrid
84609>>>>>        Send CancelEdit
84610>>>>>    End_Procedure
84611>>>>>    
84611>>>>>End_Class
84612>>>>>
84612>>>>>// A cDbCJGridColumnSuggestion would be dropped inside of cDbCJGrid.
84612>>>>>
84612>>>>>Class cDbCJGridColumnSuggestion is a cDbCJGridColumn
84613>>>>>    
84613>>>>>    Import_Class_Protocol cSuggestion_mixin            
84614>>>>>    
84614>>>>>    Procedure Construct_Object
84616>>>>>        Forward Send Construct_Object
84618>>>>>
84618>>>>>        Send Define_cSuggestion_mixin
84619>>>>>        Set phcEditClass to (RefClass(cDbCJGridColumnSuggestionEdit))
84620>>>>>    End_Procedure
84621>>>>>    
84621>>>>>End_Class
84622>>>
84622>>>Use Customer.DD
84622>>>Use Vendor.DD
84622>>>Use dfTabDlg.pkg
84622>>>
84622>>>
84622>>>Deferred_View Activate_oDemoSuggestionForm for ;Object oDemoSuggestionForm is a dbView
84647>>>
84647>>>    Set Border_Style to Border_Thick
84648>>>    Set Size to 227 300
84649>>>    Set Location to 2 2
84650>>>    Set Label to "Suggestion Forms and Grids"
84651>>>
84651>>>    Object oSuggestionsTP is a dbTabDialogView
84653>>>        Set Size to 208 284
84654>>>        Set Location to 10 7
84655>>>
84655>>>        Object oVendor_DD is a Vendor_DataDictionary
84657>>>        End_Object
84658>>>    
84658>>>        Object oCustomer_DD is a Customer_DataDictionary
84660>>>            Procedure Field_defaults
84663>>>                Forward Send Field_Defaults
84665>>>                Set Field_Changed_Value   Field Customer.State to ""
84666>>>            End_Procedure
84667>>>        End_Object
84668>>>    
84668>>>        Set Main_DD to oCustomer_DD
84669>>>        Set Server to oCustomer_DD
84670>>>
84670>>>        Object oSuggestionForms is a dbTabView
84672>>>            Set Label to 'dbSuggestionForm'
84673>>>
84673>>>            Object oLabel1 is a TextBox
84675>>>                Set Auto_Size_State to False
84676>>>                Set Size to 10 237
84677>>>                Set Location to 17 16
84678>>>                Set Label to "Data bound, incremental, starting at character 1"
84679>>>                Set FontWeight to fw_Bold
84680>>>            End_Object
84681>>>            Object oSuggestionForm2 is a dbSuggestionForm
84683>>>                Set Location to 28 74
84684>>>                Entry_Item Customer.Customer_Number
84685>>>                Set size to 14 45
84686>>>                Set Label to "Customer Num:"
84687>>>                Set piStartAtChar to 1
84688>>>            End_Object
84689>>>            Object oSuggestionForm1 is a dbSuggestionForm
84691>>>                Set Location to 44 74
84692>>>                Entry_Item Customer.Name
84693>>>                Set size to 14 146
84694>>>                Set Label to "Customer Name:"
84695>>>                Set piStartAtChar to 1
84696>>>            End_Object
84697>>>            Object oLabel3 is a TextBox
84699>>>                Set Auto_Size_State to False
84700>>>                Set Size to 9 211
84701>>>                Set Location to 77 17
84702>>>                Set Label to "Validation Table, incremental, starting at character 1"
84703>>>                Set FontWeight to fw_Bold
84704>>>            End_Object
84705>>>            Object oSuggestionForm4 is a dbSuggestionForm
84707>>>                Set Location to 89 74
84708>>>                Entry_Item Customer.State
84709>>>                Set Size to 14 50
84710>>>                Set Label to "Customer State:"
84711>>>                Set peSuggestionMode to smValidationTable
84712>>>                Set piStartAtChar to 1
84713>>>            End_Object
84714>>>            Object oLabel2 is a TextBox
84716>>>                Set Auto_Size_State to False
84717>>>                Set Size to 10 199
84718>>>                Set Location to 120 16
84719>>>                Set Label to "Data bound, full text, starting at character 2"
84720>>>                Set FontWeight to fw_Bold
84721>>>            End_Object
84722>>>            
84722>>>            Object oSuggestionForm3 is a dbSuggestionForm
84724>>>                Set Location to 137 74
84725>>>                Entry_Item Vendor.Name
84726>>>                Set Server to oVendor_DD
84727>>>                Set Size to 14 100
84728>>>                Set pbFullText to True
84729>>>                Set Label to "Vendor name:"
84730>>>            End_Object
84731>>>
84731>>>            Object oLabel3 is a TextBox
84733>>>                Set Auto_Size_State to False
84734>>>                Set Size to 10 199
84735>>>                Set Location to 158 16
84736>>>                Set Label to "Custom Suggestion List"
84737>>>                Set FontWeight to fw_Bold
84738>>>            End_Object
84739>>>            
84739>>>            // this shows how to create you own custom suggestion list
84739>>>            Object oSuggestionForm5 is a dbSuggestionForm
84741>>>                Set Location to 175 74
84742>>>                Set Label to "Custom Id:"
84743>>>                Set Size to 14 100
84744>>>                Set peSuggestionMode to smCustom
84745>>>                Set piStartAtChar to 1
84746>>>
84746>>>                // even though we handle searching manually in OnFindSuggestions, pbFullText
84746>>>                // is still used to determine the display and bolding of matched text. Setting
84746>>>                // this true tells it we are matching anywhere within the string.
84746>>>                // Since this is a custom list, it is the developer's job to make sure that
84746>>>                // OnFindSuggestions follows these rules as well.
84746>>>                Set pbFullText to True
84747>>>                
84747>>>                // augment to create an arbitrary list of Ids to be used for our search
84747>>>                Property String[] pCustomIds
84749>>>                
84749>>>                // augment to create a list of Ids
84749>>>                Procedure Activating
84752>>>                    String[] sIds
84753>>>                    Forward Send Activating
84755>>>                    Move "JSON" to sIds[0]
84756>>>                    Move "XML" to sIds[1]
84757>>>                    Move "SQL" to sIds[2]
84758>>>                    Move "SQLExpress" to sIds[3]
84759>>>                    Move "SQLServer" to sIds[4]
84760>>>                    Move "DF" to sIds[5]
84761>>>                    Move "XQuery" to sIds[6]
84762>>>                    Move "JScript" to sIds[7]
84763>>>                    Move "Java" to sIds[8]
84764>>>                    Move "UTF-8" to sIds[9]
84765>>>                    Move "UTF-16" to sIds[10]
84766>>>                    Set pCustomIds to (SortArray(sIds,Desktop,RefFunc(DFSTRICMP)))
84767>>>                End_Procedure
84768>>>                
84768>>>                // custom code to find all matches for the search
84768>>>                // You can write whatever code you want here to find matched items
84768>>>                Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
84771>>>                    String[] sIds
84772>>>                    Integer i iLen iIds iCount
84772>>>                    Move (Lowercase(sSearch)) to sSearch
84773>>>                    Move (Length(sSearch)) to iLen
84774>>>                    Get pCustomIds to sIds
84775>>>                    Move (SizeOfArray(sIds)-1) to iIds
84776>>>                    For i from 0 to iIds
84782>>>>
84782>>>                        If (Lowercase(sIds[i]) contains sSearch) Begin
84784>>>                            Move sIds[i] to aSuggestions[iCount].sRowId
84785>>>                            Move sIds[i] to aSuggestions[iCount].aValues[0]
84786>>>                            Increment iCount
84787>>>                        End
84787>>>>
84787>>>                    Loop
84788>>>>
84788>>>                End_Procedure
84789>>>
84789>>>                Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
84792>>>                    Set Value to Suggestion.sRowId
84793>>>                    Set Item_Changed_State to True
84794>>>                End_Procedure
84795>>>
84795>>>            
84795>>>            End_Object
84796>>>        End_Object
84797>>>
84797>>>        Object oSuggestionGrid is a dbTabView
84799>>>
84799>>>            Set Label to "cDbCJGridColumnSuggestion"
84800>>>
84800>>>            Object oCustomer_DD is a Customer_DataDictionary
84802>>>            End_Object
84803>>>        
84803>>>            Set Main_DD to oCustomer_DD
84804>>>            Set Server to oCustomer_DD
84805>>>        
84805>>>            Object oDbCJGrid1 is a cDbCJGrid
84807>>>                Set Size to 177 268
84808>>>                Set Location to 7 7
84809>>>                Set Ordering to 1
84810>>>                Set Verify_Save_msg to (RefFunc(Save_Confirmation))
84811>>>                
84811>>>                Object oCustomer_Customer_Number is a cDbCJGridColumnSuggestion
84813>>>                    Entry_Item Customer.Customer_Number
84814>>>                    Set piWidth to 73
84815>>>                    Set psCaption to "Number"
84816>>>                    Set piStartAtChar to 1
84817>>>                End_Object
84818>>>        
84818>>>                // normally you would not use a suggestion list with a grid's main 
84818>>>                // file. It would be more useful when selecting a parent.
84818>>>                Object oCustomer_Name is a cDbCJGridColumnSuggestion
84820>>>                    Entry_Item Customer.Name
84821>>>                    Set piWidth to 358
84822>>>                    Set psCaption to "Customer Name"
84823>>>                    Set pbFullText to True
84824>>>                    Set piStartAtChar to 1
84825>>>                End_Object
84826>>>        
84826>>>                Object oCustomer_State is a cDbCJGridColumnSuggestion
84828>>>                    Entry_Item Customer.State
84829>>>                    Set piWidth to 105
84830>>>                    Set psCaption to "State"
84831>>>                    Set peSuggestionMode to smValidationTable
84832>>>                    Set piStartAtChar to 1
84833>>>                End_Object
84834>>>            End_Object
84835>>>
84835>>>        End_Object
84836>>>        
84836>>>    End_Object
84837>>>        
84837>>>        
84837>>>Cd_End_Object
84839>>>>
84839>        Use DemoButtonTest.vw
Including file: DemoButtonTest.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\DemoButtonTest.vw)
84839>>>Use Windows.pkg
84839>>>Use DFClient.pkg
84839>>>Use cImageList32.pkg
84839>>>Use cSplitButton.pkg
Including file: cSplitButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cSplitButton.pkg)
84839>>>>>// cSplitButton class
84839>>>>>
84839>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84839>>>>>// older versions you will just get a regular button with no split part.
84839>>>>> 
84839>>>>>Use Windows.pkg
84839>>>>>
84839>>>>>Class cSplitButton is a Button
84840>>>>>
84840>>>>>    Procedure Page Integer iPageObject
84842>>>>>        Integer iStyle
84842>>>>>        Boolean bSupported
84842>>>>>        Get IsExControlSupported to bSupported
84843>>>>>        If (iPageObject=1  and bSupported) Begin
84845>>>>>            Get Form_Style iStyle to iStyle
84846>>>>>            Move (iStyle ior BS_SPLITBUTTON) to iStyle
84847>>>>>            Set Form_Style 0 to iStyle
84848>>>>>        End
84848>>>>>>
84848>>>>>        Forward Send Page iPageObject
84850>>>>>    End_Procedure
84851>>>>>    
84851>>>>>    Procedure Notify Integer wParam Integer lParam
84853>>>>>        tWinNmHdr Hdr
84853>>>>>        tWinNmHdr Hdr
84853>>>>>        Integer iVoid
84853>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to iVoid
84854>>>>>        If (Hdr.code=BCN_DROPDOWN) Begin
84856>>>>>            Send OnDropDown
84857>>>>>        End
84857>>>>>>
84857>>>>>        Else Begin
84858>>>>>            Forward Send Notify wParam lParam
84860>>>>>        End
84860>>>>>>
84860>>>>>    End_Procedure
84861>>>>>    
84861>>>>>End_Class
84862>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\cCommandLinkButton.pkg)
84862>>>>>// cCommandLinkButton class
84862>>>>>
84862>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
84862>>>>>// older versions you will just get a regular great big button.
84862>>>>> 
84862>>>>>Use Windows.pkg
84862>>>>>Use CharTranslate.pkg
84862>>>>>
84862>>>>>Class cCommandLinkButton is a Button
84863>>>>>
84863>>>>>        Procedure Construct_Object
84865>>>>>            Forward Send Construct_Object
84867>>>>>            Property String psPrivateNote
84868>>>>>        End_Procedure
84869>>>>>        
84869>>>>>        Procedure Set psNote String sNote
84871>>>>>            Boolean bSupported
84871>>>>>            Set psPrivateNote to sNote
84872>>>>>            Get IsExControlSupported to bSupported
84873>>>>>            If bSupported Begin
84875>>>>>                Send SetWinNote
84876>>>>>            End
84876>>>>>>
84876>>>>>        End_Procedure
84877>>>>>        
84877>>>>>        Procedure SetWinNote
84879>>>>>            String sNote
84879>>>>>            Handle hWnd
84879>>>>>            Integer i
84879>>>>>            Address aVar
84879>>>>>            Get Form_Window_Handle 0 to hWnd
84880>>>>>            If hWnd Begin
84882>>>>>                Get psNote to sNote
84883>>>>>                Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
84884>>>>>                Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
84885>>>>>                Move (Free(aVar)) to i 
84886>>>>>            End
84886>>>>>>
84886>>>>>        End_Procedure
84887>>>>>        
84887>>>>>        
84887>>>>>        Function psNote Returns String
84889>>>>>            Function_Return (psPrivateNote(Self))
84890>>>>>        End_Function
84891>>>>>        
84891>>>>>
84891>>>>>        Procedure Page Integer iState
84893>>>>>            Integer i hWnd
84893>>>>>            Boolean bSupported
84893>>>>>            Get IsExControlSupported to bSupported
84894>>>>>            If (iState=1 and bSupported) Begin
84896>>>>>                Get form_style i to i
84897>>>>>                Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
84898>>>>>                Forward Send Page iState
84900>>>>>                Send SetWinNote
84901>>>>>            End
84901>>>>>>
84901>>>>>            Else Begin
84902>>>>>                Forward Send Page iState
84904>>>>>            End
84904>>>>>>
84904>>>>>        End_Procedure        
84905>>>>>
84905>>>>>End_Class
84906>>>Use cCJStandardMenuItemClasses.pkg
84906>>>
84906>>>
84906>>>Deferred_View Activate_oButtonTest for ;Object oButtonTest is a dbView
84931>>>
84931>>>    Set Border_Style to Border_Thick
84932>>>    Set Size to 212 300
84933>>>    Set Location to 2 3
84934>>>    Set Label to "Button Samples"
84935>>>
84935>>>    Object oTextBox1 is a TextBox
84937>>>        Set Size to 9 110
84938>>>        Set Location to 8 10
84939>>>        Set Label to 'Buttons that use Text and Images'
84940>>>    End_Object
84941>>>
84941>>>    Object oTextButton is a Button
84943>>>        Set Location to 20 11
84944>>>        Set Label to 'Save'
84945>>>    
84945>>>        Procedure OnClick
84948>>>        End_Procedure
84949>>>    
84949>>>    End_Object
84950>>>
84950>>>    Object oTextAndImageButton is a Button
84952>>>        Set Location to 20 71
84953>>>        Set Label to 'Save'
84954>>>        Set psImage to "ActionSave.ico"
84955>>>
84955>>>        Procedure OnClick
84958>>>        End_Procedure
84959>>>    
84959>>>    End_Object
84960>>>
84960>>>    Object oImageButton is a Button
84962>>>        Set Size to 14 27
84963>>>        Set Location to 20 131
84964>>>        Set psImage to "ActionSave.ico"
84965>>>        Set peImageAlign to Button_ImageList_Align_Center
84966>>>
84966>>>        Procedure OnClick
84969>>>        End_Procedure
84970>>>    
84970>>>    End_Object
84971>>>
84971>>>    Object oTextAndImageTopButton is a Button
84973>>>        Set Size to 26 50
84974>>>        Set Location to 20 168
84975>>>        Set Label to 'Save'
84976>>>        Set psImage to "ActionSave.ico"
84977>>>        Set peImageAlign to Button_ImageList_Align_Top
84978>>>        Set piImageMarginTop to 10
84979>>>
84979>>>        Procedure OnClick
84982>>>        End_Procedure
84983>>>    
84983>>>    End_Object
84984>>>
84984>>>    Object oTextAndImageBottomButton is a Button
84986>>>        Set Size to 26 50
84987>>>        Set Location to 20 226
84988>>>        Set Label to 'Save'
84989>>>        Set psImage to "ActionSave.ico"
84990>>>        Set peImageAlign to Button_ImageList_Align_Bottom
84991>>>        Set piImageMarginBottom to 10
84992>>>
84992>>>        Procedure OnClick
84995>>>        End_Procedure
84996>>>    
84996>>>    End_Object
84997>>>
84997>>>    Object oTextBox1 is a TextBox
84999>>>        Set Size to 9 110
85000>>>        Set Location to 51 10
85001>>>        Set Label to 'Buttons with drop down menus'
85002>>>    End_Object
85003>>>
85003>>>    // this is a button with down arrow button on the right that invokes
85003>>>    // a context menu inside of OnClick
85003>>>    Object oDropDownButton is a Button
85005>>>        Set Size to 14 58
85006>>>        Set Location to 65 10
85007>>>        Set Label to "Select"
85008>>>        Set psImage to "Down16.bmp"
85009>>>        Set peImageAlign to Button_ImageList_Align_Right
85010>>>
85010>>>        Procedure OnClick
85013>>>            // OnDropDown is defined to popup menu in phoButtonPopup
85013>>>            Send OnDropDown
85014>>>        End_Procedure
85015>>>        
85015>>>        Object oButtonMenu is a cCJContextMenu
85017>>>            
85017>>>            Object oMenuItem1 is a cCJMenuItem
85019>>>                Set psCaption to "Save"
85020>>>                Set psImage to "ActionSaveRecord.ico"
85021>>>                Procedure OnExecute Variant vCommandBarControl
85024>>>                End_Procedure
85025>>>            End_Object
85026>>>            
85026>>>            Object oMenuItem2 is a cCJMenuItem
85028>>>                Set psCaption to "Clear"
85029>>>                Set psImage to "ActionClear.ico"
85030>>>                Procedure OnExecute Variant vCommandBarControl
85033>>>                End_Procedure
85034>>>            End_Object
85035>>>            
85035>>>            Object oMenuItem3 is a cCJMenuItem
85037>>>                Set psCaption to "Delete"
85038>>>                Set psImage to "ActionDeleteRecord.ico"
85039>>>                Procedure OnExecute Variant vCommandBarControl
85042>>>                End_Procedure
85043>>>            End_Object
85044>>>
85044>>>        End_Object
85045>>>        // Binds OnDropDown to this menu
85045>>>        Set phoButtonPopup to oButtonMenu 
85046>>>
85046>>>    End_Object
85047>>>
85047>>>    // this is split button (Vista or greater required), where OnClick and
85047>>>    // OnDropDown are two events. OnDropDown automatically invokes phoButtonPopup
85047>>>    
85047>>>    Object oSplitButton is a cSplitButton
85049>>>        Set Size to 14 53
85050>>>        Set Location to 65 76
85051>>>        Set Label to 'Save'
85052>>>        Set psImage to "ActionSaveRecord.ico"
85053>>>    
85053>>>        Procedure OnClick
85056>>>        End_Procedure
85057>>>        
85057>>>        Object oButtonMenu is a cCJContextMenu
85059>>>            
85059>>>            Object oMenuItem1 is a cCJMenuItem
85061>>>                Set psCaption to "Set to Save"
85062>>>                Procedure OnExecute Variant vCommandBarControl
85065>>>                    Delegate Set label to "Save"
85067>>>                    Delegate Set psImage to "ActionSaveRecord.ico"
85069>>>                End_Procedure
85070>>>            End_Object
85071>>>            
85071>>>            Object oMenuItem2 is a cCJMenuItem
85073>>>                Set psCaption to "Set to Clear"
85074>>>                Procedure OnExecute Variant vCommandBarControl
85077>>>                    Delegate Set label  to "Clear"
85079>>>                    Delegate Set psImage to  "ActionClear.ico"
85081>>>                End_Procedure
85082>>>            End_Object
85083>>>            
85083>>>            Object oMenuItem3 is a cCJMenuItem
85085>>>                Set psCaption to "Set to Delete"
85086>>>                Procedure OnExecute Variant vCommandBarControl
85089>>>                    Delegate Set label  to "Delete"
85091>>>                    Delegate Set psImage to  "ActionDeleteRecord.ico"
85093>>>                End_Procedure
85094>>>            End_Object
85095>>>
85095>>>            Object oMenuItem4 is a cCJMenuItem
85097>>>                Set psCaption to "Set to Select"
85098>>>                Procedure OnExecute Variant vCommandBarControl
85101>>>                    Delegate Set label  to "Select"
85103>>>                    Delegate Set psImage to  ""
85105>>>                End_Procedure
85106>>>            End_Object
85107>>>
85107>>>        End_Object
85108>>>
85108>>>        Set phoButtonPopup to oButtonMenu 
85109>>>
85109>>>    End_Object
85110>>>
85110>>>    Object oTextBox2 is a TextBox
85112>>>        Set Size to 9 115
85113>>>        Set Location to 51 166
85114>>>        Set Label to "Button using an external image list"
85115>>>    End_Object
85116>>>    
85116>>>    // button have 6 image states. We will provide a different image
85116>>>    // for each of these states
85116>>>    Object oImageList is a cImageList32
85118>>>        Set piMaxImages to 6
85119>>>        Set piImageHeight to 16
85120>>>        Set piImageWidth to 16
85121>>>        Procedure OnCreate
85124>>>            Integer iIndex
85124>>>            // for buttons either create 1 image or 6
85124>>>            // if 6, they are normal, hot, pressed, disabled, defaulted, stylus-hot
85124>>>            Get AddImage "ClosFold.bmp" to iIndex
85125>>>            Get AddImage "OpenFold.bmp" to iIndex
85126>>>            Get AddImage "OpenFold.bmp" to iIndex
85127>>>            Get AddImage "ClosFold.bmp" to iIndex
85128>>>            Get AddImage "OpenFold.bmp" to iIndex
85129>>>            Get AddImage "ClosFold.bmp" to iIndex
85130>>>        End_Procedure
85131>>>    End_Object
85132>>>
85132>>>    // this attaches to an external imageist with 6 images. Because this
85132>>>    // uses an external imagelist you will not see the image modeled in the Studio
85132>>>    Object oMultiImageButton is a Button
85134>>>        Set Location to 65 194
85135>>>        Set phoExternalButtonImageList to oImageList
85136>>>        Set peImageAlign to Button_ImageList_Align_Center
85137>>>        
85137>>>        Procedure OnClick
85140>>>        End_Procedure
85141>>>
85141>>>    End_Object
85142>>>
85142>>>    // CommandLinkButtons work with Vista or greater required
85142>>>    Object oCommandLinkButtonGroup is a Group
85144>>>        Set Size to 115 258
85145>>>        Set Location to 90 10
85146>>>        Set Label to "CommandLink Buttons"
85147>>>
85147>>>        Object oCommandLinkStandard is a cCommandLinkButton
85149>>>            Set Location to 11 9
85150>>>            Set Size to 34 239
85151>>>            Set Label to 'CommandLink Choice 1'
85152>>>            Set psNote to "This is a normal command link button with the standard command link image"
85153>>>    
85153>>>            Procedure OnClick
85156>>>            End_Procedure
85157>>>            
85157>>>        End_Object
85158>>>
85158>>>        Object oCommandLinkShield is a cCommandLinkButton
85160>>>            Set Location to 44 9
85161>>>            Set Size to 34 239
85162>>>            Set Label to 'CommandLink Choice 2'
85163>>>            Set psNote to "This is a command link button using the Windows elevated shield image"
85164>>>            Set pbShield to True
85165>>>    
85165>>>            Procedure OnClick
85168>>>            End_Procedure
85169>>>            
85169>>>        End_Object
85170>>>
85170>>>        Object oCommandLinkCustom is a cCommandLinkButton
85172>>>            Set Location to 78 9
85173>>>            Set Size to 34 239
85174>>>            Set Label to 'CommandLink Choice 3'
85175>>>            Set psNote to "This is a command link with a custom image. This image just happens to be larger"
85176>>>            Set psImage to "DF32.bmp"
85177>>>            Set piImageSize to 48
85178>>>
85178>>>            Procedure OnClick
85181>>>            End_Procedure
85182>>>            
85182>>>        End_Object
85183>>>
85183>>>    End_Object
85184>>>
85184>>>
85184>>>Cd_End_Object
85186>>>>
85186>              Use DemoCalendarControl.vw
Including file: DemoCalendarControl.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\DemoCalendarControl.vw)
85186>>>Use Windows.pkg
85186>>>Use DFClient.pkg
85186>>>
85186>>>Use MonthCalendarPrompt.dg
85186>>>Use cTextEdit.pkg
85186>>>
85186>>>Activate_View Activate_oDemoCalendarControl for oDemoCalendarControl
85196>>>>
85196>>>Object oDemoCalendarControl is a dbView
85198>>>
85198>>>    Set Border_Style to Border_Thick
85199>>>    Set Size to 148 196
85200>>>    Set Location to 2 2
85201>>>    Set Label to "Calendar Control Sample"
85202>>>
85202>>>    // Simplest case example, just set the prompt_object
85202>>>    Object oDateFormTest is a Form
85204>>>        Set Location to 16 89
85205>>>        Set Size to 13 66
85206>>>        Set Label to "Date Select Test:"
85207>>>
85207>>>        Set Prompt_Object to oMonthCalendarPrompt
85208>>>        Set Prompt_Button_Mode to PB_PromptOn
85209>>>
85209>>>    End_Object
85210>>>
85210>>>    Object oDateRangeGroup is a Group
85212>>>
85212>>>        Set Label to "Selecting Date Range"
85213>>>        Set Size to 74 165
85214>>>        Set Location to 39 23
85215>>>        
85215>>>        Object oFromDate is a Form
85217>>>            Set Label to "From:"
85218>>>            Set Location to 29 66
85219>>>            Set Size to 13 66
85220>>>            Set Prompt_Button_Mode to PB_PromptOn
85221>>>            Set Prompt_Object to oMonthCalendarPrompt
85222>>>            
85222>>>            Procedure Prompt_Callback Integer hoPrompt
85225>>>                Send DateRangeCallback hoPrompt
85226>>>            End_Procedure
85227>>>        End_Object
85228>>>        
85228>>>        Object oToDate is a Form
85230>>>            Set Label to "To:"
85231>>>            Set Location to 50 66
85232>>>            Set Size to 13 66
85233>>>            Set Prompt_Button_Mode to PB_PromptOn
85234>>>            
85234>>>            Procedure Prompt
85237>>>                Send Popup to oMonthCalendarPrompt
85238>>>            End_Procedure
85239>>>            
85239>>>            Procedure Prompt_Callback Integer hoPrompt
85242>>>                Send DateRangeCallback hoPrompt
85243>>>            End_Procedure
85244>>>        End_Object
85245>>>
85245>>>              Object oTextBox1 is a TextBox
85247>>>                        Set Size to 10 154
85248>>>                        Set Location to 11 3
85249>>>                        Set Label to "(select initial date and drag the mouse to end date)"
85250>>>              End_Object
85251>>>        
85251>>>        
85251>>>        // Since these two date forms are using the same logic, we delegate to here
85251>>>        // and let the group handle the inititalization and update
85251>>>        
85251>>>        // this is the callback set in DateRangeCallback
85251>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85254>>>            Set Value of oFromDate to dDate1
85255>>>            Set Value of oToDate to dDate2
85256>>>        End_Procedure
85257>>>        
85257>>>        // This is the first callback. Make this multi-select, 
85257>>>        // no click select, show week numbers, don't show today stuff.   
85257>>>        // also set the callback to call DoDateUpdate (which will delegate to here)
85257>>>        Procedure DateRangeCallback Integer hoPrompt
85260>>>            Date dDate1 dDate2
85260>>>            
85260>>>            Set pbMultiSelect of hoPrompt to True
85261>>>            Set peMouseSelectOk of hoPrompt to msoNone
85262>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85263>>>            
85263>>>            Set pbWeekNumbers of hoPrompt to True
85264>>>            Set pbNoToday of hoPrompt to True
85265>>>            Set pbNoTodayCircle of hoPrompt to True
85266>>>            
85266>>>            Get Value of oFromDate to dDate1
85267>>>            Get Value of oToDate to dDate2
85268>>>            Set pdSeedValue of hoPrompt to dDate1 
85269>>>            Set pdSeedValue2 of hoPrompt to dDate2 
85270>>>        End_Procedure
85271>>>    End_Object
85272>>>
85272>>>    Object oDateTextBox is a TextBox
85274>>>        Set Size to 10 34
85275>>>        Set Location to 123 56
85276>>>        Set Label to '1/30/2016'
85277>>>        Procedure Activating 
85280>>>            Set Label to (Date(CurrentDateTime()))
85281>>>            Forward Send Activating
85283>>>        End_Procedure
85284>>>    End_Object
85285>>>
85285>>>    Object oButton1 is a Button
85287>>>        Set Location to 121 100
85288>>>        Set Label to 'Change'
85289>>>        
85289>>>        Procedure Prompt_Callback Integer hoPrompt
85292>>>            Date dDate
85292>>>            Get Value of oDateTextBox to dDate
85293>>>            Set peUpdateMode of hoPrompt to umPromptCustom
85294>>>            Set pdSeedValue of hoPrompt to dDate
85295>>>            Set phmPromptUpdateCallback of hoPrompt to (RefProc(DoDateUpdate))
85296>>>        End_Procedure
85297>>>
85297>>>        Procedure DoDateUpdate Integer hoSel Date dDate1 Date dDate2
85300>>>            Set Value of oDateTextBox to dDate1
85301>>>        End_Procedure
85302>>>    
85302>>>        Procedure OnClick
85305>>>            Send Popup of oMonthCalendarPrompt
85306>>>        End_Procedure
85307>>>    
85307>>>    End_Object
85308>>>    
85308>>>End_Object
85309>        Use DemoParentCombos.vw
Including file: DemoParentCombos.vw    (A:\Dropbox\Git_Bit\bagunca_aprendendo\visualdataflex\Order Entry\AppSrc\DemoParentCombos.vw)
85309>>>Use dfClient.pkg
85309>>>Use DataDict.pkg
85309>>>Use dfEntry.pkg
85309>>>Use dfSpnEnt.pkg
85309>>>Use dfCEntry.pkg
85309>>>Use dfTable.pkg
85309>>>Use Windows.pkg
85309>>>Use Vendor.DD
85309>>>Use Invt.DD
85309>>>Use Customer.DD
85309>>>Use SalesP.DD
85309>>>Use OrderHea.DD
85309>>>Use OrderDtl.DD
85309>>>Use cDbCJGrid.pkg
85309>>>Use cCJGridColumnRowIndicator.pkg
85309>>>Use DbParentCombo.pkg
Including file: dbParentCombo.pkg    (C:\Program Files (x86)\DataFlex 18.2\Pkg\dbParentCombo.pkg)
85309>>>>>Use Dfcentry.pkg
85309>>>>>
85309>>>>>// Combo for parents. 
85309>>>>>Class dbParentCombo is a dbComboForm
85310>>>>>    Procedure Construct_Object
85312>>>>>        Forward Send Construct_Object
85314>>>>>        
85314>>>>>        // Show a psEmptyItemDescription. If Entry_State is false, you probably
85314>>>>>        // want this false as well
85314>>>>>        Property Boolean pbAddEmptyItem True        
85315>>>>>        Property String psEmptyItemDescription DD_BLANK_CODE_DESCRIPTION
85316>>>>>        
85316>>>>>        // if true, the list is refilled each time the combo takes the focus
85316>>>>>        // making it more dynamic. You can manually refill a list sending ComboRefill
85316>>>>>        Property Boolean pbRefillOnFocus False
85317>>>>>        
85317>>>>>        // object maintained. If it detects that the list does not contain a parent it
85317>>>>>        // will set this true to force a refill on the next focus 
85317>>>>>        Property Boolean pbNeedsRefill False
85318>>>>>        
85318>>>>>        // make sure these properties are what we want
85318>>>>>        Set Code_Display_Mode to CB_Code_Display_Description
85319>>>>>        Set Undefined_Display_Mode to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85320>>>>>        Set Undefined_Save_Mode    to CB_ERR_UPDATE_WINDOW_VALUE // don't change
85321>>>>>        
85321>>>>>        // in general this will work best with a non-editable combo
85321>>>>>        // but the other style works as well
85321>>>>>        Set Entry_State 0 to False
85322>>>>>        // its ok to change this - when default it displays in Combo_Index order
85322>>>>>        Set Combo_Sort_State to True
85323>>>>>    End_Procedure
85324>>>>>    
85324>>>>>    // augment to fill list when paged (instead of doing earlier)
85324>>>>>    Procedure Page_Object Boolean bPage
85326>>>>>        If bPage Begin
85328>>>>>            Send ComboRefill
85329>>>>>        End
85329>>>>>>
85329>>>>>        Forward Send Page_Object bPage
85331>>>>>    End_Procedure
85332>>>>>
85332>>>>>    
85332>>>>>    // Augmentation to handle optional combo refill on set focus
85332>>>>>    Procedure Notify_Focus_Change Integer Fg
85334>>>>>        Boolean bReFillOnFocus bNeedsRefill
85334>>>>>        Forward Send Notify_Focus_Change Fg
85336>>>>>        If Fg Begin
85338>>>>>            Get pbNeedsRefill to bNeedsRefill
85339>>>>>            Get pbRefillOnFocus to bReFillOnFocus
85340>>>>>            If (bRefillOnFocus or bNeedsRefill) Begin
85342>>>>>                Send ComboRefill
85343>>>>>            End
85343>>>>>>
85343>>>>>        End
85343>>>>>>
85343>>>>>    End_Procedure
85344>>>>>    
85344>>>>>    // Refill combo list, while maintaining current value
85344>>>>>    Procedure ComboRefill
85346>>>>>        String sValue
85346>>>>>        Set Deferred_State to True
85347>>>>>        Get Value 0 to sValue
85348>>>>>        Send Combo_Fill_List
85349>>>>>        Set Deferred_State to False
85350>>>>>        Set Combo_data_object to (Combo_Data_Object(Self))
85351>>>>>        Set Local_Value 0 to sValue
85352>>>>>    End_Procedure
85353>>>>>    
85353>>>>>    // Augment to  init and fill the list with all parents.
85353>>>>>    Procedure Combo_Fill_List
85355>>>>>        Handle hoServer hoDD
85355>>>>>        Integer iFile iField iIndex
85355>>>>>        String sDescription sData
85355>>>>>        Boolean bAddEmptyItem
85355>>>>>        Boolean bOldRelate bNeedsRelate
85355>>>>>        RowID riID
85355>>>>>        
85355>>>>>        Get Server to hoServer
85356>>>>>        Get Data_File to iFile
85357>>>>>        Get Data_Field to iField
85358>>>>>        Get Combo_Index to iIndex
85359>>>>>        Get pbAddEmptyItem to bAddEmptyItem
85360>>>>>        Send Combo_Delete_Data
85361>>>>>        
85361>>>>>        If (hoServer and iFile) Begin
85363>>>>>    
85363>>>>>            Get Data_Set of hoServer iFile to hoDD
85364>>>>>            
85364>>>>>            If (hoDD) Begin
85366>>>>>                Set Relational_State to True
85367>>>>>                If (bAddEmptyItem) Begin
85369>>>>>                    Get psEmptyItemDescription to sDescription
85370>>>>>                    Send Combo_Add_Blank_Item sDescription
85371>>>>>                    Set Data_Only_State to True // this got cleared - we don't care about dummy item
85372>>>>>                End
85372>>>>>>
85372>>>>>                
85372>>>>>                If (iIndex <= 0) Begin
85374>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
85377>>>>>                End
85377>>>>>>
85377>>>>>                // optimize relates. Only do it if needed
85377>>>>>                Get No_Relate_State of hoDD to bOldRelate
85378>>>>>                Get DDOConstraintNeedsRelate of hoDD iIndex to bNeedsRelate
85379>>>>>                Set No_Relate_State of hoDD to (not(bNeedsRelate))
85380>>>>>                Send Request_Read of hoDD FIRST_RECORD iFile iIndex
85381>>>>>                While (Found)
85385>>>>>                    Send AddParentItemFromRecord  
85386>>>>>                    Send Locate_Next of hoDD
85387>>>>>                 Loop
85388>>>>>>
85388>>>>>                Set No_Relate_State of hoDD to bOldRelate
85389>>>>>            End
85389>>>>>>
85389>>>>>        End
85389>>>>>>
85389>>>>>        If (not(hoDD)) Begin
85391>>>>>            Error DFERR_PROGRAM "Invalid use of DbParentCombo"            
85392>>>>>>
85392>>>>>        End
85392>>>>>>
85392>>>>>        Set pbNeedsRefill to False
85393>>>>>    End_Procedure
85394>>>>>    
85394>>>>>    Procedure AddParentItemFromRecord
85396>>>>>        Integer iFile iField iItems
85396>>>>>        String sData sDescription
85396>>>>>        RowID riID
85396>>>>>        
85396>>>>>        Get Data_File to iFile
85397>>>>>        Get Data_Field to iField
85398>>>>>        Move (GetRowID(iFile)) to riID
85399>>>>>        Get_Field_Value iFile iField to sData
85402>>>>>        Move (Trim(sData)) to sData 
85403>>>>>        Move sData to sDescription
85404>>>>>        // user hook to customize the combo description
85404>>>>>        Send OnDefineDescription (&sDescription)
85405>>>>>        Get Combo_Item_Count to iItems
85406>>>>>        Send ComboFillItem iItems sData sDescription iFile riID
85407>>>>>        Increment iItems
85408>>>>>    End_Procedure
85409>>>>>    
85409>>>>>    // Hook to customize a combo item's description.
85409>>>>>    Procedure OnDefineDescription String ByRef sDescription
85411>>>>>    End_Procedure
85412>>>>>    
85412>>>>>    // augment to test that we found a match and if not add it to the list
85412>>>>>    Procedure Display_Description String DataVal
85414>>>>>        String sValue
85414>>>>>        Integer iItem
85414>>>>>        Move (Trim(DataVal)) to DataVal // must be trimmed for Combo_Item_Matching below
85415>>>>>        Get Data_to_Description DataVal to sValue
85416>>>>>        // Test that the combo item exists. We assume that a missing combo item means the list is out of date.
85416>>>>>        // If so, add the missing item and mark that we probably need to do a refill next chance we get.
85416>>>>>        If (DataVal<>"") Begin
85418>>>>>            Get Combo_Item_Matching sValue to iItem
85419>>>>>            If (iItem=-1) Begin
85421>>>>>                Send AddParentItemFromRecord
85422>>>>>                Set pbNeedsRefill to True
85423>>>>>                // now it should work
85423>>>>>                Get Data_to_Description DataVal to sValue
85424>>>>>            End
85424>>>>>>
85424>>>>>        End
85424>>>>>>
85424>>>>>        Set Value item 0 to sValue
85425>>>>>    End_Procedure
85426>>>>>    
85426>>>>>    // cancel so the list is not built upon attach to DDO. Attach upon activation
85426>>>>>    Procedure combo_initialize_list
85428>>>>>    End_Procedure
85429>>>>>    
85429>>>>>    
85429>>>>>End_Class
85430>>>Use MonthCalendarPrompt.dg
85430>>>
85430>>>Activate_View Activate_oDemoParentCombos for oDemoParentCombos
85440>>>>
85440>>>Object oDemoParentCombos is a dbView
85442>>>    Set Border_Style to Border_Thick
85443>>>    Set Maximize_Icon to True
85444>>>    Set Label to "Parent Combo Demo"
85445>>>    Set Location to 2 3
85446>>>    Set Size to 174 383
85447>>>    Set piMinSize to 174 383
85448>>>    
85448>>>
85448>>>    Object Vendor_DD is a Vendor_DataDictionary
85450>>>    End_Object    // Vendor_DD
85451>>>
85451>>>    Object Invt_DD is a Invt_DataDictionary
85453>>>        Set DDO_Server to Vendor_DD
85454>>>    End_Object    // Invt_DD
85455>>>
85455>>>    Object Customer_DD is a Customer_DataDictionary
85457>>>    End_Object    // Customer_DD
85458>>>
85458>>>    Object SalesP_DD is a Salesp_DataDictionary
85460>>>    End_Object    // SalesP_DD
85461>>>
85461>>>    Object OrderHea_DD is a OrderHea_DataDictionary
85463>>>        Set DDO_Server to Customer_DD
85464>>>        Set DDO_Server to SalesP_DD
85465>>>        
85465>>>        // this lets you save a new OrderHea from within OrderDtl.
85465>>>        Set Allow_Foreign_New_Save_State to True
85466>>>        
85466>>>    End_Object    // OrderHea_DD
85467>>>    
85467>>>    Object OrderDtl_DD is a OrderDtl_DataDictionary
85469>>>        Set DDO_Server to OrderHea_DD
85470>>>        Set DDO_Server to Invt_DD
85471>>>        Set Constrain_File to OrderHea.File_Number
85472>>>    End_Object    // OrderDtl_DD
85473>>>
85473>>>    Set Main_DD to OrderHea_DD
85474>>>    Set Server to OrderHea_DD
85475>>>    
85475>>>    Object oDbContainer3d1 is a dbContainer3d
85477>>>        Set Size to 85 377
85478>>>        Set Location to 2 3
85479>>>        Set peAnchors to anTopLeftRight
85480>>>        
85480>>>        
85480>>>        Object oOrderHea_Order_Number is a dbForm
85482>>>            Entry_Item OrderHea.Order_Number
85483>>>            Set Label to "Order Number:"
85484>>>            Set Size to 13 42
85485>>>            Set Location to 4 63
85486>>>            Set peAnchors to anTopLeft
85487>>>            Set Label_Col_Offset to 2
85488>>>            Set Label_Justification_Mode to jMode_Right
85489>>>            
85489>>>        End_Object    // oOrderHea_Order_Number
85490>>>
85490>>>        Object oOrderHea_Customer_Number is a DbParentCombo
85492>>>            Entry_Item Customer.Customer_Number
85493>>>            Set Label to "Customer Number:"
85494>>>            Set Size to 13 42
85495>>>            Set Location to 4 201
85496>>>            Set peAnchors to anTopRight
85497>>>            Set Label_Col_Offset to 2
85498>>>            Set Label_Justification_Mode to jMode_Right
85499>>>            Set psEmptyItemDescription to "???"
85500>>>            // with numbers, not sorting may be preferred
85500>>>            Set Combo_Sort_State to False
85501>>>            // anytime this takes the focus, refill the combo. If the list is very
85501>>>            // large you may not want this. However, if the list is very large you
85501>>>            // may not want parent combos.
85501>>>            Set pbRefillOnFocus to True
85502>>>        End_Object
85503>>>
85503>>>        Object oOrderHea_Order_Date is a dbForm
85505>>>            Entry_Item OrderHea.Order_Date
85506>>>            Set Label to "Order Date:"
85507>>>            Set Size to 13 67
85508>>>            Set Location to 4 299
85509>>>            Set peAnchors to anTopRight
85510>>>            Set Label_Col_Offset to 2
85511>>>            Set Label_Justification_Mode to jMode_Right
85512>>>            
85512>>>            Set Prompt_Object to oMonthCalendarPrompt
85513>>>            Set Prompt_Button_Mode to PB_PromptOn
85514>>>        End_Object    // oOrderHea_Order_Date
85515>>>
85515>>>        Object oCustomer_Name is a dbForm
85517>>>            Entry_Item Customer.Name
85518>>>            Set Label to "Customer Name:"
85519>>>            Set Size to 13 180
85520>>>            Set Location to 18 63
85521>>>            Set peAnchors to anTopLeftRight
85522>>>            Set Label_Col_Offset to 2
85523>>>            Set Label_Justification_Mode to jMode_Right
85524>>>        End_Object    // oCustomer_Name
85525>>>
85525>>>        Object oCustomer_Address is a dbForm
85527>>>            Entry_Item Customer.Address
85528>>>            Set Label to "Street Address:"
85529>>>            Set Size to 13 180
85530>>>            Set Location to 34 63
85531>>>            Set peAnchors to anTopLeftRight
85532>>>            Set Label_Col_Offset to 2
85533>>>            Set Label_Justification_Mode to jMode_Right
85534>>>        End_Object    // oCustomer_Address
85535>>>
85535>>>        Object oCustomer_City is a dbForm
85537>>>            Entry_Item Customer.City
85538>>>            Set Label to "City/State/Zip:"
85539>>>            Set Size to 13 84
85540>>>            Set Location to 49 63
85541>>>            Set peAnchors to anTopLeftRight
85542>>>            Set Label_Col_Offset to 2
85543>>>            Set Label_Justification_Mode to jMode_Right
85544>>>        End_Object    // oCustomer_City
85545>>>
85545>>>        Object oCustomer_State is a dbForm
85547>>>            Entry_Item Customer.State
85548>>>            Set Size to 13 20
85549>>>            Set Location to 49 155
85550>>>            Set peAnchors to anTopRight
85551>>>        End_Object    // oCustomer_State
85552>>>
85552>>>        Object oCustomer_Zip is a dbForm
85554>>>            Entry_Item Customer.Zip
85555>>>            Set Size to 13 60
85556>>>            Set Location to 49 183
85557>>>            Set peAnchors to anTopRight
85558>>>        End_Object    // oCustomer_Zip
85559>>>
85559>>>        Object oOrderHea_Ordered_By is a dbForm
85561>>>            Entry_Item OrderHea.Ordered_By
85562>>>            Set Label to "Ordered By:"
85563>>>            Set Size to 13 67
85564>>>            Set Location to 34 299
85565>>>            Set peAnchors to anTopRight
85566>>>            Set Label_Col_Offset to 2
85567>>>            Set Label_Justification_Mode to jMode_Right
85568>>>        End_Object    // oOrderHea_Ordered_By
85569>>>
85569>>>        Object oOrderHea_Salesperson_ID is a DbParentCombo
85571>>>            Entry_Item Salesp.Id
85572>>>            Set Label to "Sold by:"
85573>>>            Set Size to 11 90
85574>>>            Set Location to 49 276
85575>>>            Set peAnchors to anTopRight
85576>>>            Set Label_Col_Offset to 2
85577>>>            Set Label_Justification_Mode to jMode_Right
85578>>>            Set psEmptyItemDescription to "<none>"
85579>>>            
85579>>>            Procedure OnDefineDescription String ByRef sDescription
85582>>>                Move (trim(Salesp.ID) + " - " * SalesP.Name) to sDescription
85583>>>            End_Procedure
85584>>>        End_Object    // oOrderHea_Salesperson_ID
85585>>>
85585>>>        Object oOrderHea_Terms is a dbComboForm
85587>>>            Entry_Item OrderHea.Terms
85588>>>            Set Label to "Terms:"
85589>>>            Set Size to 13 85
85590>>>            Set Location to 64 63
85591>>>            Set peAnchors to anTopLeft
85592>>>            Set Form_Border to 0
85593>>>            Set Label_Col_Offset to 2
85594>>>            Set Label_Justification_Mode to jMode_Right
85595>>>            Set Entry_State to False
85596>>>
85596>>>        End_Object    // oOrderHea_Terms
85597>>>
85597>>>        Object oOrderHea_Ship_Via is a dbComboForm
85599>>>            Entry_Item OrderHea.Ship_Via
85600>>>            Set Label to "Ship Via:"
85601>>>            Set Size to 13 103
85602>>>            Set Location to 64 183
85603>>>            Set peAnchors to anTopRight
85604>>>            Set Form_Border to 0
85605>>>            Set Label_Col_Offset to 2
85606>>>            Set Label_Justification_Mode to jMode_Right
85607>>>            Set Entry_State to False
85608>>>            
85608>>>
85608>>>        End_Object    // oOrderHea_Ship_Via
85609>>>
85609>>>    End_Object    // oDbContainer3d1
85610>>>
85610>>>    Object oOrderDtl_Grid is a cDbCJGrid
85612>>>        Set Server to OrderDtl_DD
85613>>>        Set Ordering to 1
85614>>>        Set Size to 63 377
85615>>>        Set Location to 90 3
85616>>>        Set peAnchors to anAll
85617>>>        Set pbAllowInsertRow to False
85618>>>        Set pbRestoreLayout to False
85619>>>        Set psLayoutSection to "OrderView_oOrderDtl_Grid2"
85620>>>        Set piLayoutBuild to 6
85621>>>        Set pbHeaderPrompts to True
85622>>>
85622>>>        On_Key Key_F11 Send Request_InsertRow
85623>>>
85623>>>        Object oMark is a cCJGridColumnRowIndicator
85625>>>        End_Object
85626>>>        
85626>>>        Object oInvt_Item_ID is a cDbCJGridColumn
85628>>>            Entry_Item Invt.Item_ID
85629>>>            Set piWidth to 91
85630>>>            Set psCaption to "Item ID"
85631>>>            Set psImage to "ActionPrompt.ico"
85632>>>        End_Object
85633>>>
85633>>>        Object oInvt_Description is a cDbCJGridColumn
85635>>>            Entry_Item Invt.Description
85636>>>            Set piWidth to 213
85637>>>            Set psCaption to "Description"
85638>>>        End_Object
85639>>>
85639>>>        Object oInvt_Unit_Price is a cDbCJGridColumn
85641>>>            Entry_Item Invt.Unit_Price
85642>>>            Set piWidth to 53
85643>>>            Set psCaption to "Unit Price"
85644>>>        End_Object
85645>>>
85645>>>        Object oOrderDtl_Qty_Ordered is a cDbCJGridColumn
85647>>>            Entry_Item OrderDtl.Qty_Ordered
85648>>>            Set piWidth to 50
85649>>>            Set psCaption to "Quantity"
85650>>>        End_Object
85651>>>
85651>>>        Object oOrderDtl_Price is a cDbCJGridColumn
85653>>>            Entry_Item OrderDtl.Price
85654>>>            Set piWidth to 62
85655>>>            Set psCaption to "Price"
85656>>>        End_Object
85657>>>
85657>>>        Object oOrderDtl_Extended_Price is a cDbCJGridColumn
85659>>>            Entry_Item OrderDtl.Extended_Price
85660>>>            Set piWidth to 81
85661>>>            Set psCaption to "Total"
85662>>>        End_Object
85663>>>        
85663>>>    End_Object    // oOrderDtl_Grid
85664>>>
85664>>>    Object oOrderHea_Order_Total is a dbForm
85666>>>        Entry_Item OrderHea.Order_Total
85667>>>        Set Label to "Order Total:"
85668>>>        Set Size to 13 60
85669>>>        Set Location to 156 307
85670>>>        Set peAnchors to anBottomRight
85671>>>        Set Label_Col_Offset to 3
85672>>>        Set Label_Justification_Mode to jMode_Right
85673>>>    End_Object    // oOrderHea_Order_Total
85674>>>
85674>>>    Object oPrintBtn is a Button
85676>>>        Set Label to "Print Order"
85677>>>        Set Location to 156 3
85678>>>        Set peAnchors to anBottomLeft
85679>>>        Set psToolTip to "Print preview of current order"
85680>>>
85680>>>        Procedure OnClick
85683>>>            Delegate Send PrintCurrentOrder // defined in view object
85685>>>        End_Procedure  // OnClick
85686>>>        
85686>>>    End_Object    // oPrintBtn
85687>>>
85687>>>
85687>>>    // Change:   Create custom confirmation messages for save and delete
85687>>>    //           We must create the new functions and assign verify messages
85687>>>    //           to them.
85687>>>    Function Confirm_Delete_Order Returns Integer
85690>>>        Integer iRetVal
85690>>>        Get Confirm "Delete Entire Order?" to iRetVal
85691>>>        Function_Return iRetVal
85692>>>    End_Function
85693>>>    
85693>>>    // Only confirm on the saving of new records
85693>>>    Function Confirm_Save_Order Returns Integer
85696>>>        Integer iNoSave iSrvr
85696>>>        Boolean bOld
85696>>>        Get Server to iSrvr
85697>>>        Get HasRecord of iSrvr to bOld
85698>>>        If not bOld Begin
85700>>>            Get Confirm "Save this NEW order header?" to iNoSave
85701>>>        End
85701>>>>
85701>>>        Function_Return iNoSave
85702>>>    End_Function
85703>>>    
85703>>>    // Define alternate confirmation Messages
85703>>>    Set Verify_Save_MSG       to (RefFunc(Confirm_Save_Order))
85704>>>    Set Verify_Delete_MSG     to (RefFunc(Confirm_Delete_Order))
85705>>>    Set Auto_Clear_DEO_State  to False // don't clear Header on save
85706>>>    
85706>>>    
85706>>>    // print the current order. This message will be sent
85706>>>    // by the print button
85706>>>    Procedure PrintCurrentOrder
85709>>>        Integer hDD iNum
85709>>>        Get Server to hDD // this will be the OrderHea DD
85710>>>        If (HasRecord(hDD)) Begin // only do this if record exists
85712>>>            Get Field_Current_Value of hDD Field OrderHea.Order_Number to iNum
85713>>>//            Send PrintOrder of oOrder_Report iNum
85713>>>            Send Info_Box "This is just a stub and this invoice is not actually being printed" ("Print Order " + String(iNum))
85714>>>        End
85714>>>>
85714>>>    End_Procedure
85715>>>    
85715>>>    // refresh is sent to containers. We will use that to control the print button and only
85715>>>    // enable it when an order exists
85715>>>    Procedure Refresh Integer eMode
85718>>>        Boolean bRec
85718>>>        Handle hoServer
85718>>>        Get Server to hoServer
85719>>>        Get HasRecord of hoServer to bRec
85720>>>        Set Enabled_State of oPrintBtn to bRec
85721>>>    End_Procedure
85722>>>
85722>>>End_Object
85723>    
85723>        Procedure Activate_About
85726>            Send DoAbout "Order Entry Sample Application" "18.2.1.0" "Copyright (c) 2016 Data Access Corporation" "Data Access Worldwide" ""
85727>        End_Procedure
85728>    
85728>    End_Object
85729>
85729>
85729>End_Object
85730>
85730>// open Order Entry view on application startup
85730>Send Activate_oOrderEntryView of (oClientArea(oMain))
85731>Start_UI
85732>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 47277
Total Resources: 0
Total Commands : 85731
Total Windows  : 5
Total Pages    : 4
Static Data    : 536581
Message area   : 609238
Total Blocks   : 30617
